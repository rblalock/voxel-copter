<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelCopter - Comanche-Style Terrain Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0f0;
            text-shadow: 1px 1px 2px #000, -1px -1px 2px #000;
            z-index: 100;
            pointer-events: none;
        }
        
        #fps {
            font-size: 18px;
            font-weight: bold;
            display: none;
        }
        
        #altitude {
            font-size: 14px;
            margin-top: 5px;
        }
        
        #speed {
            font-size: 14px;
        }
        
        #controls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: #fff;
            font-size: 11px;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #0a0;
            pointer-events: auto;
            max-width: 180px;
        }
        
        #controls h3 {
            color: #0f0;
            margin-bottom: 5px;
        }
        
        #mapSelector {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
            padding: 8px 12px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.7);
            color: #0f0;
            border: 2px solid #0f0;
            border-radius: 5px;
            cursor: pointer;
        }
        
        #mapSelector:hover {
            background: rgba(0,50,0,0.8);
        }
        
        #mapSelector option {
            background: #000;
            color: #0f0;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 24px;
            text-shadow: 0 0 10px #0f0;
            z-index: 200;
        }
        
        #title {
            position: fixed;
            top: 50px;
            right: 10px;
            color: #0f0;
            font-size: 12px;
            text-shadow: 0 0 5px #0f0;
            z-index: 100;
            text-align: right;
            pointer-events: none;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="fps">FPS: --</div>
        <div id="altitude">ALT: --</div>
        <div id="speed">SPD: --</div>
    </div>
    
    <select id="mapSelector">
        <option value="1">1 - Map 1</option>
        <option value="2">2 - Map 2</option>
        <option value="3">3 - Map 3</option>
        <option value="4">4 - Map 4</option>
        <option value="5">5 - Map 5</option>
        <option value="6">6 - Map 6</option>
        <option value="7">7 - Map 7</option>
        <option value="8">8 - Map 8</option>
        <option value="9">9 - Map 9</option>
        <option value="10">10 - Map 10</option>
        <option value="11">11 - Map 11</option>
        <option value="12">12 - Map 12</option>
        <option value="13">13 - Map 13</option>
        <option value="14">14 - Map 14</option>
        <option value="15">15 - Map 15</option>
        <option value="16">16 - Map 16</option>
        <option value="17">17 - Map 17</option>
        <option value="18">18 - Map 18</option>
        <option value="19">19 - Map 19</option>
        <option value="20">20 - Map 20</option>
        <option value="21">21 - Map 21</option>
        <option value="22">22 - Map 22</option>
        <option value="23">23 - Map 23</option>
        <option value="24">24 - Map 24</option>
        <option value="25">25 - Map 25</option>
        <option value="26">26 - Map 26</option>
        <option value="27">27 - Map 27</option>
        <option value="28">28 - Map 28</option>
        <option value="29">29 - Map 29</option>
    </select>
    
    <div id="title">
        VOXELCOPTER<br>
        <span style="font-size:10px; color:#0a0;">Comanche-Style Engine</span>
    </div>
    
    <div id="controls">
        <h3>CONTROLS [H to hide]</h3>
        <b style="color:#ff0">═══ COMANCHE (Helicopter) ═══</b><br>
        <b>Movement:</b><br>
        W/S - Forward/Back<br>
        A/D - Bank Left/Right<br>
        J/L - Yaw Left/Right<br>
        R/F - Altitude Up/Down<br>
        Q/E - Look Up/Down<br>
        Space - Boost<br>
        <b>Weapons:</b><br>
        1-4 - Select Weapon<br>
        Z/X or [ ] - Cycle Weapons<br>
        ; - Chaff | ' - Flare<br>
        <b>Targeting:</b><br>
        T - Target Crosshairs<br>
        Tab - Cycle Targets<br>
        <hr style="border-color:#0a0;margin:3px 0">
        <b style="color:#ff0">═══ DELTA (On Foot) ═══</b><br>
        <b>Movement:</b><br>
        WASD - Move | Mouse - Look<br>
        Shift - Sprint<br>
        Ctrl - Crouch | V - Prone<br>
        <b>Weapons:</b><br>
        Click - Fire | R - Reload<br>
        Z/X - Cycle Weapons<br>
        1-5 - Select Weapon<br>
        <b>Targeting:</b><br>
        T - Target Crosshairs<br>
        Tab - Cycle Targets<br>
        <hr style="border-color:#0a0;margin:3px 0">
        <b style="color:#ff0">═══ GENERAL ═══</b><br>
        E - Exit/Enter Heli<br>
        M - Weather | N - NVG<br>
        B - Sound | ESC - Pause<br>
        <hr style="border-color:#0a0;margin:3px 0">
        <label style="color:#0f0">Draw Distance:</label><br>
        <input type="range" id="distanceSlider" min="400" max="2000" value="1200" 
               style="width:100%;accent-color:#0f0" oninput="updateDistance(this.value)">
        <span id="distanceValue" style="color:#0f0">1200</span>
    </div>
    

    
    <div id="loading">LOADING TERRAIN...</div>

    <script src="/src/web/public/game.js"></script>
    <script>
    (function() {
        'use strict';
        
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            MAP_SIZE: 1024,
            MAP_SHIFT: 10,
            RENDER_DISTANCE: 1200,         // Increased for more expansive terrain feel
            MIN_ALTITUDE: 5,              // Can fly very low for nap-of-earth
            MAX_ALTITUDE: 800,            // Increased for taller terrain
            MOVE_SPEED: 0.25,             // Slow base movement (for simple controls)
            TURN_SPEED: 0.008,            // Slower turning
            CLIMB_SPEED: 0.25,            // Slightly faster climbing
            HORIZON_SPEED: 1.0,           // Look up/down speed
            BOOST_MULTIPLIER: 3.0,        // Boost for when you need speed
            SKY_COLOR: 0xFF8090E0,        // ABGR format for canvas
            FOG_START: 400,
            COLLISION_MARGIN: 5,          // Smaller margin - fly close to terrain
            // Combat settings
            TARGET_COUNT: 8,
            RADAR_SIZE: 100,
            RADAR_RANGE: 500,
            // Map boundaries (no wrapping)
            BOUNDARY_MARGIN: 50,          // Distance from edge where warning starts
            BOUNDARY_HARD: 20             // Hard boundary - can't go past this
        };
        
        // Boundary warning state
        let boundaryWarning = {
            active: false,
            direction: null,  // 'north', 'south', 'east', 'west'
            intensity: 0
        };

        // ============================================
        // GAME STATES
        // ============================================
        const GAME_STATES = {
            TITLE: 'title',
            MENU: 'menu',
            CAMPAIGN: 'campaign',
            FREEPLAY: 'freeplay',
            SETTINGS: 'settings',
            ACHIEVEMENTS: 'achievements',
            LEADERBOARD: 'leaderboard',
            HOWTO: 'howto',
            BRIEFING: 'briefing',
            PLAYING: 'playing',
            PAUSED: 'paused',
            VICTORY: 'victory',
            DEFEAT: 'defeat',
            MISSION_GENERATOR: 'mission_generator',
            CUSTOM_MISSION: 'custom_mission'
        };

        const GAME_MODES = { COMANCHE: 'comanche', DELTA: 'delta' };
        let gameMode = GAME_MODES.COMANCHE;
        
        let gameState = GAME_STATES.TITLE;
        let currentMissionIndex = 0;
        let missionTime = 0;
        let missionStartTime = 0;
        let defeatReason = '';
        let missionNoDamage = true;
        let playtimeAccumulator = 0;
        let lastMissionElapsed = 0;
        let activeMission = null;
        let activeAIMission = null;
        let aiMission = null;
        let pendingAIMission = null;
        let aiMissionBaseIndex = 0;
        let aiMissionMapIndex = null;
        let isGeneratingMission = false;
        let missionGeneratorInput = '';
        let missionGeneratorCursor = true;
        let missionGeneratorCursorTime = 0;
        let customMissionConfig = null;
        const CUSTOM_MISSION_KEY = 'voxelcopter_map_editor';
        
        const SETTINGS_KEY = 'voxelcopter_settings';
        const PROFILE_KEY = 'voxelcopter_profile';
        const DEFAULT_SETTINGS = {
            masterVolume: 0.5,
            sfxVolume: 0.7,
            mouseSensitivity: 1.0,
            invertY: false,
            drawDistance: CONFIG.RENDER_DISTANCE,
            fogEnabled: true,
            defaultMode: GAME_MODES.COMANCHE
        };
        const DEFAULT_PROFILE = {
            version: 1,
            highScore: 0,
            missionScores: {},
            missionStars: {},
            missionsCompleted: [],
            stats: {
                totalKills: 0,
                totalDeaths: 0,
                totalTimePlayed: 0,
                missionsPlayed: 0,
                missionsCompleted: 0,
                tanksDestroyed: 0,
                samsDestroyed: 0,
                buildingsDestroyed: 0
            },
            achievements: [],
            firstPlayDate: null,
            lastPlayDate: null
        };
        let settings = { ...DEFAULT_SETTINGS };
        let profile = { ...DEFAULT_PROFILE };
        let fogEnabled = true;
        let mouseSensitivity = 1.0;
        let invertY = false;

        // ============================================
        // GLOBAL STATS + LEADERBOARD
        // ============================================
        async function postStatsEvent(event) {
            try {
                await fetch('/api/stats/event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(event)
                });
            } catch (e) {
                console.warn('Failed to post stats event:', e);
            }
        }

        async function fetchGlobalStats() {
            try {
                const response = await fetch('/api/stats');
                if (response.ok) {
                    return await response.json();
                }
            } catch (e) {
                console.warn('Failed to fetch global stats:', e);
            }
            return null;
        }

        let cachedGlobalStats = null;
        let lastStatsFetch = 0;
        let lastLeaderboardName = localStorage.getItem('voxelcopter_playerName') || 'Pilot';

        function refreshGlobalStatsIfNeeded() {
            const now = performance.now();
            if (now - lastStatsFetch > 30000 || !cachedGlobalStats) {
                fetchGlobalStats().then((stats) => {
                    if (stats) cachedGlobalStats = stats;
                });
                lastStatsFetch = now;
            }
        }

        let sessionStats = {
            kills: 0,
            deaths: 0,
            score: 0,
            shotsFired: 0,
            hits: 0,
            submitted: false
        };

        // Session telemetry
        let telemetry = {
            shotsFired: 0,
            shotsHit: 0,
            missilesFired: 0,
            missilesHit: 0,
            missilesDodged: 0,
            damageDealt: 0,
            damageTaken: 0,
            distanceTraveled: 0,
            flightTime: 0,
            groundTime: 0,
            lastPosition: { x: 512, y: 512 }
        };

        function resetSessionStats() {
            sessionStats = {
                kills: 0,
                deaths: 0,
                score: 0,
                shotsFired: 0,
                hits: 0,
                submitted: false
            };
        }

        function resetTelemetry() {
            telemetry = {
                shotsFired: 0,
                shotsHit: 0,
                missilesFired: 0,
                missilesHit: 0,
                missilesDodged: 0,
                damageDealt: 0,
                damageTaken: 0,
                distanceTraveled: 0,
                flightTime: 0,
                groundTime: 0,
                lastPosition: { x: camera.x, y: camera.y }
            };
        }

        function updateTelemetry(deltaTime) {
            const dx = camera.x - telemetry.lastPosition.x;
            const dy = camera.y - telemetry.lastPosition.y;
            telemetry.distanceTraveled += Math.sqrt(dx * dx + dy * dy);
            telemetry.lastPosition = { x: camera.x, y: camera.y };

            if (gameMode === GAME_MODES.COMANCHE) {
                telemetry.flightTime += deltaTime / 1000;
                if (isHeliLanded(playerState.heli)) {
                    telemetry.groundTime += deltaTime / 1000;
                }
            } else {
                telemetry.groundTime += deltaTime / 1000;
            }
        }

        function submitSessionScore(finalScore) {
            if (godMode) return;  // Don't allow god mode scores
            if (sessionStats.submitted || !finalScore || finalScore <= 0) return;
            sessionStats.submitted = true;
            const defaultName = lastLeaderboardName || 'Pilot';
            const nameInput = prompt('Enter your name for the leaderboard:', defaultName);
            const playerName = (nameInput && nameInput.trim()) ? nameInput.trim() : 'Anonymous';
            lastLeaderboardName = playerName;
            localStorage.setItem('voxelcopter_playerName', playerName);
            
            // Get current map index from selector
            const mapSelectorEl = document.getElementById('mapSelector');
            const currentMap = mapSelectorEl ? parseInt(mapSelectorEl.value) : 1;
            
            // Determine mission info
            const missionNum = currentMissionIndex >= 0 ? currentMissionIndex + 1 : 0;
            const missionName = currentMissionIndex >= 0 ? `Mission ${missionNum}` : 'Free Play';
            
            postStatsEvent({ 
                type: 'high_score', 
                score: finalScore, 
                name: playerName,
                mission: missionNum,
                missionName: missionName,
                map: currentMap,
                mapName: `Map ${currentMap}`,
                kills: sessionStats.kills,
                missionsCompleted: missionComplete ? 1 : 0
            });
        }

        function calculateAccuracy() {
            const hasTelemetry = telemetry.shotsFired > 0 || telemetry.shotsHit > 0;
            const shots = hasTelemetry ? telemetry.shotsFired : sessionStats.shotsFired;
            const hits = hasTelemetry ? telemetry.shotsHit : sessionStats.hits;
            if (!shots) return 0;
            return Math.max(0, Math.min(100, Math.round((hits / shots) * 100)));
        }

        function trackEvent(name, properties) {
            try {
                window.agentuityAnalytics?.track(name, properties);
            } catch (e) {
                // Silently ignore analytics errors
            }
        }

        let showOnboardingHints = true;
        let onboardingStep = 0;
        const ONBOARDING_HINTS = [
            {
                condition: () => telemetry.flightTime < 30,
                text: 'Press H for controls'
            }
        ];

        function getActiveMission() {
            if (currentMissionIndex < 0) return null;
            return activeMission || MISSIONS[currentMissionIndex];
        }

        function normalizeDifficulty(difficulty) {
            if (difficulty === 'normal') return 'medium';
            if (difficulty === 'easy' || difficulty === 'medium' || difficulty === 'hard' || difficulty === 'extreme') {
                return difficulty;
            }
            return 'medium';
        }

        function deriveTargetCounts(aiConfig) {
            const counts = { tanks: 0, soldiers: 0, buildings: 0, sams: 0 };
            if (!aiConfig || !Array.isArray(aiConfig.entities)) return counts;
            for (const spec of aiConfig.entities) {
                const typeKey = String(spec.type || '').toUpperCase();
                const rawCount = Number(spec.count || 0);
                const count = Number.isFinite(rawCount) ? rawCount : 0;
                if (typeKey === 'TANK') counts.tanks += count;
                if (typeKey === 'SOLDIER') counts.soldiers += count;
                if (typeKey === 'SNIPER') counts.soldiers += count;  // Snipers count as soldiers
                if (typeKey === 'BUILDING') counts.buildings += count;
                if (typeKey === 'SAM_SITE') counts.sams += count;
            }
            return counts;
        }

        function buildMissionFromAI(aiConfig, baseMission) {
            const counts = deriveTargetCounts(aiConfig);
            const base = baseMission || MISSIONS[0];
            return {
                ...base,
                name: 'AI OPERATION',
                briefing: aiConfig.briefing || base.briefing,
                briefingDelta: aiConfig.briefingDelta || base.briefingDelta,
                objectives: Array.isArray(aiConfig.objectives) && aiConfig.objectives.length > 0 ? aiConfig.objectives : base.objectives,
                difficulty: normalizeDifficulty(aiConfig.difficulty || base.difficulty),
                timeLimit: typeof aiConfig.timeLimit === 'number' ? aiConfig.timeLimit : base.timeLimit,
                targets: {
                    tanks: counts.tanks,
                    buildings: counts.buildings,
                    sams: counts.sams
                },
                targetsDelta: {
                    soldiers: counts.soldiers,
                    buildings: counts.buildings,
                    sams: counts.sams
                },
                rewards: base.rewards
            };
        }

        function getBriefingMission() {
            const baseMission = MISSIONS[currentMissionIndex] || MISSIONS[0];
            if (pendingAIMission) {
                return buildMissionFromAI(pendingAIMission, baseMission);
            }
            
            // Try to merge cached layout data for more accurate briefing display
            if (baseMission.layoutFile && missionLayoutCache[baseMission.layoutFile]) {
                const layout = missionLayoutCache[baseMission.layoutFile];
                // Create a merged mission object for display
                const merged = { ...baseMission };
                if (layout.objectives && layout.objectives.length > 0) {
                    merged.objectives = layout.objectives;
                }
                if (layout.briefing) {
                    merged.briefing = layout.briefing;
                }
                if (layout.name) {
                    merged.name = layout.name;
                }
                return merged;
            }
            
            return baseMission;
        }
        
        // Preload mission layout when entering briefing screen
        async function preloadMissionLayout(missionIndex) {
            const mission = MISSIONS[missionIndex];
            if (mission && mission.layoutFile && !missionLayoutCache[mission.layoutFile]) {
                await loadMissionLayout(mission.layoutFile);
            }
        }

        function getCompletedObjectives() {
            const mission = getActiveMission();
            if (!mission || !Array.isArray(mission.objectives)) return 0;
            return missionComplete ? mission.objectives.length : 0;
        }

        function getTotalObjectives() {
            const mission = getActiveMission();
            if (!mission || !Array.isArray(mission.objectives)) return 0;
            return mission.objectives.length;
        }

        async function generateAIMission(prompt, difficulty = 'normal') {
            if (isGeneratingMission) return null;

            isGeneratingMission = true;
            const mapIndex = MISSIONS[currentMissionIndex]?.map ?? 0;
            aiMissionMapIndex = mapIndex;

            try {
                const response = await fetch('/api/mission/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        mode: gameMode,
                        difficulty,
                        mapIndex
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        aiMission = data.mission;
                        // Use currentMissionIndex if valid, otherwise default to 0
                        aiMissionBaseIndex = (currentMissionIndex >= 0 && currentMissionIndex < MISSIONS.length) ? currentMissionIndex : 0;
                        // Auto-start the mission immediately
                        if (gameState === GAME_STATES.MISSION_GENERATOR) {
                            pendingAIMission = aiMission;
                            aiMission = null;
                            currentMissionIndex = aiMissionBaseIndex;
                            playMenuConfirmSound();
                            startTransition(GAME_STATES.PLAYING, 900, {
                                hold: true,
                                onSwitch: () => startMission(currentMissionIndex, { onReady: releaseTransition })
                            });
                        }
                        return data.mission;
                    }
                }
            } catch (e) {
                console.warn('Failed to generate AI mission.');
            } finally {
                isGeneratingMission = false;
            }
            return null;
        }

        // ============================================
        // MISSION DEFINITIONS
        // ============================================
        const MISSIONS = [
            {
                id: 1,
                name: "TRAINING GROUND",
                map: 0,  // Map 1
                layoutFile: '/missions/mission-1.json',
                briefing: "Welcome, pilot. This is a training exercise. Destroy all enemy targets to complete the mission. Watch out for SAM sites - they will fire missiles at you.",
                briefingDelta: "Welcome, operator. This is your first field operation. Eliminate all enemy personnel in the area and secure the site.",
                objectives: [
                    { type: 'destroy_all', description: 'Destroy all enemy targets' }
                ],
                targets: {
                    tanks: 3,
                    buildings: 2,
                    sams: 1
                },
                targetsDelta: {
                    soldiers: 8,
                    buildings: 1,
                    sams: 0
                },
                difficulty: 'easy',
                timeLimit: null,  // No time limit
                rewards: { score: 1000 }
            },
            {
                id: 2,
                name: "VALLEY ASSAULT",
                map: 0,  // Map 1
                layoutFile: '/missions/mission-2.json',
                briefing: "Intelligence reports enemy armor moving through the valley. Neutralize all tanks before they reach the base. SAM coverage is light.",
                briefingDelta: "Enemy patrols are sweeping the valley. Clear all hostiles and dismantle their forward presence.",
                objectives: [
                    { type: 'destroy_all', description: 'Destroy all enemy forces' }
                ],
                targets: {
                    tanks: 5,
                    buildings: 1,
                    sams: 2
                },
                targetsDelta: {
                    soldiers: 12,
                    buildings: 1,
                    sams: 0
                },
                difficulty: 'medium',
                timeLimit: 180,  // 3 minutes
                rewards: { score: 2000 }
            },
            {
                id: 3,
                name: "MOUNTAIN STRIKE",
                map: 1,  // Map 2
                layoutFile: '/missions/mission-3.json',
                briefing: "A heavily fortified enemy base has been located in the mountains. Multiple SAM sites protect the area. Use terrain for cover and take out air defenses first.",
                briefingDelta: "Enemy forces have dug in across the ridgeline. Assault the position, neutralize all combatants, and destroy key structures.",
                objectives: [
                    { type: 'destroy_all', description: 'Destroy enemy base' }
                ],
                targets: {
                    tanks: 4,
                    buildings: 3,
                    sams: 4
                },
                targetsDelta: {
                    soldiers: 15,
                    buildings: 2,
                    sams: 0
                },
                difficulty: 'hard',
                timeLimit: 240,  // 4 minutes
                rewards: { score: 3000 }
            },
            {
                id: 4,
                name: "SEARCH AND DESTROY",
                map: 2,  // Map 3
                layoutFile: '/missions/mission-4.json',
                briefing: "Enemy forces are scattered across the region. Hunt them down and eliminate all targets. Watch your ammo - resupply is not available.",
                briefingDelta: "Multiple hostile squads are operating in the region. Search the area methodically and eliminate all enemy forces.",
                objectives: [
                    { type: 'destroy_all', description: 'Eliminate all hostiles' }
                ],
                targets: {
                    tanks: 6,
                    buildings: 2,
                    sams: 3
                },
                targetsDelta: {
                    soldiers: 18,
                    buildings: 2,
                    sams: 0
                },
                difficulty: 'hard',
                timeLimit: 300,  // 5 minutes
                rewards: { score: 4000 }
            },
            {
                id: 5,
                name: "FINAL OFFENSIVE",
                map: 1,  // Map 2
                layoutFile: '/missions/mission-5.json',
                briefing: "This is it, pilot. The enemy's main command center must be destroyed. Expect heavy resistance. All weapons authorized. Good luck.",
                briefingDelta: "Final assault. The enemy command center is heavily guarded. Break through, eliminate all defenders, and destroy the facility.",
                objectives: [
                    { type: 'destroy_all', description: 'Destroy command center' }
                ],
                targets: {
                    tanks: 8,
                    buildings: 4,
                    sams: 5
                },
                targetsDelta: {
                    soldiers: 25,
                    buildings: 3,
                    sams: 0
                },
                difficulty: 'extreme',
                timeLimit: 360,  // 6 minutes
                rewards: { score: 5000 }
            },
            {
                id: 6,
                name: "SHADOW STRIKE",
                map: 9,  // Map 10
                layoutFile: '/missions/mission-6.json',
                briefing: "COMANCHE mode not available for this mission.",
                briefingDelta: "Operator, this is a stealth infiltration. An enemy forward operating base houses their regional command center. Your mission: infiltrate the base perimeter, reach the control tower, and destroy it. Extraction point will be marked after the target is destroyed. Avoid detection if possible - a full alert will bring heavy reinforcements.",
                objectives: [
                    { type: 'destroy_type', targetType: 'CONTROL_TOWER', count: 1, description: 'Destroy the Command Center' },
                    { type: 'reach_location', x: 110, y: 110, radius: 50, description: 'Extract to the insertion point' }
                ],
                targets: { tanks: 0, buildings: 0, sams: 0 },
                targetsDelta: { soldiers: 20, buildings: 5, sams: 8 },
                difficulty: 'hard',
                timeLimit: 600,  // 10 minutes
                rewards: { score: 5000 },
                deltaOnly: true
            }
        ];

        function getCampaignMissionIndices() {
            const isDelta = gameMode === GAME_MODES.DELTA;
            const indices = [];
            for (let i = 0; i < MISSIONS.length; i++) {
                const mission = MISSIONS[i];
                if (mission.deltaOnly && !isDelta) continue;
                indices.push(i);
            }
            return indices;
        }

        function getCampaignSelectionIndexFromMission(missionIndex) {
            const indices = getCampaignMissionIndices();
            const idx = indices.indexOf(missionIndex);
            return idx >= 0 ? idx : 0;
        }

        function getCampaignMissionIndexFromSelection(selectionIndex) {
            const indices = getCampaignMissionIndices();
            if (indices.length === 0) return 0;
            const clamped = Math.max(0, Math.min(indices.length - 1, selectionIndex));
            return indices[clamped];
        }

        function syncCampaignSelectionForMode() {
            const indices = getCampaignMissionIndices();
            if (indices.length === 0) {
                campaignSelectionIndex = 0;
                currentMissionIndex = 0;
                return;
            }
            if (!indices.includes(currentMissionIndex)) {
                currentMissionIndex = indices[0];
            }
            campaignSelectionIndex = getCampaignSelectionIndexFromMission(currentMissionIndex);
        }
        
        // ============================================
        // MISSION OBJECTIVE SYSTEM
        // ============================================
        // Objective types:
        //   destroy_all     - Destroy all targets (default)
        //   destroy_type    - Destroy X targets of a specific type { type: 'TANK', count: 5 }
        //   destroy_count   - Destroy at least X targets total { count: 10 }
        //   reach_location  - Reach a specific area { x, y, radius }
        //   survive_time    - Survive for X seconds { duration: 60 }
        //   protect_target  - Keep a friendly target alive { targetId }
        
        const objectiveState = {
            objectives: [],      // Active objectives with progress
            events: [],          // Pending event triggers
            completed: [],       // Completed objective IDs
            failed: [],          // Failed objective IDs
            surviveStartTime: 0, // For survive_time objectives
            protectedTargets: [] // Targets that must stay alive
        };
        
        function initObjectives(mission) {
            objectiveState.objectives = [];
            objectiveState.events = [];
            objectiveState.completed = [];
            objectiveState.failed = [];
            objectiveState.surviveStartTime = performance.now();
            objectiveState.protectedTargets = [];
            
            if (!mission || !mission.objectives) return;
            
            mission.objectives.forEach((obj, index) => {
                objectiveState.objectives.push({
                    id: `obj_${index}`,
                    ...obj,
                    progress: 0,
                    total: getObjectiveTotal(obj),
                    complete: false,
                    failed: false
                });
                
                // Initialize protected targets
                if (obj.type === 'protect_target' && obj.targetId) {
                    objectiveState.protectedTargets.push(obj.targetId);
                }
            });
            
            // Initialize mission events
            if (mission.events) {
                mission.events.forEach((evt, index) => {
                    objectiveState.events.push({
                        id: `evt_${index}`,
                        ...evt,
                        triggered: false
                    });
                });
            }
        }
        
        function getObjectiveTotal(obj) {
            switch (obj.type) {
                case 'destroy_type':
                    return obj.count || 1;
                case 'destroy_count':
                    return obj.count || 1;
                case 'survive_time':
                    return obj.duration || 60;
                case 'destroy_all':
                    return -1; // Dynamic total based on spawned targets
                default:
                    return 1;
            }
        }
        
        function updateObjectiveProgress(action, data = {}) {
            if (missionComplete || isPlayerDead) return;
            
            objectiveState.objectives.forEach(obj => {
                if (obj.complete || obj.failed) return;
                
                switch (obj.type) {
                    case 'destroy_all':
                        // Handled by checkWinCondition
                        break;
                        
                    case 'destroy_type':
                        if (action === 'target_destroyed' && data.type === obj.targetType) {
                            obj.progress++;
                            if (obj.progress >= obj.total) {
                                obj.complete = true;
                                objectiveState.completed.push(obj.id);
                            }
                        }
                        break;
                        
                    case 'destroy_count':
                        if (action === 'target_destroyed') {
                            obj.progress++;
                            if (obj.progress >= obj.total) {
                                obj.complete = true;
                                objectiveState.completed.push(obj.id);
                            }
                        }
                        break;
                        
                    case 'reach_location':
                        if (action === 'position_update') {
                            const dx = data.x - obj.x;
                            const dy = data.y - obj.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const radius = obj.radius || 50;
                            if (dist < radius) {
                                obj.complete = true;
                                objectiveState.completed.push(obj.id);
                            }
                        }
                        break;
                        
                    case 'survive_time':
                        if (action === 'time_update') {
                            const elapsed = (performance.now() - objectiveState.surviveStartTime) / 1000;
                            obj.progress = Math.min(elapsed, obj.total);
                            if (elapsed >= obj.total) {
                                obj.complete = true;
                                objectiveState.completed.push(obj.id);
                            }
                        }
                        break;
                        
                    case 'protect_target':
                        if (action === 'target_destroyed' && data.id === obj.targetId) {
                            obj.failed = true;
                            objectiveState.failed.push(obj.id);
                        }
                        break;
                }
            });
            
            // Check event triggers
            updateEventTriggers(action, data);
        }
        
        function updateEventTriggers(action, data = {}) {
            objectiveState.events.forEach(evt => {
                if (evt.triggered) return;
                
                let shouldTrigger = false;
                
                switch (evt.trigger) {
                    case 'kill_count':
                        if (action === 'target_destroyed' && sessionStats.kills >= evt.count) {
                            shouldTrigger = true;
                        }
                        break;
                        
                    case 'time_elapsed':
                        if (action === 'time_update') {
                            const elapsed = (performance.now() - missionStartTime) / 1000;
                            if (elapsed >= evt.time) {
                                shouldTrigger = true;
                            }
                        }
                        break;
                        
                    case 'enter_zone':
                        if (action === 'position_update') {
                            const dx = data.x - evt.x;
                            const dy = data.y - evt.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < (evt.radius || 100)) {
                                shouldTrigger = true;
                            }
                        }
                        break;
                        
                    case 'objective_complete':
                        if (objectiveState.completed.includes(evt.objectiveId)) {
                            shouldTrigger = true;
                        }
                        break;
                }
                
                if (shouldTrigger) {
                    evt.triggered = true;
                    executeEvent(evt);
                }
            });
        }
        
        function executeEvent(evt) {
            switch (evt.action) {
                case 'spawn_enemies':
                    if (evt.enemies) {
                        evt.enemies.forEach(e => {
                            for (let i = 0; i < (e.count || 1); i++) {
                                const x = e.x + (Math.random() - 0.5) * (e.spread || 100);
                                const y = e.y + (Math.random() - 0.5) * (e.spread || 100);
                                spawnTargetAt(e.type || 'TANK', x, y);
                            }
                        });
                    }
                    break;
                    
                case 'show_message':
                    if (evt.message) {
                        showMissionMessage(evt.message, evt.duration || 3000);
                    }
                    break;
                    
                case 'add_objective':
                    if (evt.objective) {
                        const newObj = {
                            id: `obj_dyn_${objectiveState.objectives.length}`,
                            ...evt.objective,
                            progress: 0,
                            total: getObjectiveTotal(evt.objective),
                            complete: false,
                            failed: false
                        };
                        objectiveState.objectives.push(newObj);
                    }
                    break;
                    
                case 'complete_mission':
                    endMission(true);
                    break;
                    
                case 'fail_mission':
                    endMission(false, evt.reason || 'Mission failed');
                    break;
            }
        }
        
        // Mission message system
        let missionMessage = null;
        let missionMessageEnd = 0;
        
        function showMissionMessage(text, duration = 3000) {
            missionMessage = text;
            missionMessageEnd = performance.now() + duration;
        }
        
        function renderMissionMessage() {
            if (!missionMessage || performance.now() > missionMessageEnd) {
                missionMessage = null;
                return;
            }
            
            const alpha = Math.min(1, (missionMessageEnd - performance.now()) / 500);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff0';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText(missionMessage, screenWidth / 2, screenHeight * 0.25);
            ctx.fillText(missionMessage, screenWidth / 2, screenHeight * 0.25);
            ctx.restore();
        }
        
        function checkAllObjectivesComplete() {
            // If any objective failed, mission fails
            if (objectiveState.failed.length > 0) {
                const failedObj = objectiveState.objectives.find(o => o.failed);
                endMission(false, failedObj ? `FAILED: ${failedObj.description}` : 'Objective failed');
                return;
            }
            
            // Check if all objectives complete
            const allComplete = objectiveState.objectives.every(obj => obj.complete);
            if (allComplete && objectiveState.objectives.length > 0) {
                endMission(true);
            }
        }
        
        function getObjectiveProgressText(obj) {
            switch (obj.type) {
                case 'destroy_all':
                    const remaining = targets.filter(t => !t.destroyed).length;
                    return remaining === 0 ? 'COMPLETE' : `${remaining} remaining`;
                case 'destroy_type':
                case 'destroy_count':
                    return `${obj.progress}/${obj.total}`;
                case 'survive_time':
                    const remaining2 = Math.max(0, obj.total - obj.progress);
                    return `${Math.ceil(remaining2)}s`;
                case 'reach_location':
                    return obj.complete ? 'REACHED' : 'IN PROGRESS';
                case 'protect_target':
                    return obj.failed ? 'FAILED' : 'PROTECTED';
                default:
                    return obj.complete ? 'COMPLETE' : 'IN PROGRESS';
            }
        }
        
        // ============================================
        // WEAPON DEFINITIONS
        // ============================================
        const WEAPONS = {
            cannon: {
                name: 'CANNON',
                key: '1',
                ammo: Infinity,
                maxAmmo: Infinity,
                fireRate: 100,      // ms between shots
                damage: 25,
                projectileSpeed: 20,
                projectileType: 'bullet',
                color: '#ffff00',   // Yellow tracer
                spread: 0.02,       // Small spread for inaccuracy
                description: 'Rapid-fire cannon'
            },
            rockets: {
                name: 'ROCKETS',
                key: '2',
                ammo: 20,
                maxAmmo: 20,
                fireRate: 500,      // Slower rate
                damage: 75,
                projectileSpeed: 15,
                projectileType: 'rocket',
                color: '#ff6600',   // Orange
                spread: 0.01,
                description: 'Unguided rockets'
            },
            hellfire: {
                name: 'HELLFIRE',
                key: '3',
                ammo: 8,
                maxAmmo: 8,
                fireRate: 1000,     // Slow rate
                damage: 200,        // High damage
                projectileSpeed: 12,
                projectileType: 'missile',
                color: '#ff0000',   // Red
                spread: 0,
                guided: true,       // Tracks nearest target
                description: 'Laser-guided missile'
            },
            stinger: {
                name: 'STINGER',
                key: '4',
                ammo: 4,
                maxAmmo: 4,
                fireRate: 1500,     // Very slow
                damage: 150,
                projectileSpeed: 25, // Fast
                projectileType: 'missile',
                color: '#00ffff',   // Cyan
                spread: 0,
                guided: true,       // Tracks air targets
                airToAir: true,     // For enemy helicopters
                description: 'Heat-seeking missile'
            }
        };

        const WEAPONS_DELTA = {
            m4: {
                name: 'M4 Carbine',
                damage: 25,
                fireRate: 100,   // ms between shots
                spread: 0.02,
                magSize: 30,
                maxMags: 5,
                projectileSpeed: 20,
                color: '#ffaa00',
                auto: true,      // Hold to fire
                key: 'Digit1'
            },
            sniper: {
                name: 'M24 Sniper',
                damage: 100,
                fireRate: 1200,
                spread: 0.002,   // Very accurate
                magSize: 5,
                maxMags: 4,
                projectileSpeed: 30,
                color: '#ff4400',
                auto: false,     // Semi-auto
                key: 'Digit2'
            },
            pistol: {
                name: 'M9 Pistol',
                damage: 20,
                fireRate: 200,
                spread: 0.03,
                magSize: 15,
                maxMags: 3,
                projectileSpeed: 15,
                color: '#ffff00',
                auto: false,
                key: 'Digit3'
            },
            javelin: {
                name: 'Javelin',
                damage: 240,
                fireRate: 1800,
                spread: 0.005,
                magSize: 1,
                maxMags: 3,
                projectileSpeed: 10,
                color: '#ff8800',
                auto: false,
                guided: true,
                projectileType: 'missile',
                key: 'Digit4'
            },
            stinger: {
                name: 'Stinger',
                damage: 180,
                fireRate: 1500,
                spread: 0.003,
                magSize: 1,
                maxMags: 4,
                projectileSpeed: 18,
                color: '#00ccff',
                auto: false,
                guided: true,
                airToAir: true,
                projectileType: 'missile',
                key: 'Digit5'
            },
            c4: {
                name: 'C4 Explosive',
                damage: 400,
                fireRate: 500,     // Delay between placing charges
                spread: 0,
                magSize: 1,        // One charge "in hand"
                maxMags: 3,        // 3 total charges
                projectileSpeed: 0,
                color: '#ff4400',
                auto: false,
                explosive: true,
                blastRadius: 60,
                key: 'Digit6'
            },
            airstrike: {
                name: 'Airstrike',
                damage: 0,
                fireRate: 0,
                spread: 0,
                magSize: 1,
                maxMags: 2,
                projectileSpeed: 0,
                color: '#66ccff',
                auto: false,
                type: 'support',
                key: 'Digit7'
            }
        };

        const DAMAGE_MULTIPLIERS = {
            // Soldier weapons - heavily nerfed vs vehicles (small arms don't do much to armor)
            pistol: { soldier: 1.0, tank: 0.02, building: 0.02, sam: 0.05, aircraft: 0.08 },
            m4: { soldier: 1.0, tank: 0.03, building: 0.03, sam: 0.08, aircraft: 0.12 },
            sniper: { soldier: 1.5, tank: 0.06, building: 0.05, sam: 0.12, aircraft: 0.18 },
            // Helicopter weapons - effective vs all targets
            cannon: { soldier: 1.0, tank: 0.5, building: 0.3, sam: 0.8, aircraft: 1.0 },
            rockets: { soldier: 2.0, tank: 1.0, building: 0.8, sam: 1.0, aircraft: 1.5 },
            hellfire: { soldier: 3.0, tank: 1.5, building: 1.0, sam: 1.2, aircraft: 2.0 },
            // Anti-vehicle weapons - designed for specific targets
            stinger: { soldier: 1.0, tank: 0.1, building: 0.05, sam: 0.3, aircraft: 2.0 },  // Anti-air
            javelin: { soldier: 0.6, tank: 2.5, building: 0.6, sam: 1.2, aircraft: 0.4 },   // Anti-tank
            c4: { soldier: 3.0, tank: 2.0, building: 2.5, sam: 2.0, aircraft: 0.5 },        // Anti-structure
            airstrike: { soldier: 1.6, tank: 1.4, building: 1.3, sam: 1.3, aircraft: 0.4 }
        };

        function getTargetDamageCategory(target) {
            if (!target) return 'soldier';
            if (target.type === 'soldier') return 'soldier';
            if (target.type === 'sniper') return 'soldier';  // Snipers take same damage as soldiers
            if (target.type === 'tank') return 'tank';
            if (target.type === 'sam') return 'sam';
            if (target.domain === DOMAINS.AIR) return 'aircraft';
            if (target.domain === DOMAINS.STRUCTURE) return 'building';
            return 'soldier';
        }

        function getDamageMultiplier(weaponType, target) {
            const table = DAMAGE_MULTIPLIERS[weaponType];
            if (!table) return 1;
            const category = getTargetDamageCategory(target);
            return table[category] ?? 1;
        }
        
        // Weapon state (ammo tracking)
        // Note: Player cannon has no burst cooldown - can fire continuously
        // Enemy helicopters have burst cooldown defined in their AI config
        const weaponState = {
            cannon: { ammo: Infinity },
            rockets: { ammo: 20 },
            hellfire: { ammo: 8 },
            stinger: { ammo: 4 }
        };
        
        // Weapon cycling
        let currentWeaponIndex = 0;
        const weaponOrder = ['cannon', 'rockets', 'hellfire', 'stinger'];
        
        // Countermeasures
        const countermeasures = {
            chaff: { count: 10, cooldown: 2000, lastUsed: 0 },
            flare: { count: 10, cooldown: 2000, lastUsed: 0 }
        };
        
        // ============================================
        // TARGET TYPE DEFINITIONS
        // ============================================
        const FACTIONS = { ENEMY: 'enemy', FRIENDLY: 'friendly', NEUTRAL: 'neutral' };
        const DOMAINS = { GROUND: 'ground', AIR: 'air', STRUCTURE: 'structure', PLAYER: 'player' };
        const TARGET_TYPES = {
            TANK: {
                type: 'tank',
                health: 100,
                points: 100,
                size: 20,
                color: '#4a5c4a',  // Olive drab
                domain: DOMAINS.GROUND,
                faction: FACTIONS.ENEMY,
                hitHeight: 8,
                heightOffset: 0,      // Sits directly on terrain
                ai: {
                    type: 'patrol',
                    speed: 0.02,         // Very slow patrol
                    patrolRadius: 40,     // Smaller patrol area
                    detectRange: 250,
                    engageRange: 200,
                    fireRate: 2500,
                    bulletSpeed: 1.2,
                    bulletDamage: 25
                }
            },
            SOLDIER: {
                type: 'soldier',
                health: 60,
                maxHealth: 60,
                points: 100,
                size: 12,
                color: '#5a6b4a',  // Army green
                domain: DOMAINS.GROUND,
                faction: FACTIONS.ENEMY,
                hitHeight: 12,
                heightOffset: 7,   // Center mass height
                canShoot: true,
                ai: {
                    type: 'infantry',
                    detectRange: 200,
                    engageRange: 150,
                    fireRate: 800,    // ms between shots
                    accuracy: 0.05,   // Spread
                    bulletSpeed: 2.5,
                    bulletDamage: 8,
                    patrolRadius: 30,
                    patrolSpeed: 0.02
                }
            },
            SNIPER: {
                type: 'sniper',
                health: 40,           // Lower health - snipers are fragile
                maxHealth: 40,
                points: 150,          // Higher value target
                size: 12,
                color: '#3a4a3a',     // Darker green (camouflaged)
                domain: DOMAINS.GROUND,
                faction: FACTIONS.ENEMY,
                hitHeight: 12,
                heightOffset: 7,
                canShoot: true,
                ai: {
                    type: 'sniper',   // New AI type
                    detectRange: 400, // Much longer detection range
                    engageRange: 350, // Engages from much further away
                    fireRate: 2500,   // Slow fire rate (bolt action)
                    accuracy: 0.01,   // Very accurate
                    bulletSpeed: 4.0, // High velocity rounds
                    bulletDamage: 25, // High damage per shot
                    patrolRadius: 15, // Barely moves - holds position
                    patrolSpeed: 0.005  // Very slow when patrolling
                }
            },
            BUILDING: {
                type: 'building',
                health: 200,
                points: 200,
                size: 40,
                color: '#6b5a4a',  // Desert tan/brown
                domain: DOMAINS.STRUCTURE,
                faction: FACTIONS.ENEMY,
                hitHeight: 40,
                heightOffset: 0,      // Sits directly on terrain
                ai: null  // Buildings don't move
            },
            HANGAR: {
                type: 'hangar', domain: DOMAINS.STRUCTURE, faction: FACTIONS.ENEMY,
                health: 300, size: 50, hitHeight: 35, points: 250,
                color: '#5a5a5a', heightOffset: 0, ai: null
            },
            CONTROL_TOWER: {
                type: 'control_tower', domain: DOMAINS.STRUCTURE, faction: FACTIONS.ENEMY,
                health: 150, size: 20, hitHeight: 50, points: 300,
                color: '#6a6a6a', heightOffset: 0, ai: null
            },
            BARRACKS: {
                type: 'barracks', domain: DOMAINS.STRUCTURE, faction: FACTIONS.ENEMY,
                health: 180, size: 35, hitHeight: 20, points: 150,
                color: '#5a6a4a', heightOffset: 0, ai: null
            },
            FUEL_DEPOT: {
                type: 'fuel_depot', domain: DOMAINS.STRUCTURE, faction: FACTIONS.ENEMY,
                health: 100, size: 25, hitHeight: 15, points: 200,
                color: '#4a4a4a', heightOffset: 0, ai: null  // Explodes spectacularly when destroyed
            },
            HELIPAD: {
                type: 'helipad', domain: DOMAINS.STRUCTURE, faction: FACTIONS.ENEMY,
                health: 50, size: 30, hitHeight: 2, points: 50,
                color: '#3a3a3a', heightOffset: 0, ai: null
            },
            SAM_SITE: {
                type: 'sam',
                health: 150,
                points: 150,
                size: 25,
                color: '#3a4a3a',  // Dark military green
                domain: DOMAINS.STRUCTURE,
                faction: FACTIONS.ENEMY,
                hitHeight: 20,
                heightOffset: 0,      // Sits directly on terrain
                ai: {
                    type: 'sam',
                    fireRate: 8000,      // Fire every 8 seconds (increased from 4 for better balance)
                    range: 350,          // Detection range
                    missileSpeed: 1.5,   // Slower missile (was 8) - gives time to evade
                    missileDamage: 30
                }
            },
            AIR_FIGHTER: {
                type: 'air_fighter', domain: DOMAINS.AIR, faction: FACTIONS.ENEMY,
                health: 80, size: 18, hitHeight: 8, points: 400,
                color: '#5a5a6a',
                ai: {
                    type: 'aircraft',
                    role: 'fighter',
                    speed: 0.6,
                    turnRate: 0.015,
                    climbRate: 0.3,
                    preferredAlt: 250,
                    detectRange: 400,
                    engageRange: 250,
                    fireRate: 1200,
                    weaponType: 'air_missile',
                    bulletSpeed: 0.9,
                    bulletDamage: 45,
                    attackCooldown: 8000
                }
            },
            AIR_TRANSPORT: {
                type: 'air_transport', domain: DOMAINS.AIR, faction: FACTIONS.ENEMY,
                health: 150, size: 30, hitHeight: 12, points: 300,
                color: '#6a6a5a',
                ai: {
                    type: 'aircraft',
                    role: 'transport',
                    speed: 0.4,
                    turnRate: 0.008,
                    climbRate: 0.15,
                    preferredAlt: 200,
                    detectRange: 200,
                    engageRange: 0,  // Doesn't engage
                    fireRate: 0,
                    weaponType: null
                }
            },
            AIR_ATTACK_HELI: {
                type: 'air_attack_heli', domain: DOMAINS.AIR, faction: FACTIONS.ENEMY,
                health: 120, size: 22, hitHeight: 10, points: 350,
                color: '#3a3a3a',  // Dark charcoal for aggressive RHINO style
                ai: {
                    type: 'aircraft',
                    role: 'attack_heli',
                    speed: 0.18,
                    turnRate: 0.02,
                    climbRate: 0.25,
                    preferredAlt: 80,
                    detectRange: 300,
                    engageRange: 200,
                    fireRate: 180,
                    weaponType: 'air_cannon',
                    bulletSpeed: 1.4,
                    bulletDamage: 8,
                    burstCount: 5,       // Fire 5 shots per burst
                    burstCooldown: 2000  // 2 second cooldown between bursts
                }
            }
        };
        
        // ============================================
        // MAP DATA
        // ============================================
        const maps = [
            { color: '/src/web/public/maps/C1W.png', height: '/src/web/public/maps/D1.png', name: 'Map 1' },
            { color: '/src/web/public/maps/C2W.png', height: '/src/web/public/maps/D2.png', name: 'Map 2' },
            { color: '/src/web/public/maps/C3.png', height: '/src/web/public/maps/D3.png', name: 'Map 3' },
            { color: '/src/web/public/maps/C4.png', height: '/src/web/public/maps/D4.png', name: 'Map 4' },
            { color: '/src/web/public/maps/C5W.png', height: '/src/web/public/maps/D5.png', name: 'Map 5' },
            { color: '/src/web/public/maps/C6W.png', height: '/src/web/public/maps/D6.png', name: 'Map 6' },
            { color: '/src/web/public/maps/C7W.png', height: '/src/web/public/maps/D7.png', name: 'Map 7' },
            { color: '/src/web/public/maps/C8.png', height: '/src/web/public/maps/D6.png', name: 'Map 8' },
            { color: '/src/web/public/maps/C9W.png', height: '/src/web/public/maps/D9.png', name: 'Map 9' },
            { color: '/src/web/public/maps/C10W.png', height: '/src/web/public/maps/D10.png', name: 'Map 10' },
            { color: '/src/web/public/maps/C11W.png', height: '/src/web/public/maps/D11.png', name: 'Map 11' },
            { color: '/src/web/public/maps/C12W.png', height: '/src/web/public/maps/D11.png', name: 'Map 12' },
            { color: '/src/web/public/maps/C13.png', height: '/src/web/public/maps/D13.png', name: 'Map 13' },
            { color: '/src/web/public/maps/C14.png', height: '/src/web/public/maps/D14.png', name: 'Map 14' },
            { color: '/src/web/public/maps/C15.png', height: '/src/web/public/maps/D15.png', name: 'Map 15' },
            { color: '/src/web/public/maps/C16W.png', height: '/src/web/public/maps/D16.png', name: 'Map 16' },
            { color: '/src/web/public/maps/C17W.png', height: '/src/web/public/maps/D17.png', name: 'Map 17' },
            { color: '/src/web/public/maps/C18W.png', height: '/src/web/public/maps/D18.png', name: 'Map 18' },
            { color: '/src/web/public/maps/C19W.png', height: '/src/web/public/maps/D19.png', name: 'Map 19' },
            { color: '/src/web/public/maps/C20W.png', height: '/src/web/public/maps/D20.png', name: 'Map 20' },
            { color: '/src/web/public/maps/C21.png', height: '/src/web/public/maps/D21.png', name: 'Map 21' },
            { color: '/src/web/public/maps/C22W.png', height: '/src/web/public/maps/D22.png', name: 'Map 22' },
            { color: '/src/web/public/maps/C23W.png', height: '/src/web/public/maps/D21.png', name: 'Map 23' },
            { color: '/src/web/public/maps/C24W.png', height: '/src/web/public/maps/D24.png', name: 'Map 24' },
            { color: '/src/web/public/maps/C25W.png', height: '/src/web/public/maps/D25.png', name: 'Map 25' },
            { color: '/src/web/public/maps/C26W.png', height: '/src/web/public/maps/D18.png', name: 'Map 26' },
            { color: '/src/web/public/maps/C27W.png', height: '/src/web/public/maps/D15.png', name: 'Map 27' },
            { color: '/src/web/public/maps/C28W.png', height: '/src/web/public/maps/D25.png', name: 'Map 28' },
            { color: '/src/web/public/maps/C29W.png', height: '/src/web/public/maps/D16.png', name: 'Map 29' }
        ];
        
        let currentMap = {
            width: CONFIG.MAP_SIZE,
            height: CONFIG.MAP_SIZE,
            shift: CONFIG.MAP_SHIFT,
            altitude: null,   // Uint8Array
            color: null       // Uint32Array (ABGR)
        };
        
        // ============================================
        // CAMERA STATE
        // ============================================
        const camera = {
            x: 512,
            y: 512,
            height: 150,
            angle: 0,
            horizon: 100,
            distance: CONFIG.RENDER_DISTANCE,
            // Helicopter flight dynamics
            bank: 0,              // Roll angle in radians (positive = right bank)
            bankVelocity: 0,      // Rate of bank change
            pitch: 0,             // Pitch angle (for visual, separate from horizon)
            yawRate: 0,           // Current turn rate
            forwardSpeed: 0,      // Current forward velocity
            lateralSpeed: 0,      // Sideslip velocity
            verticalSpeed: 0      // Climb/descent rate
        };

        let playerState = {
            mode: GAME_MODES.COMANCHE,
            heli: {
                x: 512,
                y: 512,
                z: 25,  // Lower spawn height so it's near ground level
                angle: 0,
                bank: 0,
                forwardSpeed: 0,
                lateralSpeed: 0,
                verticalSpeed: 0,
                health: 200,
                maxHealth: 200,
                destroyed: false,
                visible: true // Whether to render in world
            },
            soldier: {
                x: 512,
                y: 512,
                stance: 'stand',
                health: 100
            },
            activeVehicle: 'heli' // 'heli' or 'soldier'
        };

        const SOLDIER = {
            stance: 'stand',  // 'stand', 'crouch', 'prone'
            eyeHeights: { stand: 14, crouch: 9, prone: 4 },
            speeds: {
                stand: 0.15,    // Walking speed
                sprint: 0.28,   // Sprinting
                crouch: 0.075,  // Crouch walk
                prone: 0.0375   // Prone crawl
            },
            velocity: { x: 0, y: 0 },
            accel: 0.008,
            friction: 0.85,
            isSprinting: false,
            stanceChanging: false,
            headBob: 0,
            headBobSpeed: 0.15
        };

        let soldierWeapon = {
            current: 'm4',
            weapons: {
                m4: { mag: 30, mags: 5, lastFire: 0 },
                sniper: { mag: 5, mags: 4, lastFire: 0 },
                pistol: { mag: 15, mags: 3, lastFire: 0 },
                javelin: { mag: 1, mags: 3, lastFire: 0 },
                stinger: { mag: 1, mags: 4, lastFire: 0 },
                c4: { mag: 1, mags: 3, lastFire: 0 },
                airstrike: { mag: 1, mags: 2, lastFire: 0 }
            },
            isReloading: false,
            reloadStartTime: 0,
            reloadDuration: 2000,  // 2 seconds
            viewBob: 0,
            recoilOffset: 0,
            muzzleFlashTime: 0
        };
        
        // C4 charges placed in the world (can be detonated remotely)
        let placedC4Charges = [];

        const airstrikeState = {
            designating: false,
            targetX: null,
            targetY: null,
            targetZ: null,
            planesInbound: [],
            lastCallTime: 0,
            inboundMessageUntil: 0
        };

        let soldierScope = {
            active: false,
            zoom: 4,
            transitionTime: 0
        };
        
        // Helicopter physics - tuned for realistic helicopter feel
        const HELI_PHYSICS = {
            MAX_BANK: Math.PI / 4,        // 45 degrees max bank
            BANK_RATE: 0.012,             // How fast bank changes (reduced)
            BANK_RETURN: 0.015,           // How fast bank returns to level
            TURN_BANK_RATIO: 0.001,       // Turn rate per unit of bank (reduced)
            MAX_FORWARD_SPEED: 0.3,       // Slower forward (reduced from 0.4)
            ACCELERATION: 0.005,          // Gradual acceleration (reduced)
            DECELERATION: 0.003,          // Gradual deceleration
            LATERAL_DRIFT: 0.01,          // Slight sideslip when banking
            MAX_YAW_RATE: 0.008,          // Direct yaw rate (for J/L keys)
            PITCH_RATE: 0.5               // Slower pitch changes
        };
        
        // ============================================
        // COMBAT STATE
        // ============================================
        let targets = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let explosions = [];
        let score = 0;
        let currentWeapon = 'cannon';
        let lastFireTime = 0;
        let playerHealth = 100;
        let maxPlayerHealth = 100;
        let isPlayerDead = false;
        let missionComplete = false;

        // Alert system for infiltration gameplay (Delta mode)
        let alertLevel = 0;  // 0=undetected, 1=suspicious, 2=alert, 3=full alarm
        let alertTimer = 0;
        const ALERT_DURATION = 30000;  // ms

        let world = {
            stamps: [],
            airports: [],  // { id, x, y, heading, length, width, faction, entities: [] }
            bases: [],     // { id, x, y, faction, buildings: [], defenses: [] }
            helipads: []   // { id, x, y, faction }
        };

        const ENTITY_BUDGET = {
            maxGround: 50,
            maxAir: 8,
            maxStructures: 30,
            maxTotal: 80
        };

        let airportSpawnTimers = {};
        let helipadSpawnTimers = {};
        
        // Missile warning system
        let missileWarning = false;
        let missileWarningTime = 0;
        
        // ============================================
        // TARGETING SYSTEM
        // ============================================
        const targetingSystem = {
            lockedTarget: null,         // Currently locked target
            selectedTarget: null,       // Currently selected (but not locked) target
            lockProgress: 0,            // 0-100 lock acquisition progress
            lockStartTime: 0,           // When lock acquisition started
            isLocking: false,           // Currently acquiring lock
            lastCycleTime: 0,           // Debounce for target cycling
            
            // Lock times in ms for different weapon types
            lockTimes: {
                hellfire: 1500,         // 1.5s for laser designation
                stinger: 1000,          // 1.0s for IR lock
                javelin: 2000,          // 2.0s for top-attack lock (Delta mode)
            },
            
            // Get valid target types for current weapon
            getValidTargetTypes() {
                const weapon = gameMode === GAME_MODES.DELTA 
                    ? soldierWeapon.current 
                    : weaponOrder[currentWeaponIndex];
                    
                if (weapon === 'stinger') {
                    return { domain: DOMAINS.AIR, requiresLock: true };
                } else if (weapon === 'hellfire' || weapon === 'javelin') {
                    // 'surface' = ground + structure targets (not air)
                    return { domain: 'surface', requiresLock: true };
                } else {
                    return { domain: null, requiresLock: false }; // Any target, no lock needed
                }
            },
            
            // Check if a target is valid for current weapon
            isValidTarget(target) {
                if (!target || target.destroyed) return false;
                if (target.faction !== FACTIONS.ENEMY) return false;
                
                const validTypes = this.getValidTargetTypes();
                if (validTypes.domain) {
                    if (validTypes.domain === 'surface') {
                        // Surface targets = ground + structure (not air)
                        if (target.domain === DOMAINS.AIR) return false;
                    } else if (target.domain !== validTypes.domain) {
                        return false;
                    }
                }
                
                return true;
            },
            
            // Get lock time for current weapon
            getLockTime() {
                const weapon = gameMode === GAME_MODES.DELTA 
                    ? soldierWeapon.current 
                    : weaponOrder[currentWeaponIndex];
                return this.lockTimes[weapon] || 0;
            },
            
            // Reset targeting state
            reset() {
                this.lockedTarget = null;
                this.selectedTarget = null;
                this.lockProgress = 0;
                this.isLocking = false;
                this.lockStartTime = 0;
            },
            
            // Get appropriate targeting range for current weapon
            getTargetingRange() {
                const weapon = gameMode === GAME_MODES.DELTA 
                    ? soldierWeapon.current 
                    : weaponOrder[currentWeaponIndex];
                    
                // Long-range guided missiles (Hellfire, Javelin)
                if (weapon === 'hellfire' || weapon === 'javelin') {
                    return 2000;
                }
                // Medium-range AA missiles (Stinger)
                if (weapon === 'stinger') {
                    return 1200;
                }
                // Other weapons - general awareness range
                return 800;
            }
        };
        
        // Screen flash effect
        let screenFlashColor = null;
        let screenFlashTime = 0;
        
        // Screen shake system
        let screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9, duration: 0 };
        
        // Combat feedback overlays
        let muzzleFlashTime = 0;
        let muzzleFlashIntensity = 0;
        let hitMarkerTime = 0;
        let hitMarkerIntensity = 0;
        let damageVignetteTime = 0;
        let damageVignetteIntensity = 0;
        
        // Night vision / IR mode
        let nightVisionMode = false;
        
        // Debug/God mode
        let godMode = false;
        
        // Simple controls mode (direct turning like original VoxelSpace)
        let simpleControls = false;
        
        // Weather/visibility conditions
        let weatherCondition = 'clear';  // 'clear', 'dusk', 'night', 'fog', 'storm'
        const WEATHER_SETTINGS = {
            clear: {
                skyColor: 0xFF8090E0,      // Bright blue sky
                fogStart: 400,
                fogDensity: 1.0,
                ambient: 1.0,
                name: 'CLEAR'
            },
            dusk: {
                skyColor: 0xFF4040A0,      // Orange/purple dusk
                fogStart: 300,
                fogDensity: 1.2,
                ambient: 0.7,
                name: 'DUSK'
            },
            night: {
                skyColor: 0xFF101018,      // Very dark blue/black
                fogStart: 150,
                fogDensity: 2.0,
                ambient: 0.15,
                name: 'NIGHT'
            },
            fog: {
                skyColor: 0xFF909090,      // Gray fog
                fogStart: 80,
                fogDensity: 3.0,
                ambient: 0.5,
                name: 'FOG'
            },
            storm: {
                skyColor: 0xFF303040,      // Dark stormy
                fogStart: 100,
                fogDensity: 2.5,
                ambient: 0.3,
                name: 'STORM',
                hasRain: true,
                rainIntensity: 1.0
            }
        };
        
        // ============================================
        // RAIN PARTICLE SYSTEM
        // ============================================
        const MAX_RAIN_PARTICLES = 300;
        let rainParticles = [];
        let lightningFlash = 0;       // Lightning flash intensity (0-1)
        let nextLightningTime = 0;    // Time until next lightning strike

        // ============================================
        // DESTRUCTION PARTICLE SYSTEM
        // ============================================
        const MAX_PARTICLES = 200;
        const PARTICLE_GRAVITY = 120;
        let particles = [];
        let particlePool = [];

        function getPooledParticle() {
            return particlePool.pop() || {};
        }

        function recycleParticle(index) {
            const p = particles[index];
            particlePool.push(p);
            particles[index] = particles[particles.length - 1];
            particles.pop();
        }

        function spawnParticles(x, y, z, type, count) {
            if (!count || count <= 0) return;

            for (let i = 0; i < count; i++) {
                if (particles.length >= MAX_PARTICLES) return;

                const p = getPooledParticle();
                p.x = x;
                p.y = y;
                p.z = z;
                p.vx = 0;
                p.vy = 0;
                p.vz = 0;
                p.type = type;
                p.size = 2;
                p.growth = 0;
                p.color = null;

                if (type === 'spark') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 80 + Math.random() * 80;
                    const lift = 40 + Math.random() * 40;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.vz = lift;
                    p.life = 0.25 + Math.random() * 0.15;
                    p.size = 1.5 + Math.random() * 1.5;
                    p.color = { r: 255, g: 180 + Math.random() * 60, b: 60 };
                } else if (type === 'smoke') {
                    const angle = Math.random() * Math.PI * 2;
                    // Smaller, subtler smoke in Delta (FPS) mode
                    const isDelta = gameMode === GAME_MODES.DELTA;
                    const speed = isDelta ? (4 + Math.random() * 6) : (8 + Math.random() * 12);
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.vz = isDelta ? (6 + Math.random() * 8) : (12 + Math.random() * 18);
                    p.life = isDelta ? (0.4 + Math.random() * 0.4) : (1.0 + Math.random() * 1.0);
                    p.size = isDelta ? (2 + Math.random() * 2) : (6 + Math.random() * 6);
                    p.growth = isDelta ? (4 + Math.random() * 4) : (12 + Math.random() * 14);
                    const shade = 60 + Math.floor(Math.random() * 50);
                    p.color = { r: shade, g: shade, b: shade };
                } else if (type === 'debris') {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 30 + Math.random() * 40;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.vz = 50 + Math.random() * 40;
                    p.life = 0.8 + Math.random() * 0.5;
                    p.size = 2 + Math.random() * 2.5;
                    const shade = 70 + Math.floor(Math.random() * 40);
                    p.color = { r: shade, g: shade * 0.9, b: shade * 0.8 };
                } else if (type === 'dust') {
                    const terrainHeight = getTerrainHeight(x, y);
                    p.z = terrainHeight + 1;
                    p.life = 0.35 + Math.random() * 0.25;
                    p.size = 8 + Math.random() * 6;
                    p.growth = 60 + Math.random() * 40;
                    p.color = { r: 120, g: 110, b: 90 };
                } else if (type === 'blood') {
                    // Blood splatter for soldier deaths
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 20 + Math.random() * 30;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.vz = 30 + Math.random() * 40;
                    p.life = 0.4 + Math.random() * 0.3;
                    p.size = 2 + Math.random() * 3;
                    // Dark red color
                    p.color = { r: 120 + Math.floor(Math.random() * 40), g: 20 + Math.floor(Math.random() * 20), b: 20 + Math.floor(Math.random() * 20) };
                } else if (type === 'trail_smoke') {
                    // Subtle smoke trail for rockets/missiles - small, short-lived
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.vz = Math.random() * 2;
                    p.life = 0.25 + Math.random() * 0.15;  // Short-lived (250-400ms)
                    p.size = 2 + Math.random() * 2;        // Small (2-4 pixels)
                    p.growth = 3 + Math.random() * 2;      // Slow growth
                    const shade = 80 + Math.floor(Math.random() * 40);
                    p.color = { r: shade, g: shade, b: shade };
                } else if (type === 'muzzle_flash') {
                    // Brief muzzle flash for enemy firing - very short-lived
                    p.vx = 0;
                    p.vy = 0;
                    p.vz = 0;
                    p.life = 0.06 + Math.random() * 0.03;  // Very brief (60-90ms)
                    p.size = 6 + Math.random() * 4;        // Medium flash (6-10 pixels)
                    p.growth = 0;
                    p.color = { r: 255, g: 220 + Math.floor(Math.random() * 35), b: 100 + Math.floor(Math.random() * 50) };  // Yellow-orange flash
                }

                p.maxLife = p.life;
                particles.push(p);
            }
        }

        function updateParticles(deltaTime) {
            const dt = deltaTime * 0.001;
            if (dt <= 0) return;

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= dt;
                if (p.life <= 0) {
                    recycleParticle(i);
                    continue;
                }

                if (p.type === 'dust') {
                    p.size += p.growth * dt;
                    const terrainHeight = getTerrainHeight(p.x, p.y);
                    p.z = terrainHeight + 1;
                } else {
                    p.x += p.vx * dt;
                    p.y += p.vy * dt;
                    p.z += p.vz * dt;
                }

                // Despawn particles outside map boundaries (no wrapping)
                if (isOutsideBoundary(p.x, p.y)) {
                    particles.splice(i, 1);
                    continue;
                }

                if (p.type === 'smoke') {
                    p.size += p.growth * dt;
                }

                if (p.type === 'spark') {
                    p.vz -= PARTICLE_GRAVITY * 0.35 * dt;
                }

                if (p.type === 'debris') {
                    p.vz -= PARTICLE_GRAVITY * dt;
                    const terrainHeight = getTerrainHeight(p.x, p.y);
                    if (p.z <= terrainHeight) {
                        p.z = terrainHeight;
                        p.vx *= 0.4;
                        p.vy *= 0.4;
                        p.vz = 0;
                    }
                }

                // Blood particles fall with gravity
                if (p.type === 'blood') {
                    p.vz -= PARTICLE_GRAVITY * 0.8 * dt;
                    const terrainHeight = getTerrainHeight(p.x, p.y);
                    if (p.z <= terrainHeight) {
                        p.z = terrainHeight;
                        p.vx = 0;
                        p.vy = 0;
                        p.vz = 0;
                    }
                }

                // Trail smoke grows slowly like regular smoke
                if (p.type === 'trail_smoke') {
                    p.size += p.growth * dt;
                }
                
                // Muzzle flash just fades out - no movement needed (already handled by life/alpha)
            }
        }

        function renderParticles(cam) {
            if (particles.length === 0) return;

            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);

            for (const p of particles) {
                let dx = p.x - cam.x;
                let dy = p.y - cam.y;

                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;

                if (ry > 5 && ry < cam.distance) {
                    // Check terrain occlusion for particles
                    if (isProjectileOccluded(p, cam, dx, dy, ry)) {
                        continue;
                    }
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;

                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
                    const screenY = (cam.height - p.z) * scaleY + cam.horizon + bankOffset;

                    const size = Math.max(1, p.size * scaleY);
                    const alpha = Math.max(0, p.life / p.maxLife);

                    if (screenX > -size && screenX < screenWidth + size &&
                        screenY > -size && screenY < screenHeight + size) {
                        if (p.type === 'spark') {
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (p.type === 'smoke') {
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.6})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (p.type === 'debris') {
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.9})`;
                            ctx.fillRect(screenX - size * 0.5, screenY - size * 0.5, size, size);
                        } else if (p.type === 'dust') {
                            ctx.strokeStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.4})`;
                            ctx.lineWidth = Math.max(1, size * 0.15);
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.stroke();
                        } else if (p.type === 'blood') {
                            // Blood splatter - small dark red droplets
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.85})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (p.type === 'trail_smoke') {
                            // Subtle smoke trail for rockets/missiles - lower opacity
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (p.type === 'muzzle_flash') {
                            // Brief bright muzzle flash - high opacity, yellow-orange
                            ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${alpha * 0.7})`;
                            ctx.beginPath();
                            ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }
        
        function initRainParticles() {
            rainParticles = [];
            for (let i = 0; i < MAX_RAIN_PARTICLES; i++) {
                rainParticles.push({
                    x: Math.random() * screenWidth,
                    y: Math.random() * screenHeight,
                    length: 10 + Math.random() * 20,
                    speed: 15 + Math.random() * 10,
                    opacity: 0.3 + Math.random() * 0.4
                });
            }
        }
        
        function updateRainParticles(deltaTime) {
            const weather = WEATHER_SETTINGS[weatherCondition];
            if (!weather.hasRain) return;
            
            const intensity = weather.rainIntensity || 1.0;
            const windOffset = Math.sin(performance.now() / 2000) * 2;  // Slight wind variation
            
            for (const drop of rainParticles) {
                // Move rain down and slightly sideways (wind effect)
                drop.y += drop.speed * intensity;
                drop.x += windOffset;
                
                // Wrap around screen
                if (drop.y > screenHeight) {
                    drop.y = -drop.length;
                    drop.x = Math.random() * screenWidth;
                }
                if (drop.x > screenWidth) drop.x = 0;
                if (drop.x < 0) drop.x = screenWidth;
            }
            
            // Update lightning
            if (lightningFlash > 0) {
                lightningFlash -= deltaTime * 0.005;  // Fade out
                if (lightningFlash < 0) lightningFlash = 0;
            }
            
            // Random lightning strikes during storm
            if (weatherCondition === 'storm' && performance.now() > nextLightningTime) {
                // 20% chance of lightning every few seconds
                if (Math.random() < 0.2) {
                    lightningFlash = 0.8 + Math.random() * 0.2;  // Bright flash
                    // TODO: Could add thunder sound here
                }
                nextLightningTime = performance.now() + 3000 + Math.random() * 7000;  // 3-10 seconds
            }
        }
        
        function renderRainEffect() {
            const weather = WEATHER_SETTINGS[weatherCondition];
            if (!weather.hasRain) return;
            
            const intensity = weather.rainIntensity || 1.0;
            const windOffset = Math.sin(performance.now() / 2000) * 2;
            
            ctx.save();
            
            // Draw rain drops
            ctx.strokeStyle = 'rgba(180, 200, 220, 0.6)';
            ctx.lineWidth = 1;
            
            for (const drop of rainParticles) {
                ctx.globalAlpha = drop.opacity * intensity;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x + windOffset * 2, drop.y + drop.length);
                ctx.stroke();
            }
            
            // Rain splash effect at bottom of screen (simulates ground splash)
            ctx.globalAlpha = 0.3 * intensity;
            for (let i = 0; i < 20; i++) {
                const splashX = Math.random() * screenWidth;
                const splashY = screenHeight - 5 - Math.random() * 30;
                const splashSize = 1 + Math.random() * 2;
                ctx.beginPath();
                ctx.arc(splashX, splashY, splashSize, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Lightning flash overlay
            if (lightningFlash > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${lightningFlash * 0.4})`;
                ctx.fillRect(0, 0, screenWidth, screenHeight);
            }
            
            // Rain streaks on "windshield" effect (subtle)
            if (intensity > 0.5) {
                ctx.save();
                ctx.globalAlpha = 0.1;
                ctx.strokeStyle = 'rgba(200, 220, 255, 0.3)';
                ctx.lineWidth = 2;
                
                // A few longer streaks to simulate water on cockpit glass
                for (let i = 0; i < 5; i++) {
                    const streakX = Math.random() * screenWidth;
                    const streakY = Math.random() * screenHeight * 0.5;
                    const streakLen = 30 + Math.random() * 50;
                    
                    ctx.beginPath();
                    ctx.moveTo(streakX, streakY);
                    // Slightly curved streak
                    ctx.quadraticCurveTo(
                        streakX + 5, streakY + streakLen / 2,
                        streakX + 2, streakY + streakLen
                    );
                    ctx.stroke();
                }
                ctx.restore();
            }
        }
        
        // ============================================
        // SCREEN/RENDERING STATE
        // ============================================
        let canvas, ctx, imageData, buf8, buf32;
        let hiddenYBuffer;
        let screenWidth, screenHeight;
        
        // ============================================
        // INPUT STATE
        // ============================================
        const keys = {};
        let currentSpeed = 0;
        let mouseX = 0;
        let mouseY = 0;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let isPointerDown = false;
        let mouseLeftDown = false;
        let mouseRightDown = false;
        let activeSlider = null;
        let deltaTriggerHeld = false;
        let deltaTriggerPressed = false;
        let comancheTriggerHeld = false;

        // Menu navigation state
        const MAIN_MENU_OPTIONS = ['MODE', 'CAMPAIGN', 'RANDOM MISSION', 'FREE PLAY', 'AI MISSION', 'MAP EDITOR', 'SETTINGS', 'ACHIEVEMENTS', 'LEADERBOARD', 'HOW TO PLAY'];
        const FREEPLAY_OPTIONS = ['LAUNCH FREE PLAY', 'BACK TO MENU'];
        const PAUSE_OPTIONS = ['RESUME [ESC]', 'RESTART MISSION', 'QUIT TO MENU'];
        const SETTINGS_ITEMS = [
            { key: 'masterVolume', label: 'MASTER VOLUME', type: 'slider', min: 0, max: 1, step: 0.01 },
            { key: 'sfxVolume', label: 'SFX VOLUME', type: 'slider', min: 0, max: 1, step: 0.01 },
            { key: 'mouseSensitivity', label: 'MOUSE SENSITIVITY', type: 'slider', min: 0.5, max: 2.0, step: 0.05 },
            { key: 'invertY', label: 'INVERT Y', type: 'toggle' },
            { key: 'drawDistance', label: 'DRAW DISTANCE', type: 'slider', min: 400, max: 2000, step: 50 },
            { key: 'fogEnabled', label: 'FOG', type: 'toggle' },
            { key: 'back', label: 'BACK TO MENU', type: 'action' }
        ];
        let menuSelectionIndex = 0;
        let campaignSelectionIndex = 0;
        let freePlaySelectionIndex = 0;
        let settingsSelectionIndex = 0;
        let pauseSelectionIndex = 0;
        let leaderboardScrollOffset = 0;
        let menuButtons = [];
        let settingsControls = [];
        let pauseButtons = [];

        // Achievement system
        const ACHIEVEMENTS = {
            first_blood: { name: 'First Blood', desc: 'Destroy your first target', icon: '🎯' },
            tank_hunter: { name: 'Tank Hunter', desc: 'Destroy 10 tanks', icon: '🚗' },
            sam_buster: { name: 'SAM Buster', desc: 'Destroy 5 SAM sites', icon: '🚀' },
            survivor: { name: 'Survivor', desc: 'Complete a mission without taking damage', icon: '🛡️' },
            speed_demon: { name: 'Speed Demon', desc: 'Complete a mission in under 60 seconds', icon: '⚡' },
            ace_pilot: { name: 'Ace Pilot', desc: 'Complete all 5 missions', icon: '🏆' },
            high_scorer: { name: 'High Scorer', desc: 'Score over 10,000 points', icon: '💯' },
            dedicated: { name: 'Dedicated', desc: 'Play for 30 minutes total', icon: '⏰' },
            veteran: { name: 'Veteran', desc: 'Complete 3 missions', icon: '🎖️' },
            scorched_earth: { name: 'Scorched Earth', desc: 'Destroy 10 buildings', icon: '🏗️' }
        };
        const ACHIEVEMENT_TOAST_DURATION = 3000;
        const ACHIEVEMENT_TOAST_SLIDE = 260;
        let achievementToasts = [];
        
        // ============================================
        // PERFORMANCE TRACKING
        // ============================================
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;
        let fpsUpdateTime = 0;
        let transition = {
            active: false,
            alpha: 0,
            phase: 'out',
            duration: 0,
            startTime: 0,
            targetState: null,
            onSwitch: null,
            hold: false,
            switched: false
        };
        
        // ============================================
        // AUDIO SYSTEM
        // ============================================
        let audioCtx = null;
        let masterVolume = null;
        let sfxVolume = null;
        let soundEnabled = true;
        let rotorOscillator = null;
        let rotorLfo = null;
        let rotorGain = null;
        let warningInterval = null;
        let windSource = null;
        let windGain = null;
        let windFilter = null;
        let noiseBuffer = null;
        
        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterVolume = audioCtx.createGain();
                sfxVolume = audioCtx.createGain();
                masterVolume.connect(audioCtx.destination);
                sfxVolume.connect(masterVolume);
                applyAudioSettings();
            } catch (e) {
                console.warn('Web Audio API not supported');
                soundEnabled = false;
            }
        }
        
        function initAudioOnInteraction() {
            if (!audioCtx) {
                initAudio();
            }
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            if (!soundEnabled) {
                stopRotorSound();
                stopWarningAlarm();
                stopWindSound();
            }
            if (soundEnabled) {
                if (gameState === GAME_STATES.PLAYING) {
                    startRotorSound();
                    startWindSound();
                }
            }
        }

        function applyAudioSettings() {
            if (!masterVolume || !sfxVolume) return;
            masterVolume.gain.value = settings.masterVolume;
            sfxVolume.gain.value = settings.sfxVolume;
        }

        function getNoiseBuffer() {
            if (noiseBuffer || !audioCtx) return noiseBuffer;
            const bufferSize = Math.floor(audioCtx.sampleRate * 2);
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noiseBuffer = buffer;
            return noiseBuffer;
        }

        function startWindSound() {
            if (!soundEnabled || !audioCtx || windSource) return;
            const buffer = getNoiseBuffer();
            if (!buffer) return;
            windSource = audioCtx.createBufferSource();
            windFilter = audioCtx.createBiquadFilter();
            windGain = audioCtx.createGain();
            windSource.buffer = buffer;
            windSource.loop = true;
            windFilter.type = 'highpass';
            windFilter.frequency.value = 180;
            windGain.gain.value = 0;
            windSource.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(sfxVolume);
            windSource.start();
        }

        function stopWindSound() {
            try {
                if (windSource) {
                    windSource.stop();
                    windSource.disconnect();
                    windSource = null;
                }
                if (windFilter) {
                    windFilter.disconnect();
                    windFilter = null;
                }
                if (windGain) {
                    windGain.disconnect();
                    windGain = null;
                }
            } catch (e) {
                // Ignore errors
            }
        }

        function updateWindSound() {
            if (!windGain || !audioCtx) return;
            const maxSpeed = Math.max(0.01, HELI_PHYSICS.MAX_FORWARD_SPEED);
            const speedNorm = Math.min(1, Math.abs(camera.forwardSpeed) / maxSpeed);
            const targetGain = 0.02 + speedNorm * 0.12;
            const targetFilter = 180 + speedNorm * 1000;
            windGain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.08);
            if (windFilter) {
                windFilter.frequency.setTargetAtTime(targetFilter, audioCtx.currentTime, 0.08);
            }
        }

        function updateRotorSound() {
            if (!rotorOscillator || !rotorGain || !audioCtx) return;
            const maxSpeed = Math.max(0.01, HELI_PHYSICS.MAX_FORWARD_SPEED);
            const speedNorm = Math.min(1, Math.abs(camera.forwardSpeed) / maxSpeed);
            const climbNorm = Math.min(1, Math.abs(camera.verticalSpeed) / (CONFIG.CLIMB_SPEED || 1));
            const baseFreq = 38;
            const targetFreq = baseFreq * (1 + speedNorm * 0.6 + climbNorm * 0.4);
            const targetGain = 0.09 + speedNorm * 0.05 + climbNorm * 0.04;
            rotorOscillator.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.07);
            rotorGain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.08);
            if (rotorLfo) {
                rotorLfo.frequency.setTargetAtTime(8 + speedNorm * 4, audioCtx.currentTime, 0.1);
            }
        }

        function playMenuNavigateSound() {
            if (!soundEnabled || !audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(520, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(360, audioCtx.currentTime + 0.08);
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                osc.connect(gain);
                gain.connect(sfxVolume);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.08);
            } catch (e) {
                console.warn('Error playing menu navigate sound:', e);
            }
        }

        function playMenuConfirmSound() {
            if (!soundEnabled || !audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(820, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(520, audioCtx.currentTime + 0.12);
                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.12);
                osc.connect(gain);
                gain.connect(sfxVolume);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.12);
            } catch (e) {
                console.warn('Error playing menu confirm sound:', e);
            }
        }

        function playAchievementSound() {
            if (!soundEnabled || !audioCtx) return;
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(660, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(980, audioCtx.currentTime + 0.18);
                gain.gain.setValueAtTime(0.14, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.18);
                osc.connect(gain);
                gain.connect(sfxVolume);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } catch (e) {
                console.warn('Error playing achievement sound:', e);
            }
        }

        function playVictoryStinger() {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            gain.gain.setValueAtTime(0.0, now);
            const notes = [392, 523, 659];
            notes.forEach((freq, idx) => {
                const t = now + idx * 0.18;
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0.16, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.16);
            });
            osc.connect(gain);
            gain.connect(sfxVolume);
            osc.start(now);
            osc.stop(now + 0.6);
        }

        function playDefeatStinger() {
            if (!soundEnabled || !audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.0, now);
            const notes = [330, 277, 220];
            notes.forEach((freq, idx) => {
                const t = now + idx * 0.2;
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(0.14, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
            });
            osc.connect(gain);
            gain.connect(sfxVolume);
            osc.start(now);
            osc.stop(now + 0.7);
        }
        
        // Rotor/Engine Sound (looping) - only for helicopter mode
        function startRotorSound() {
            // Don't play rotor sound in Delta (soldier) mode
            if (gameMode === GAME_MODES.DELTA) return;
            if (!soundEnabled || !audioCtx || rotorOscillator) return;
            
            try {
                // Create low-frequency "thwop thwop" helicopter rotor
                rotorOscillator = audioCtx.createOscillator();
                rotorGain = audioCtx.createGain();
                
                rotorOscillator.type = 'sawtooth';
                rotorOscillator.frequency.value = 40;  // Low frequency
                
                // Create modulation for "chopping" effect
                rotorLfo = audioCtx.createOscillator();
                const lfoGain = audioCtx.createGain();
                rotorLfo.frequency.value = 8;  // 8 Hz modulation (blade frequency)
                lfoGain.gain.value = 20;
                
                rotorLfo.connect(lfoGain);
                lfoGain.connect(rotorOscillator.frequency);
                
                rotorOscillator.connect(rotorGain);
                rotorGain.gain.value = 0.12;
                rotorGain.connect(sfxVolume);
                
                rotorOscillator.start();
                rotorLfo.start();
            } catch (e) {
                console.warn('Error starting rotor sound:', e);
            }
        }
        
        function stopRotorSound() {
            try {
                if (rotorOscillator) {
                    rotorOscillator.stop();
                    rotorOscillator.disconnect();
                    rotorOscillator = null;
                }
                if (rotorLfo) {
                    rotorLfo.stop();
                    rotorLfo.disconnect();
                    rotorLfo = null;
                }
                if (rotorGain) {
                    rotorGain.disconnect();
                    rotorGain = null;
                }
            } catch (e) {
                // Ignore errors when stopping
            }
        }
        
        // Cannon Fire Sound
        function playCannonSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                // White noise burst for gunshot
                const bufferSize = Math.floor(audioCtx.sampleRate * 0.05);  // 50ms
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                
                gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(sfxVolume);
                
                noise.start();
            } catch (e) {
                console.warn('Error playing cannon sound:', e);
            }
        }
        
        // Rocket Launch Sound
        function playRocketSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                // Whoosh sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                
                gain.gain.setValueAtTime(0.18, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                
                osc.connect(gain);
                gain.connect(sfxVolume);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.warn('Error playing rocket sound:', e);
            }
        }
        
        // Missile Launch Sound (Hellfire/Stinger)
        function playMissileSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                // Higher pitched than rocket
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                
                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                
                osc.connect(gain);
                gain.connect(sfxVolume);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            } catch (e) {
                console.warn('Error playing missile sound:', e);
            }
        }
        
        // Explosion Sound
        function playExplosionSound(size = 'medium') {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                const duration = size === 'large' ? 0.5 : size === 'medium' ? 0.35 : 0.2;
                const volume = size === 'large' ? 0.35 : size === 'medium' ? 0.25 : 0.15;
                
                // Low frequency rumble + noise
                const osc = audioCtx.createOscillator();
                const noiseGain = audioCtx.createGain();
                const oscGain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                // Noise component
                const bufferSize = Math.floor(audioCtx.sampleRate * duration);
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + duration);
                
                noiseGain.gain.setValueAtTime(volume, audioCtx.currentTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(sfxVolume);
                
                // Bass thump
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + duration);
                
                oscGain.gain.setValueAtTime(volume * 0.5, audioCtx.currentTime);
                oscGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                osc.connect(oscGain);
                oscGain.connect(sfxVolume);
                
                noise.start();
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) {
                console.warn('Error playing explosion sound:', e);
            }
        }
        
        // Hit Sound (bullet impact)
        function playHitSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'square';
                osc.frequency.value = 150;
                
                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
                
                osc.connect(gain);
                gain.connect(sfxVolume);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.05);
            } catch (e) {
                console.warn('Error playing hit sound:', e);
            }
        }
        
        // Missile Warning Alarm
        function playMissileWarningBeep() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                // Beeping alarm
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'square';
                osc.frequency.value = 800;
                
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(sfxVolume);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } catch (e) {
                console.warn('Error playing warning beep:', e);
            }
        }
        
        function startWarningAlarm() {
            if (warningInterval || !soundEnabled) return;
            playMissileWarningBeep();
            warningInterval = setInterval(playMissileWarningBeep, 500);  // Beep every 500ms
        }
        
        function stopWarningAlarm() {
            if (warningInterval) {
                clearInterval(warningInterval);
                warningInterval = null;
            }
        }
        
        // Player Damage Sound
        function playDamageSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                // Crunch/impact sound
                const bufferSize = Math.floor(audioCtx.sampleRate * 0.1);
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
                }
                
                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;
                
                const gain = audioCtx.createGain();
                gain.gain.value = 0.25;
                
                noise.connect(gain);
                gain.connect(sfxVolume);
                
                noise.start();
            } catch (e) {
                console.warn('Error playing damage sound:', e);
            }
        }
        
        // Countermeasure Deploy Sound
        function playCountermeasureSound() {
            if (!soundEnabled || !audioCtx) return;
            
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.15);
                
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                
                osc.connect(gain);
                gain.connect(sfxVolume);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            } catch (e) {
                console.warn('Error playing countermeasure sound:', e);
            }
        }

        // ============================================
        // SETTINGS STORAGE
        // ============================================
        function loadSettings() {
            try {
                const stored = localStorage.getItem(SETTINGS_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    settings = { ...DEFAULT_SETTINGS, ...parsed };
                }
            } catch (e) {
                settings = { ...DEFAULT_SETTINGS };
            }
            applySettings();
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            } catch (e) {
                // Ignore storage errors (private mode, etc.)
            }
        }

        function applySettings() {
            settings.masterVolume = Math.max(0, Math.min(1, settings.masterVolume));
            settings.sfxVolume = Math.max(0, Math.min(1, settings.sfxVolume));
            settings.mouseSensitivity = Math.max(0.5, Math.min(2.0, settings.mouseSensitivity));
            settings.drawDistance = Math.max(400, Math.min(2000, settings.drawDistance));
            settings.defaultMode = normalizeGameMode(settings.defaultMode);
            fogEnabled = settings.fogEnabled;
            mouseSensitivity = settings.mouseSensitivity;
            invertY = settings.invertY;
            camera.distance = Math.round(settings.drawDistance);
            settings.drawDistance = camera.distance;
            gameMode = settings.defaultMode;
            applyAudioSettings();
            const distanceSlider = document.getElementById('distanceSlider');
            const distanceValue = document.getElementById('distanceValue');
            if (distanceSlider) distanceSlider.value = camera.distance;
            if (distanceValue) distanceValue.textContent = camera.distance;
        }

        function normalizeGameMode(mode) {
            return mode === GAME_MODES.DELTA ? GAME_MODES.DELTA : GAME_MODES.COMANCHE;
        }

        function toggleGameMode() {
            gameMode = gameMode === GAME_MODES.COMANCHE ? GAME_MODES.DELTA : GAME_MODES.COMANCHE;
            settings.defaultMode = gameMode;
            saveSettings();
            syncCampaignSelectionForMode();
        }

        // ============================================
        // PROFILE STORAGE
        // ============================================
        function loadProfile() {
            try {
                const stored = localStorage.getItem(PROFILE_KEY);
                if (stored) {
                    const parsed = JSON.parse(stored);
                    profile = {
                        ...DEFAULT_PROFILE,
                        ...parsed,
                        stats: { ...DEFAULT_PROFILE.stats, ...(parsed.stats || {}) }
                    };
                    profile.missionScores = parsed.missionScores || {};
                    profile.missionStars = parsed.missionStars || {};
                    profile.missionsCompleted = Array.isArray(parsed.missionsCompleted)
                        ? parsed.missionsCompleted.map(id => String(id))
                        : [];
                    profile.achievements = Array.isArray(parsed.achievements) ? parsed.achievements : [];
                }
            } catch (e) {
                profile = { ...DEFAULT_PROFILE };
            }
        }

        function saveProfile() {
            try {
                localStorage.setItem(PROFILE_KEY, JSON.stringify(profile));
            } catch (e) {
                // Ignore storage errors
            }
        }

        function touchProfile() {
            const now = new Date().toISOString();
            if (!profile.firstPlayDate) profile.firstPlayDate = now;
            profile.lastPlayDate = now;
        }

        function updateStats(stat, amount) {
            if (!profile.stats || !(stat in profile.stats)) return;
            profile.stats[stat] = Math.max(0, (profile.stats[stat] || 0) + amount);
            touchProfile();
            saveProfile();
        }

        function recordHighScore(value) {
            if (value > (profile.highScore || 0)) {
                profile.highScore = value;
                touchProfile();
                saveProfile();
                checkAchievements('score', { score: value });
            }
        }

        function recordMissionCompletion(mission, totalScore, starsEarned) {
            const missionId = String(mission.id);
            if (!profile.missionsCompleted.includes(missionId)) {
                profile.missionsCompleted.push(missionId);
            }
            profile.missionScores[missionId] = Math.max(profile.missionScores[missionId] || 0, totalScore);
            profile.missionStars[missionId] = Math.max(profile.missionStars[missionId] || 0, starsEarned);
            profile.stats.missionsCompleted = (profile.stats.missionsCompleted || 0) + 1;
            touchProfile();
            saveProfile();
        }

        function formatDuration(seconds) {
            const total = Math.max(0, Math.floor(seconds));
            const mins = Math.floor(total / 60);
            const secs = total % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function hasAchievement(id) {
            return profile.achievements.includes(id);
        }

        function unlockAchievement(id) {
            if (!ACHIEVEMENTS[id] || hasAchievement(id)) return;
            profile.achievements.push(id);
            touchProfile();
            saveProfile();
            queueAchievementToast(id);
            playAchievementSound();
        }

        function checkAchievements(trigger, data = {}) {
            if (trigger === 'kill') {
                if (profile.stats.totalKills >= 1) unlockAchievement('first_blood');
                if (profile.stats.tanksDestroyed >= 10) unlockAchievement('tank_hunter');
                if (profile.stats.samsDestroyed >= 5) unlockAchievement('sam_buster');
                if (profile.stats.buildingsDestroyed >= 10) unlockAchievement('scorched_earth');
            }

            if (trigger === 'mission_complete') {
                if (data.noDamage) unlockAchievement('survivor');
                if (data.elapsed && data.elapsed < 60) unlockAchievement('speed_demon');
                if (profile.missionsCompleted.length >= 3) unlockAchievement('veteran');
                if (profile.missionsCompleted.length >= MISSIONS.length) unlockAchievement('ace_pilot');
            }

            if (trigger === 'score') {
                if ((data.score || 0) >= 10000) unlockAchievement('high_scorer');
            }

            if (trigger === 'stats') {
                if (profile.stats.totalTimePlayed >= 1800) unlockAchievement('dedicated');
                if (profile.missionsCompleted.length >= 3) unlockAchievement('veteran');
            }
        }

        function queueAchievementToast(id) {
            const achievement = ACHIEVEMENTS[id];
            if (!achievement) return;
            achievementToasts.push({
                id,
                title: achievement.name,
                desc: achievement.desc,
                icon: achievement.icon,
                startTime: performance.now()
            });
        }

        function renderAchievementToasts() {
            if (!achievementToasts.length) return;
            const now = performance.now();
            const toastWidth = 280;
            const toastHeight = 60;
            const padding = 14;

            achievementToasts = achievementToasts.filter((toast) => now - toast.startTime < ACHIEVEMENT_TOAST_DURATION);
            ctx.save();
            achievementToasts.forEach((toast, index) => {
                const elapsed = now - toast.startTime;
                const remaining = ACHIEVEMENT_TOAST_DURATION - elapsed;
                const targetX = screenWidth - toastWidth - 20;
                const startX = screenWidth + toastWidth + 20;
                let x = targetX;
                let alpha = 1;

                if (elapsed < ACHIEVEMENT_TOAST_SLIDE) {
                    const t = elapsed / ACHIEVEMENT_TOAST_SLIDE;
                    const ease = 1 - Math.pow(1 - t, 3);
                    x = startX + (targetX - startX) * ease;
                    alpha = Math.min(1, t + 0.2);
                } else if (remaining < ACHIEVEMENT_TOAST_SLIDE) {
                    const t = remaining / ACHIEVEMENT_TOAST_SLIDE;
                    const ease = 1 - Math.pow(1 - t, 3);
                    x = targetX + (1 - ease) * (toastWidth + 40);
                    alpha = Math.max(0, t);
                }

                const y = screenHeight - 80 - toastHeight - index * (toastHeight + 10);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = 'rgba(0, 30, 0, 0.9)';
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.fillRect(x, y, toastWidth, toastHeight);
                ctx.strokeRect(x, y, toastWidth, toastHeight);

                ctx.font = '20px Courier New';
                ctx.fillStyle = '#ff0';
                ctx.textAlign = 'left';
                ctx.fillText(toast.icon, x + 10, y + 34);

                ctx.font = 'bold 14px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText(toast.title.toUpperCase(), x + 40, y + 24);
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#0a0';
                ctx.fillText(toast.desc, x + 40, y + 44);
                ctx.globalAlpha = 1;
            });
            ctx.restore();
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Hide some UI elements initially
            document.getElementById('controls').style.display = 'none';
            document.getElementById('title').style.display = 'none';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('mapSelector').style.display = 'none';

            loadSettings();
            loadProfile();
            touchProfile();
            saveProfile();
            
            // Map selector change handler
            document.getElementById('mapSelector').addEventListener('change', function(e) {
                const mapIndex = parseInt(e.target.value) - 1;  // Convert 1-based to 0-based
                if (mapIndex >= 0 && mapIndex < maps.length) {
                    loadMap(mapIndex);
                }
            });

            canvas.addEventListener('mousemove', handlePointerMove);
            canvas.addEventListener('mousedown', handlePointerDown);
            canvas.addEventListener('mouseup', handlePointerUp);
            canvas.addEventListener('mouseleave', handlePointerUp);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Keyboard input
            document.addEventListener('keydown', (e) => {
                // Handle menu input first
                if (handleMenuInput(e)) {
                    e.preventDefault();
                    return;
                }

                if (e.code === 'F1') {
                    showOnboardingHints = !showOnboardingHints;
                    e.preventDefault();
                    return;
                }
                
                keys[e.code] = true;
                // Prevent scrolling
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                    e.preventDefault();
                }
                
                // Only allow these during gameplay
                if (gameState === GAME_STATES.PLAYING) {
                    if (gameMode === GAME_MODES.DELTA) {
                        if (e.code === 'Digit1') switchSoldierWeapon('m4');
                        if (e.code === 'Digit2') switchSoldierWeapon('sniper');
                        if (e.code === 'Digit3') switchSoldierWeapon('pistol');
                        if (e.code === 'Digit4') switchSoldierWeapon('javelin');
                        if (e.code === 'Digit5') switchSoldierWeapon('stinger');
                        if (e.code === 'Digit6') switchSoldierWeapon('c4');
                        if (e.code === 'Digit7') switchSoldierWeapon('airstrike');
                        if (e.code === 'KeyR') startSoldierReload();
                        // Delta mode weapon cycling with Z/X
                        if (e.code === 'KeyZ') cycleSoldierWeapon(-1); // Previous weapon
                        if (e.code === 'KeyX') cycleSoldierWeapon(1);  // Next weapon
                    }
                    // Comanche mode weapon controls
                    if (gameMode === GAME_MODES.COMANCHE) {
                        // Direct weapon selection with 1-4
                        if (e.code === 'Digit1') { currentWeaponIndex = 0; currentWeapon = weaponOrder[0]; targetingSystem.reset(); }
                        if (e.code === 'Digit2') { currentWeaponIndex = 1; currentWeapon = weaponOrder[1]; targetingSystem.reset(); }
                        if (e.code === 'Digit3') { currentWeaponIndex = 2; currentWeapon = weaponOrder[2]; targetingSystem.reset(); }
                        if (e.code === 'Digit4') { currentWeaponIndex = 3; currentWeapon = weaponOrder[3]; targetingSystem.reset(); }
                        // Weapon cycling with Z/X and [ ]
                        if (e.code === 'KeyZ') prevWeapon();
                        if (e.code === 'KeyX') nextWeapon();
                        if (e.code === 'BracketRight') nextWeapon();
                        if (e.code === 'BracketLeft') prevWeapon();
                    }
                    // Countermeasures
                    if (e.code === 'Semicolon') deployCountermeasure('chaff');
                    if (e.code === 'Quote') deployCountermeasure('flare');

                    // God mode toggle (debug)
                    if (e.code === 'KeyG') {
                        godMode = !godMode;
                        console.log('God mode:', godMode ? 'ON' : 'OFF');
                    }
                    // Night vision toggle
                    if (e.code === 'KeyN') {
                        nightVisionMode = !nightVisionMode;
                        console.log('Night Vision:', nightVisionMode ? 'ON' : 'OFF');
                    }
                    // Target what's in crosshairs
                    if (e.code === 'KeyT') {
                        selectTargetInCrosshairs();
                    }
                    // Simple controls toggle (direct turn like original VoxelSpace)
                    if (e.code === 'Backquote') {
                        simpleControls = !simpleControls;
                        // Reset bank when switching to simple controls
                        if (simpleControls) {
                            camera.bank = 0;
                            camera.bankVelocity = 0;
                        }
                        console.log('Simple Controls:', simpleControls ? 'ON' : 'OFF');
                    }
                    // Toggle controls display
                    if (e.code === 'KeyH') {
                        const controls = document.getElementById('controls');
                        controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
                    }
                    // Cycle weather conditions
                    if (e.code === 'KeyM') {
                        const conditions = ['clear', 'dusk', 'night', 'fog', 'storm'];
                        const currentIndex = conditions.indexOf(weatherCondition);
                        weatherCondition = conditions[(currentIndex + 1) % conditions.length];
                        console.log('Weather:', WEATHER_SETTINGS[weatherCondition].name);
                    }

                    // Exit/Enter helicopter
                    if (e.code === 'KeyE') {
                        if (gameMode === GAME_MODES.COMANCHE && isHeliLanded(playerState.heli)) {
                            exitHeliToSoldier();
                        } else if (gameMode === GAME_MODES.DELTA && canEnterHeli()) {
                            enterHeli();
                        }
                    }
                    
                    // Targeting system
                    if (e.code === 'Tab') {
                        e.preventDefault();
                        if (e.shiftKey) {
                            cycleTarget(-1); // Previous target
                        } else {
                            cycleTarget(1);  // Next target
                        }
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'KeyC' || e.code === 'KeyX') {
                    SOLDIER.stanceChanging = false;
                }
            });

            // Start in title state - load first map for background
            gameState = GAME_STATES.TITLE;
            loadMap(0);
            
            // Check for playtest mission from map editor
            checkPlaytestMission();
        }
        
        // ============================================
        // PLAYTEST MISSION HANDLING
        // ============================================
        function checkPlaytestMission() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('playtest') === '1') {
                const missionData = localStorage.getItem('playtestMission');
                if (missionData) {
                    try {
                        const config = JSON.parse(missionData);
                        // Clear it so it doesn't persist
                        localStorage.removeItem('playtestMission');
                        
                        // Check for mode parameter
                        const playtestMode = urlParams.get('mode');
                        if (playtestMode === 'delta') {
                            gameMode = GAME_MODES.DELTA;
                        } else if (playtestMode === 'comanche') {
                            gameMode = GAME_MODES.COMANCHE;
                        }
                        // If no mode specified, use current gameMode (default)
                        
                        // Start the playtest after a short delay to let map load
                        setTimeout(() => {
                            loadPlaytestMission(config);
                        }, 500);
                    } catch (e) {
                        console.error('Failed to load playtest mission:', e);
                    }
                }
            }
        }
        
        function loadPlaytestMission(config) {
            // Set custom mission config and start it
            customMissionConfig = config;
            
            // Skip title screen and go directly to playing
            startTransition(GAME_STATES.PLAYING, 900, {
                hold: true,
                onSwitch: () => {
                    startCustomMission({ onReady: releaseTransition });
                }
            });
        }
        
        // ============================================
        // MENU INPUT HANDLING
        // ============================================
        function handleMenuInput(e) {
            // Initialize audio on any key press (browser requirement)
            initAudioOnInteraction();

            if (transition.active) return true;
            
            // Sound toggle works in all states
            if (e.code === 'KeyB') {
                toggleSound();
                return true;
            }

            if (gameState === GAME_STATES.TITLE) {
                if (!e.repeat) {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 900);
                }
                return true;
            }
            
            if (gameState === GAME_STATES.MENU) {
                if (e.code === 'KeyG' && !e.repeat) {
                    if (isGeneratingMission) return true;
                    // Open mission generator menu instead of using prompt()
                    missionGeneratorInput = '';
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MISSION_GENERATOR, 400);
                    return true;
                }
                if (e.code === 'Enter' && aiMission && !isGeneratingMission) {
                    pendingAIMission = aiMission;
                    aiMission = null;
                    currentMissionIndex = aiMissionBaseIndex;
                    playMenuConfirmSound();
                    // Auto-start AI mission immediately instead of going to briefing
                    startTransition(GAME_STATES.PLAYING, 900, {
                        hold: true,
                        onSwitch: () => startMission(currentMissionIndex, { onReady: releaseTransition })
                    });
                    return true;
                }
                if (e.code === 'ArrowUp') {
                    menuSelectionIndex = (menuSelectionIndex - 1 + MAIN_MENU_OPTIONS.length) % MAIN_MENU_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    menuSelectionIndex = (menuSelectionIndex + 1) % MAIN_MENU_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if ((e.code === 'ArrowLeft' || e.code === 'ArrowRight') && menuSelectionIndex === 0) {
                    toggleGameMode();
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    handleMainMenuSelection(menuSelectionIndex);
                    return true;
                }
            } else if (gameState === GAME_STATES.CAMPAIGN) {
                if (e.code.startsWith('Digit')) {
                    const availableMissions = getCampaignMissionIndices();
                    const selection = parseInt(e.code.slice(5), 10);
                    if (!Number.isNaN(selection) && selection >= 1 && selection <= availableMissions.length) {
                        campaignSelectionIndex = selection - 1;
                        currentMissionIndex = availableMissions[campaignSelectionIndex];
                        playMenuConfirmSound();
                        // Preload mission layout for accurate briefing display
                        preloadMissionLayout(currentMissionIndex).then(() => {
                            startTransition(GAME_STATES.BRIEFING, 600);
                        });
                        return true;
                    }
                }
                if (e.code === 'ArrowUp') {
                    const availableMissions = getCampaignMissionIndices();
                    if (availableMissions.length === 0) return true;
                    campaignSelectionIndex = Math.max(0, campaignSelectionIndex - 1);
                    currentMissionIndex = availableMissions[campaignSelectionIndex] ?? availableMissions[0] ?? 0;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    const availableMissions = getCampaignMissionIndices();
                    if (availableMissions.length === 0) return true;
                    campaignSelectionIndex = Math.min(availableMissions.length - 1, campaignSelectionIndex + 1);
                    currentMissionIndex = availableMissions[campaignSelectionIndex] ?? availableMissions[0] ?? 0;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    // Preload mission layout for accurate briefing display
                    preloadMissionLayout(currentMissionIndex).then(() => {
                        startTransition(GAME_STATES.BRIEFING, 600);
                    });
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.FREEPLAY) {
                if (e.code === 'ArrowUp') {
                    freePlaySelectionIndex = (freePlaySelectionIndex - 1 + FREEPLAY_OPTIONS.length) % FREEPLAY_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    freePlaySelectionIndex = (freePlaySelectionIndex + 1) % FREEPLAY_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    if (freePlaySelectionIndex === 0) {
                        startTransition(GAME_STATES.PLAYING, 700, {
                            onSwitch: () => startFreePlay()
                        });
                    } else {
                        startTransition(GAME_STATES.MENU, 500);
                    }
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.SETTINGS) {
                if (e.code === 'ArrowUp') {
                    settingsSelectionIndex = (settingsSelectionIndex - 1 + SETTINGS_ITEMS.length) % SETTINGS_ITEMS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    settingsSelectionIndex = (settingsSelectionIndex + 1) % SETTINGS_ITEMS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowLeft') {
                    adjustSetting(settingsSelectionIndex, -1);
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowRight') {
                    adjustSetting(settingsSelectionIndex, 1);
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter') {
                    const item = SETTINGS_ITEMS[settingsSelectionIndex];
                    if (item.type === 'toggle') {
                        settings[item.key] = !settings[item.key];
                        applySettings();
                        saveSettings();
                        playMenuConfirmSound();
                    } else if (item.type === 'action') {
                        playMenuConfirmSound();
                        startTransition(GAME_STATES.MENU, 500);
                    }
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.ACHIEVEMENTS) {
                if (e.code === 'Enter' || e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.LEADERBOARD) {
                if (e.code === 'ArrowUp') {
                    leaderboardScrollOffset = Math.max(0, leaderboardScrollOffset - 1);
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    leaderboardScrollOffset += 1; // Will be clamped in render
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter' || e.code === 'Escape') {
                    playMenuConfirmSound();
                    leaderboardScrollOffset = 0; // Reset scroll when leaving
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.HOWTO) {
                if (e.code === 'Enter' || e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 500);
                    return true;
                }
            } else if (gameState === GAME_STATES.MISSION_GENERATOR) {
                // Handle text input for mission description
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    missionGeneratorInput = '';
                    startTransition(GAME_STATES.MENU, 400);
                    return true;
                }
                if (e.code === 'Enter' && !isGeneratingMission) {
                    if (missionGeneratorInput.trim().length > 0) {
                        playMenuConfirmSound();
                        generateAIMission(missionGeneratorInput.trim(), 'normal');
                    }
                    return true;
                }
                if (e.code === 'Backspace') {
                    missionGeneratorInput = missionGeneratorInput.slice(0, -1);
                    return true;
                }
                // Handle regular character input
                if (e.key.length === 1 && missionGeneratorInput.length < 100) {
                    missionGeneratorInput += e.key;
                    return true;
                }
                return true;  // Consume all keys in this state
            } else if (gameState === GAME_STATES.CUSTOM_MISSION) {
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    customMissionConfig = null;
                    startTransition(GAME_STATES.MENU, 400);
                    return true;
                }
                if (e.code === 'Enter' && customMissionConfig) {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.PLAYING, 700, {
                        onSwitch: () => startCustomMission()
                    });
                    return true;
                }
                return true;
            } else if (gameState === GAME_STATES.BRIEFING) {
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.PLAYING, 900, {
                        hold: true,
                        onSwitch: () => startMission(currentMissionIndex, { onReady: releaseTransition })
                    });
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    if (pendingAIMission) {
                        aiMission = pendingAIMission;
                        pendingAIMission = null;
                        startTransition(GAME_STATES.MENU, 500);
                    } else {
                        startTransition(GAME_STATES.CAMPAIGN, 500);
                    }
                    return true;
                }
            } else if (gameState === GAME_STATES.PLAYING) {
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.PAUSED, 250, {
                        onSwitch: () => {
                            pauseSelectionIndex = 0;
                            gameState = GAME_STATES.PAUSED;
                            stopRotorSound();
                            stopWarningAlarm();
                            stopWindSound();
                        }
                    });
                    return true;
                }
            } else if (gameState === GAME_STATES.PAUSED) {
                if (e.code === 'ArrowUp') {
                    pauseSelectionIndex = (pauseSelectionIndex - 1 + PAUSE_OPTIONS.length) % PAUSE_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'ArrowDown') {
                    pauseSelectionIndex = (pauseSelectionIndex + 1) % PAUSE_OPTIONS.length;
                    playMenuNavigateSound();
                    return true;
                }
                if (e.code === 'Enter' || e.code === 'Escape') {
                    playMenuConfirmSound();
                    if (pauseSelectionIndex === 0 || e.code === 'Escape') {
                        startTransition(GAME_STATES.PLAYING, 250, {
                            onSwitch: () => resumeFromPause()
                        });
                    } else if (pauseSelectionIndex === 1) {
                        startTransition(GAME_STATES.PLAYING, 900, {
                            hold: true,
                            onSwitch: () => restartCurrentMode()
                        });
                    } else {
                        startTransition(GAME_STATES.MENU, 700, {
                            onSwitch: () => returnToMenu()
                        });
                    }
                    return true;
                }
                if (e.code === 'KeyR') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.PLAYING, 900, {
                        hold: true,
                        onSwitch: () => restartCurrentMode()
                    });
                    return true;
                }
                if (e.code === 'KeyM') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 700, {
                        onSwitch: () => returnToMenu()
                    });
                    return true;
                }
            } else if (gameState === GAME_STATES.VICTORY) {
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    if (activeAIMission) {
                        startTransition(GAME_STATES.MENU, 700);
                    } else {
                        const availableMissions = getCampaignMissionIndices();
                        const currentIdx = availableMissions.indexOf(currentMissionIndex);
                        if (currentIdx >= 0 && currentIdx < availableMissions.length - 1) {
                            campaignSelectionIndex = currentIdx + 1;
                            currentMissionIndex = availableMissions[campaignSelectionIndex];
                            startTransition(GAME_STATES.BRIEFING, 700);
                        } else {
                            startTransition(GAME_STATES.MENU, 700);
                        }
                    }
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 700);
                    return true;
                }
            } else if (gameState === GAME_STATES.DEFEAT) {
                if (e.code === 'Enter') {
                    playMenuConfirmSound();
                    if (activeAIMission) {
                        pendingAIMission = activeAIMission;
                    }
                    startTransition(GAME_STATES.PLAYING, 900, {
                        hold: true,
                        onSwitch: () => startMission(currentMissionIndex, { onReady: releaseTransition })
                    });
                    return true;
                }
                if (e.code === 'Escape') {
                    playMenuConfirmSound();
                    startTransition(GAME_STATES.MENU, 700);
                    return true;
                }
            }
            return false;
        }

        // ============================================
        // SCREEN TRANSITIONS
        // ============================================
        function startTransition(targetState, duration = 700, options = {}) {
            if (transition.active) return;
            transition.active = true;
            transition.phase = 'out';
            transition.startTime = performance.now();
            transition.duration = duration;
            transition.targetState = targetState;
            transition.onSwitch = options.onSwitch || null;
            transition.hold = options.hold || false;
            transition.switched = false;
            transition.alpha = 0;
            if (!transition.onSwitch && targetState === GAME_STATES.MENU) {
                transition.onSwitch = () => {
                    gameState = GAME_STATES.MENU;
                    menuSelectionIndex = 0;
                };
            }
        }

        function releaseTransition() {
            if (transition.active && transition.phase === 'hold') {
                transition.phase = 'in';
                transition.startTime = performance.now();
            }
        }

        function updateTransition(timestamp) {
            if (!transition.active) return;
            const half = Math.max(1, transition.duration / 2);
            if (transition.phase === 'out') {
                const t = Math.min(1, (timestamp - transition.startTime) / half);
                transition.alpha = t;
                if (t >= 1) {
                    if (!transition.switched) {
                        transition.switched = true;
                        if (transition.onSwitch) {
                            transition.onSwitch();
                        } else if (transition.targetState) {
                            gameState = transition.targetState;
                        }
                    }
                    if (transition.hold) {
                        transition.phase = 'hold';
                    } else {
                        transition.phase = 'in';
                        transition.startTime = timestamp;
                    }
                }
            } else if (transition.phase === 'hold') {
                transition.alpha = 1;
            } else if (transition.phase === 'in') {
                const t = Math.min(1, (timestamp - transition.startTime) / half);
                transition.alpha = 1 - t;
                if (t >= 1) {
                    transition.active = false;
                    transition.alpha = 0;
                }
            }
        }

        function handlePointerMove(e) {
            const rect = canvas.getBoundingClientRect();
            const nextX = e.clientX - rect.left;
            const nextY = e.clientY - rect.top;
            const dx = nextX - mouseX;
            const dy = nextY - mouseY;
            mouseX = nextX;
            mouseY = nextY;
            if (activeSlider) {
                setSliderValueFromPointer(activeSlider, mouseX);
            }
            if (gameState === GAME_STATES.PLAYING) {
                const isDelta = gameMode === GAME_MODES.DELTA;
                const hasPointerLock = document.pointerLockElement === canvas;
                // Both modes support mouse look: with pointer lock OR while holding mouse button
                const shouldLook = hasPointerLock || isPointerDown;
                if (shouldLook) {
                    const lookDX = hasPointerLock ? e.movementX : dx;
                    const lookDY = hasPointerLock ? e.movementY : dy;
                    if (isDelta) {
                        let scopeMultiplier = 1;
                        if (soldierScope.active) {
                            const weaponKey = soldierWeapon.current;
                            scopeMultiplier = weaponKey === 'sniper' ? 0.35 : 0.6;
                        }
                        const yawSpeed = 0.0025 * mouseSensitivity * scopeMultiplier;
                        const pitchSpeed = 0.5 * mouseSensitivity * scopeMultiplier;
                        // FPS standard: mouse right = turn right (decrease angle), mouse up = look up (increase horizon)
                        camera.angle -= lookDX * yawSpeed;
                        camera.horizon += (invertY ? lookDY : -lookDY) * pitchSpeed;
                        // No pitch limits in Delta mode - allow full vertical aim
                        camera.horizon = Math.max(0, Math.min(screenHeight, camera.horizon));
                    } else {
                        const yawSpeed = 0.002 * mouseSensitivity;
                        const bankSpeed = 0.0025 * mouseSensitivity;
                        const pitchSpeed = 0.6 * mouseSensitivity;
                        const pitchDelta = (invertY ? lookDY : -lookDY) * pitchSpeed;

                        if (mouseRightDown || simpleControls) {
                            camera.angle -= lookDX * yawSpeed;
                        } else {
                            camera.bank += -lookDX * bankSpeed;
                            camera.bank = Math.max(-HELI_PHYSICS.MAX_BANK, Math.min(HELI_PHYSICS.MAX_BANK, camera.bank));
                        }

                        camera.horizon += pitchDelta;
                        camera.pitch = Math.max(-0.5, Math.min(0.5, camera.pitch - pitchDelta * 0.02));
                        camera.horizon = Math.max(0, Math.min(screenHeight, camera.horizon));
                    }
                }
            }
            lastMouseX = mouseX;
            lastMouseY = mouseY;
        }

        function handlePointerDown(e) {
            if (transition.active) return;
            if (e.button === 0) mouseLeftDown = true;
            if (e.button === 2) mouseRightDown = true;
            isPointerDown = true;
            initAudioOnInteraction();
            handlePointerMove(e);
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            if (gameState === GAME_STATES.PLAYING) {
                if (gameMode === GAME_MODES.DELTA) {
                    if (e.button === 2) {
                        soldierScope.active = true;
                    } else if (e.button === 0) {
                        deltaTriggerHeld = true;
                        deltaTriggerPressed = true;
                    }
                } else {
                    if (e.button === 0) {
                        comancheTriggerHeld = true;
                    }
                }
                // Enable pointer lock for both modes - makes mouse control smoother
                if (canvas.requestPointerLock) {
                    canvas.requestPointerLock();
                }
            }
            if (gameState === GAME_STATES.TITLE) {
                startTransition(GAME_STATES.MENU, 900);
                return;
            }
            handleMenuClick();
        }

        function handlePointerUp(e) {
            if (!e || e.button === 0 || e.button === undefined) {
                mouseLeftDown = false;
            }
            if (!e || e.button === 2 || e.button === undefined) {
                mouseRightDown = false;
            }
            isPointerDown = mouseLeftDown || mouseRightDown;
            activeSlider = null;
            if (!e || e.button === 0 || e.button === undefined) {
                deltaTriggerHeld = false;
                deltaTriggerPressed = false;
                comancheTriggerHeld = false;
            }
            if (!e || e.button === 2 || e.button === undefined) {
                if (gameMode === GAME_MODES.DELTA) {
                    soldierScope.active = false;
                }
            }
        }

        function handleMenuClick() {
            if (!isMenuState(gameState) && gameState !== GAME_STATES.PAUSED) return;
            const candidates = (gameState === GAME_STATES.PAUSED) ? pauseButtons : menuButtons;
            for (const button of candidates) {
                if (hitTest(button, mouseX, mouseY)) {
                    if (button.onClick) button.onClick();
                    playMenuConfirmSound();
                    return;
                }
            }
            if (gameState === GAME_STATES.SETTINGS) {
                for (const control of settingsControls) {
                    if (hitTest(control, mouseX, mouseY)) {
                        if (control.type === 'slider') {
                            activeSlider = control;
                            setSliderValueFromPointer(control, mouseX);
                            playMenuNavigateSound();
                            return;
                        }
                        if (control.type === 'toggle') {
                            settings[control.key] = !settings[control.key];
                            applySettings();
                            saveSettings();
                            playMenuConfirmSound();
                            return;
                        }
                        if (control.type === 'action' && control.onClick) {
                            control.onClick();
                            playMenuConfirmSound();
                            return;
                        }
                    }
                }
            }
        }

        function hitTest(rect, x, y) {
            return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
        }

        function setSliderValueFromPointer(control, pointerX) {
            const t = Math.max(0, Math.min(1, (pointerX - control.x) / control.width));
            const rawValue = control.min + t * (control.max - control.min);
            const stepped = Math.round(rawValue / control.step) * control.step;
            settings[control.key] = Math.max(control.min, Math.min(control.max, stepped));
            applySettings();
            saveSettings();
        }

        function adjustSetting(index, direction) {
            const item = SETTINGS_ITEMS[index];
            if (!item || item.type !== 'slider') return;
            const step = item.step || 0.01;
            const nextValue = settings[item.key] + step * direction;
            const clamped = Math.max(item.min, Math.min(item.max, nextValue));
            if (item.key === 'drawDistance') {
                settings[item.key] = Math.round(clamped / step) * step;
            } else {
                settings[item.key] = parseFloat(clamped.toFixed(3));
            }
            applySettings();
            saveSettings();
        }

        function handleMainMenuSelection(index) {
            if (index === 0) {
                toggleGameMode();
            } else if (index === 1) {
                syncCampaignSelectionForMode();
                startTransition(GAME_STATES.CAMPAIGN, 600);
            } else if (index === 2) {
                // RANDOM MISSION - pick random map and start mission
                playMenuConfirmSound();
                startTransition(GAME_STATES.PLAYING, 700, {
                    hold: true,
                    onSwitch: () => startRandomMission({ onReady: releaseTransition })
                });
            } else if (index === 3) {
                freePlaySelectionIndex = 0;
                startTransition(GAME_STATES.FREEPLAY, 600);
            } else if (index === 4) {
                // AI MISSION - open mission generator
                missionGeneratorInput = '';
                startTransition(GAME_STATES.MISSION_GENERATOR, 400);
            } else if (index === 5) {
                // MAP EDITOR - open mapeditor.html in a new window
                const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                const editorUrl = isLocal ? '/src/web/public/mapeditor.html' : '/mapeditor.html';
                window.open(editorUrl, '_blank');
            } else if (index === 6) {
                settingsSelectionIndex = 0;
                startTransition(GAME_STATES.SETTINGS, 600);
            } else if (index === 7) {
                startTransition(GAME_STATES.ACHIEVEMENTS, 600);
            } else if (index === 8) {
                startTransition(GAME_STATES.LEADERBOARD, 600);
            } else if (index === 9) {
                startTransition(GAME_STATES.HOWTO, 600);
            }
        }

        function resumeFromPause() {
            gameState = GAME_STATES.PLAYING;
            if (currentMissionIndex >= 0) {
                const mission = getActiveMission();
                if (mission && mission.timeLimit) {
                    const remaining = mission.timeLimit - missionTime;
                    missionStartTime = performance.now() - remaining * 1000;
                }
            }
            startRotorSound();
            startWindSound();
        }

        function restartCurrentMode() {
            if (currentMissionIndex >= 0) {
                if (activeAIMission) {
                    pendingAIMission = activeAIMission;
                }
                startMission(currentMissionIndex, { onReady: releaseTransition });
            } else {
                startFreePlay({ onReady: releaseTransition });
            }
        }

        function returnToMenu() {
            stopRotorSound();
            stopWarningAlarm();
            stopWindSound();
            gameState = GAME_STATES.MENU;
            menuSelectionIndex = 0;
            activeMission = null;
            activeAIMission = null;
        }
        
        function resizeCanvas() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
            
            // Recreate image buffer
            imageData = ctx.createImageData(screenWidth, screenHeight);
            buf8 = new Uint8ClampedArray(imageData.data.buffer);
            buf32 = new Uint32Array(imageData.data.buffer);
            hiddenYBuffer = new Int32Array(screenWidth);
            
            // Adjust horizon for new height
            camera.horizon = screenHeight * 0.4;
            
            // Reinitialize rain particles for new screen size
            initRainParticles();
        }
        
        // ============================================
        // MAP LOADING
        // ============================================
        function loadMap(index) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.textContent = `LOADING ${maps[index].name.toUpperCase()}...`;
            
            // Update dropdown to match
            document.getElementById('mapSelector').value = (index + 1).toString();
            
             const mapData = maps[index];
             let loadedCount = 0;
             
             const colorImg = new Image();
             const heightImg = new Image();
             colorImg.crossOrigin = 'anonymous';
             heightImg.crossOrigin = 'anonymous';
             
             function checkLoaded() {
                 loadedCount++;
                 if (loadedCount === 2) {
                     processMapImages(colorImg, heightImg);
                     loadingEl.style.display = 'none';
                     
                     // Reset camera position
                     camera.x = 512;
                     camera.y = 512;
                     camera.height = 80;
                     camera.angle = 0;
                     camera.horizon = screenHeight * 0.4;
                     
                     // Initialize combat
                     initCombat();
                 }
             }
             
             colorImg.onload = checkLoaded;
             heightImg.onload = checkLoaded;
             
             colorImg.onerror = () => {
                 loadingEl.textContent = 'ERROR LOADING COLOR MAP';
             };
             heightImg.onerror = () => {
                 loadingEl.textContent = 'ERROR LOADING HEIGHT MAP';
             };
             
             colorImg.src = mapData.color;
             heightImg.src = mapData.height;
        }
        
        function processMapImages(colorImg, heightImg) {
            // Create temporary canvas to read pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CONFIG.MAP_SIZE;
            tempCanvas.height = CONFIG.MAP_SIZE;
             const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
            
            // Process color map
            tempCtx.drawImage(colorImg, 0, 0, CONFIG.MAP_SIZE, CONFIG.MAP_SIZE);
            const colorData = tempCtx.getImageData(0, 0, CONFIG.MAP_SIZE, CONFIG.MAP_SIZE);
            currentMap.color = new Uint32Array(CONFIG.MAP_SIZE * CONFIG.MAP_SIZE);
            
            // Convert to ABGR format (canvas native)
            for (let i = 0; i < CONFIG.MAP_SIZE * CONFIG.MAP_SIZE; i++) {
                const r = colorData.data[i * 4];
                const g = colorData.data[i * 4 + 1];
                const b = colorData.data[i * 4 + 2];
                // ABGR format for little-endian systems
                currentMap.color[i] = (255 << 24) | (b << 16) | (g << 8) | r;
            }
            
            // Process height map with enhanced scale for dramatic terrain
            tempCtx.drawImage(heightImg, 0, 0, CONFIG.MAP_SIZE, CONFIG.MAP_SIZE);
            const heightData = tempCtx.getImageData(0, 0, CONFIG.MAP_SIZE, CONFIG.MAP_SIZE);
            // Use Uint16Array to allow heights above 255 after scaling
            currentMap.altitude = new Uint16Array(CONFIG.MAP_SIZE * CONFIG.MAP_SIZE);
            
            // Height scale multiplier - makes terrain more dramatic
            const HEIGHT_SCALE = 1.8;
            
            for (let i = 0; i < CONFIG.MAP_SIZE * CONFIG.MAP_SIZE; i++) {
                // Use red channel for height (grayscale images have same R,G,B)
                // Scale up for more dramatic cliffs and valleys
                currentMap.altitude[i] = Math.floor(heightData.data[i * 4] * HEIGHT_SCALE);
            }
            
            // Start game loop if not already running
            if (!lastTime) {
                lastTime = performance.now();
                requestAnimationFrame(gameLoop);
            }

            snapshotBaseMap();
        }

        let baseMap = { altitude: null, color: null };

        function snapshotBaseMap() {
            if (currentMap.altitude && currentMap.color) {
                baseMap.altitude = new Uint16Array(currentMap.altitude);
                baseMap.color = new Uint32Array(currentMap.color);
            }
        }

        function restoreBaseMap() {
            if (baseMap.altitude && baseMap.color) {
                currentMap.altitude.set(baseMap.altitude);
                currentMap.color.set(baseMap.color);
            }
        }

        function stampFlattenRect(cx, cy, width, length, heading, heightValue, feather = 2) {
            // Flatten terrain in a rotated rectangle
            const cos = Math.cos(heading);
            const sin = Math.sin(heading);
            const hw = width / 2;
            const hl = length / 2;
            
            for (let dy = -hl - feather; dy <= hl + feather; dy++) {
                for (let dx = -hw - feather; dx <= hw + feather; dx++) {
                    const rx = cx + dx * cos - dy * sin;
                    const ry = cy + dx * sin + dy * cos;
                    const ix = Math.floor(rx) & (CONFIG.MAP_SIZE - 1);
                    const iy = Math.floor(ry) & (CONFIG.MAP_SIZE - 1);
                    const idx = iy * CONFIG.MAP_SIZE + ix;
                    
                    // Calculate feather blend
                    const distFromEdgeX = Math.max(0, Math.abs(dx) - hw);
                    const distFromEdgeY = Math.max(0, Math.abs(dy) - hl);
                    const distFromEdge = Math.sqrt(distFromEdgeX * distFromEdgeX + distFromEdgeY * distFromEdgeY);
                    
                    if (distFromEdge <= feather) {
                        const blend = distFromEdge / feather;
                        const currentHeight = currentMap.altitude[idx];
                        currentMap.altitude[idx] = Math.round(currentHeight * blend + heightValue * (1 - blend));
                    }
                }
            }
        }

        function stampColorRect(cx, cy, width, length, heading, abgrColor, alpha = 1) {
            // Paint color in a rotated rectangle
            const cos = Math.cos(heading);
            const sin = Math.sin(heading);
            const hw = width / 2;
            const hl = length / 2;
            
            for (let dy = -hl; dy <= hl; dy++) {
                for (let dx = -hw; dx <= hw; dx++) {
                    const rx = cx + dx * cos - dy * sin;
                    const ry = cy + dx * sin + dy * cos;
                    const ix = Math.floor(rx) & (CONFIG.MAP_SIZE - 1);
                    const iy = Math.floor(ry) & (CONFIG.MAP_SIZE - 1);
                    const idx = iy * CONFIG.MAP_SIZE + ix;
                    
                    if (alpha >= 1) {
                        currentMap.color[idx] = abgrColor;
                    } else {
                        // Blend colors
                        const existing = currentMap.color[idx];
                        const eR = existing & 0xFF;
                        const eG = (existing >> 8) & 0xFF;
                        const eB = (existing >> 16) & 0xFF;
                        const nR = abgrColor & 0xFF;
                        const nG = (abgrColor >> 8) & 0xFF;
                        const nB = (abgrColor >> 16) & 0xFF;
                        const r = Math.round(eR * (1 - alpha) + nR * alpha);
                        const g = Math.round(eG * (1 - alpha) + nG * alpha);
                        const b = Math.round(eB * (1 - alpha) + nB * alpha);
                        currentMap.color[idx] = 0xFF000000 | (b << 16) | (g << 8) | r;
                    }
                }
            }
        }

        function applyMissionStamps(stamps) {
            restoreBaseMap();
            for (const stamp of stamps) {
                if (stamp.type === 'flatten') {
                    // Skip flatten stamps entirely - we now rely on naturally flat terrain
                    // This prevents terrain distortion/stretching artifacts
                    // The findFlatSpot() function now finds VERY flat areas that don't need modification
                    continue;
                } else if (stamp.type === 'color') {
                    stampColorRect(stamp.x, stamp.y, stamp.width, stamp.length, stamp.heading || 0, stamp.color, stamp.alpha || 1);
                }
            }
        }
        
        // ============================================
        // INPUT HANDLING
        // ============================================
        function handleSoldierInput(deltaTime) {
            const dt = Math.max(0, Math.min(2, deltaTime / 16.666));
            // Stance controls: Ctrl for crouch, V for prone (Z/X now used for weapon cycling)
            if ((keys['ControlLeft'] || keys['ControlRight']) && !SOLDIER.stanceChanging) {
                SOLDIER.stance = SOLDIER.stance === 'crouch' ? 'stand' : 'crouch';
                SOLDIER.stanceChanging = true;
            }
            if (keys['KeyV'] && !SOLDIER.stanceChanging) {
                SOLDIER.stance = SOLDIER.stance === 'prone' ? 'stand' : 'prone';
                SOLDIER.stanceChanging = true;
            }
            const moveX = (keys['KeyD'] ? 1 : 0) - (keys['KeyA'] ? 1 : 0);
            const moveY = (keys['KeyW'] ? 1 : 0) - (keys['KeyS'] ? 1 : 0);
            const hasInput = moveX !== 0 || moveY !== 0;

            SOLDIER.isSprinting = (SOLDIER.stance === 'stand') && (!!keys['ShiftLeft'] || !!keys['ShiftRight']);
            const baseSpeed = SOLDIER.speeds[SOLDIER.stance] || SOLDIER.speeds.stand;
            const maxSpeed = (SOLDIER.isSprinting && SOLDIER.stance === 'stand')
                ? SOLDIER.speeds.sprint
                : baseSpeed;

            if (hasInput) {
                const sinAngle = Math.sin(camera.angle);
                const cosAngle = Math.cos(camera.angle);
                const forwardX = -sinAngle;
                const forwardY = -cosAngle;
                const rightX = cosAngle;
                const rightY = -sinAngle;

                let dirX = forwardX * moveY + rightX * moveX;
                let dirY = forwardY * moveY + rightY * moveX;
                const dirLen = Math.hypot(dirX, dirY) || 1;
                dirX /= dirLen;
                dirY /= dirLen;

                SOLDIER.velocity.x += dirX * SOLDIER.accel * dt;
                SOLDIER.velocity.y += dirY * SOLDIER.accel * dt;

                const speed = Math.hypot(SOLDIER.velocity.x, SOLDIER.velocity.y);
                const speedLimit = maxSpeed * dt;
                if (speed > speedLimit) {
                    const scale = speedLimit / speed;
                    SOLDIER.velocity.x *= scale;
                    SOLDIER.velocity.y *= scale;
                }
            } else {
                SOLDIER.velocity.x *= SOLDIER.friction;
                SOLDIER.velocity.y *= SOLDIER.friction;
                if (Math.abs(SOLDIER.velocity.x) < 0.0001) SOLDIER.velocity.x = 0;
                if (Math.abs(SOLDIER.velocity.y) < 0.0001) SOLDIER.velocity.y = 0;
            }

            camera.x += SOLDIER.velocity.x;
            camera.y += SOLDIER.velocity.y;

            // Map boundary enforcement for soldier (stop at edges)
            const boundaryResult = enforceMapBoundary(camera.x, camera.y, camera.angle, dt, true);
            camera.x = boundaryResult.x;
            camera.y = boundaryResult.y;
            // Don't auto-turn soldier, just stop movement
            if (boundaryResult.hitBoundary) {
                SOLDIER.velocity.x = 0;
                SOLDIER.velocity.y = 0;
            }

            const terrainHeight = getTerrainHeight(camera.x, camera.y);
            const eyeHeight = SOLDIER.eyeHeights[SOLDIER.stance] || SOLDIER.eyeHeights.stand;

            const moveSpeed = Math.hypot(SOLDIER.velocity.x, SOLDIER.velocity.y);
            if (moveSpeed > 0.001) {
                const bobMultiplier = SOLDIER.isSprinting ? 1.6 : 1.0;
                SOLDIER.headBob += SOLDIER.headBobSpeed * bobMultiplier * dt;
            } else {
                SOLDIER.headBob *= 0.9;
            }
            soldierWeapon.viewBob = SOLDIER.headBob;
            const bobAmplitude = SOLDIER.isSprinting ? 1.4 : (soldierScope.active ? 0.4 : 0.8);
            const headBobOffset = Math.sin(SOLDIER.headBob) * bobAmplitude;

            camera.height = terrainHeight + eyeHeight + headBobOffset;
            camera.horizon = Math.max(screenHeight * 0.05, Math.min(screenHeight * 0.95, camera.horizon));
            currentSpeed = moveSpeed;
        }

        function handleInput(deltaTime) {
            if (gameState !== GAME_STATES.PLAYING) return;

            if (gameMode === GAME_MODES.DELTA) {
                handleSoldierInput(deltaTime);
                return;
            }

            const dt = Math.max(0, Math.min(2, deltaTime / 16.666));
            
            const boost = keys['Space'] ? CONFIG.BOOST_MULTIPLIER : 1;
            const climbSpeed = CONFIG.CLIMB_SPEED * boost;
            
            if (simpleControls) {
                // === SIMPLE CONTROLS (like original VoxelSpace) ===
                // Direct turning without banking
                
                // Turn directly with A/D
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    camera.angle += CONFIG.TURN_SPEED * boost * dt;
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    camera.angle -= CONFIG.TURN_SPEED * boost * dt;
                }
                
                // Forward/Backward movement
                if (keys['KeyW'] || keys['ArrowUp']) {
                    camera.forwardSpeed = CONFIG.MOVE_SPEED * boost;
                } else if (keys['KeyS'] || keys['ArrowDown']) {
                    camera.forwardSpeed = -CONFIG.MOVE_SPEED * boost * 0.5;
                } else {
                    camera.forwardSpeed = 0;
                }
                
                // No banking in simple mode
                camera.bank = 0;
                camera.lateralSpeed = 0;
                
            } else {
                // === HELICOPTER BANKING PHYSICS ===
                
                // Bank input (A/D roll the helicopter)
                // Positive bank = visual roll LEFT (left side of horizon goes UP)
                // Negative bank = visual roll RIGHT (right side of horizon goes UP)
                let bankInput = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) {
                    bankInput = 1;   // Bank left (positive bank = roll left visually)
                }
                if (keys['KeyD'] || keys['ArrowRight']) {
                    bankInput = -1;  // Bank right (negative bank = roll right visually)
                }
                
                // Apply bank input or return to level
                if (bankInput !== 0) {
                    // Roll into the turn
                    camera.bank += bankInput * HELI_PHYSICS.BANK_RATE;
                } else {
                    // Return to level flight
                    camera.bank *= (1 - HELI_PHYSICS.BANK_RETURN);
                    if (Math.abs(camera.bank) < 0.01) camera.bank = 0;
                }
                
                // Clamp bank angle
                camera.bank = Math.max(-HELI_PHYSICS.MAX_BANK, Math.min(HELI_PHYSICS.MAX_BANK, camera.bank));

                if (gameMode === GAME_MODES.DELTA) {
                    camera.bank = 0;
                }
                
                // Forward/Backward speed control
                if (keys['KeyW'] || keys['ArrowUp']) {
                    camera.forwardSpeed += HELI_PHYSICS.ACCELERATION * boost;
                } else if (keys['KeyS'] || keys['ArrowDown']) {
                    camera.forwardSpeed -= HELI_PHYSICS.ACCELERATION * boost;  // Same speed as forward
                } else {
                    // Gradual deceleration
                    camera.forwardSpeed *= (1 - HELI_PHYSICS.DECELERATION);
                }
                
                // Clamp forward speed (same max in both directions)
                camera.forwardSpeed = Math.max(-HELI_PHYSICS.MAX_FORWARD_SPEED * boost, 
                                               Math.min(HELI_PHYSICS.MAX_FORWARD_SPEED * boost, camera.forwardSpeed));
                
                // Q/E Strafe speed control (same as forward/backward)
                if (keys['KeyQ']) {
                    camera.lateralSpeed += HELI_PHYSICS.ACCELERATION * boost;  // Strafe left
                } else if (keys['KeyE']) {
                    camera.lateralSpeed -= HELI_PHYSICS.ACCELERATION * boost;  // Strafe right
                } else {
                    // Gradual deceleration + bank drift
                    const bankDrift = -camera.bank * HELI_PHYSICS.LATERAL_DRIFT * Math.abs(camera.forwardSpeed);
                    camera.lateralSpeed *= (1 - HELI_PHYSICS.DECELERATION);
                    camera.lateralSpeed += bankDrift;
                }
                
                // Clamp lateral speed
                camera.lateralSpeed = Math.max(-HELI_PHYSICS.MAX_FORWARD_SPEED * boost, 
                                               Math.min(HELI_PHYSICS.MAX_FORWARD_SPEED * boost, camera.lateralSpeed));
                
                // Turn rate based on bank angle (banking causes turning)
                // More bank = faster turn, forward speed affects turn rate
                // Positive bank (left roll) should turn left (increase angle in VoxelSpace coords)
                const effectiveSpeed = Math.max(0.3, Math.abs(camera.forwardSpeed) / HELI_PHYSICS.MAX_FORWARD_SPEED);
                camera.yawRate = camera.bank * HELI_PHYSICS.TURN_BANK_RATIO * effectiveSpeed * 15;
                
                // Apply yaw (heading change)
                camera.angle += camera.yawRate;
            }
            
            // Apply movement (same for both modes)
            const sinAngle = Math.sin(camera.angle);
            const cosAngle = Math.cos(camera.angle);
            
            // Forward movement
            camera.x -= sinAngle * camera.forwardSpeed * dt;
            camera.y -= cosAngle * camera.forwardSpeed * dt;
            
            // Lateral movement (perpendicular to heading) - only in banking mode
            camera.x -= cosAngle * camera.lateralSpeed * dt;
            camera.y += sinAngle * camera.lateralSpeed * dt;
            
            // Update display speed
            currentSpeed = camera.forwardSpeed;
            
            // Altitude Up/Down - helicopter climb
            if (keys['KeyR']) {
                camera.verticalSpeed += climbSpeed * 0.06 * dt;
            } else if (keys['KeyF']) {
                camera.verticalSpeed -= climbSpeed * 0.06 * dt;
            } else {
                camera.verticalSpeed *= Math.max(0, 1 - 0.08 * dt); // Gradual level off
            }
            camera.verticalSpeed = Math.max(-climbSpeed * 0.7, Math.min(climbSpeed, camera.verticalSpeed));
            camera.height += camera.verticalSpeed * dt;
            
            // Pitch returns to level automatically
            camera.pitch *= Math.max(0, 1 - 0.05 * dt);
            
            // Direct yaw control (J/L keys) - turn without banking
            if (keys['KeyJ']) {
                camera.angle += HELI_PHYSICS.MAX_YAW_RATE * dt;
            }
            if (keys['KeyL']) {
                camera.angle -= HELI_PHYSICS.MAX_YAW_RATE * dt;
            }
            
            // Clamp values
            camera.horizon = Math.max(0, Math.min(screenHeight, camera.horizon));
            camera.height = Math.max(CONFIG.MIN_ALTITUDE, Math.min(CONFIG.MAX_ALTITUDE, camera.height));
            
            // Map boundary enforcement (no wrapping - auto turn at edges)
            const boundaryResult = enforceMapBoundary(camera.x, camera.y, camera.angle, dt);
            camera.x = boundaryResult.x;
            camera.y = boundaryResult.y;
            camera.angle = boundaryResult.angle;
            
            // Terrain collision
            const terrainHeight = getTerrainHeight(camera.x, camera.y);
            if (camera.height < terrainHeight + CONFIG.COLLISION_MARGIN) {
                camera.height = terrainHeight + CONFIG.COLLISION_MARGIN;
                camera.verticalSpeed = Math.max(0, camera.verticalSpeed); // Stop descending
            }
        }
        
        // Enforce map boundaries - no wrapping, auto-turn at edges
        function enforceMapBoundary(x, y, angle, dt, isSoldier = false) {
            const margin = CONFIG.BOUNDARY_MARGIN;
            const hard = CONFIG.BOUNDARY_HARD;
            const maxPos = CONFIG.MAP_SIZE - hard;
            const minPos = hard;
            
            let newX = x;
            let newY = y;
            let newAngle = angle;
            let hitBoundary = false;
            let warningDir = null;
            
            // Check boundaries and apply auto-turn for aircraft
            const turnRate = isSoldier ? 0 : 0.08 * dt;  // Aircraft turn rate
            
            // West boundary (x near 0)
            if (x < minPos) {
                newX = minPos;
                hitBoundary = true;
                warningDir = 'west';
                if (!isSoldier) newAngle += turnRate;  // Turn right (east)
            } else if (x < margin) {
                warningDir = 'west';
                if (!isSoldier && Math.sin(angle) < 0) newAngle += turnRate * 0.5;
            }
            
            // East boundary (x near MAP_SIZE)
            if (x > maxPos) {
                newX = maxPos;
                hitBoundary = true;
                warningDir = 'east';
                if (!isSoldier) newAngle -= turnRate;  // Turn left (west)
            } else if (x > CONFIG.MAP_SIZE - margin) {
                warningDir = 'east';
                if (!isSoldier && Math.sin(angle) > 0) newAngle -= turnRate * 0.5;
            }
            
            // North boundary (y near 0)
            if (y < minPos) {
                newY = minPos;
                hitBoundary = true;
                warningDir = 'north';
                if (!isSoldier) newAngle += turnRate;  // Turn away
            } else if (y < margin) {
                warningDir = 'north';
                if (!isSoldier && Math.cos(angle) < 0) newAngle += turnRate * 0.5;
            }
            
            // South boundary (y near MAP_SIZE)
            if (y > maxPos) {
                newY = maxPos;
                hitBoundary = true;
                warningDir = 'south';
                if (!isSoldier) newAngle -= turnRate;  // Turn away
            } else if (y > CONFIG.MAP_SIZE - margin) {
                warningDir = 'south';
                if (!isSoldier && Math.cos(angle) > 0) newAngle -= turnRate * 0.5;
            }
            
            // Update warning state
            boundaryWarning.active = warningDir !== null;
            boundaryWarning.direction = warningDir;
            boundaryWarning.intensity = hitBoundary ? 1.0 : (warningDir ? 0.5 : 0);
            
            return { x: newX, y: newY, angle: newAngle, hitBoundary };
        }
        
        // Simple boundary clamp for AI entities - returns clamped position
        function clampToBoundary(x, y) {
            const hard = CONFIG.BOUNDARY_HARD;
            const maxPos = CONFIG.MAP_SIZE - hard;
            return {
                x: Math.max(hard, Math.min(maxPos, x)),
                y: Math.max(hard, Math.min(maxPos, y))
            };
        }
        
        // Check if position is outside map boundaries
        function isOutsideBoundary(x, y) {
            const hard = CONFIG.BOUNDARY_HARD;
            const maxPos = CONFIG.MAP_SIZE - hard;
            return x < hard || x > maxPos || y < hard || y > maxPos;
        }
        
        function getTerrainHeight(x, y) {
            if (!currentMap.altitude) return 0;
            const ix = Math.floor(x) & (CONFIG.MAP_SIZE - 1);
            const iy = Math.floor(y) & (CONFIG.MAP_SIZE - 1);
            return currentMap.altitude[(iy << CONFIG.MAP_SHIFT) + ix];
        }

        function getTerrainColor(x, y) {
            if (!currentMap.color) return 0xFF000000;
            const ix = Math.floor(x) & (CONFIG.MAP_SIZE - 1);
            const iy = Math.floor(y) & (CONFIG.MAP_SIZE - 1);
            return currentMap.color[(iy << CONFIG.MAP_SHIFT) + ix];
        }

        function isWaterAt(x, y, height = null) {
            const h = height !== null ? height : getTerrainHeight(x, y);
            if (h < 12) return true;
            const color = getTerrainColor(x, y);
            const r = color & 0xFF;
            const g = (color >> 8) & 0xFF;
            const b = (color >> 16) & 0xFF;
            return b > 110 && b > g + 20 && b > r + 20;
        }

        function estimateSlope(x, y, radius = 8) {
            let maxDiff = 0;
            const centerHeight = getTerrainHeight(x, y);

            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                const sx = x + Math.cos(angle) * radius;
                const sy = y + Math.sin(angle) * radius;
                const h = getTerrainHeight(sx, sy);
                maxDiff = Math.max(maxDiff, Math.abs(h - centerHeight));
            }

            return maxDiff;
        }

        function findFlatSpot(tries = 200, minHeight = 20, maxSlope = 20, avoidX = 512, avoidY = 512, minDist = 200) {
            for (let i = 0; i < tries; i++) {
                const x = Math.random() * CONFIG.MAP_SIZE;
                const y = Math.random() * CONFIG.MAP_SIZE;
                const height = getTerrainHeight(x, y);

                // Check height range
                if (height < minHeight || height > 180) continue;

                // Avoid water/shorelines
                if (isWaterAt(x, y, height)) continue;

                // Check slope at multiple radii for better flatness detection
                const slopeSmall = estimateSlope(x, y, 15);
                const slopeMedium = estimateSlope(x, y, 30);
                const slopeLarge = estimateSlope(x, y, 50);
                
                // All sample radii must be within tolerance (relaxed multipliers for natural terrain)
                if (slopeSmall > maxSlope || slopeMedium > maxSlope * 1.5 || slopeLarge > maxSlope * 2.0) continue;

                // Check distance from avoid point (player start)
                const dx = x - avoidX;
                const dy = y - avoidY;
                if (Math.sqrt(dx * dx + dy * dy) < minDist) continue;

                console.log('Found flat spot at', x.toFixed(1), y.toFixed(1), 'slope:', slopeSmall.toFixed(1));
                return { x, y, height };
            }

            // No suitable flat spot found - return null so callers can skip this structure
            return null;
        }

        function getHeliAGL(heli) {
            return heli.z - getTerrainHeight(heli.x, heli.y);
        }

        function isHeliLanded(heli) {
            const agl = getHeliAGL(heli);
            const slow = Math.abs(heli.forwardSpeed) < 0.03 &&
                Math.abs(heli.lateralSpeed) < 0.03 &&
                Math.abs(heli.verticalSpeed) < 0.3;
            return agl <= 6 && slow && !heli.destroyed;
        }
        
        // ============================================
        // RESUPPLY SYSTEM
        // ============================================
        const RESUPPLY = {
            range: 50,              // Distance to helipad to resupply
            interval: 500,          // ms between resupply ticks
            lastResupply: 0,
            ammoPerTick: 1,         // Amount refilled per tick
            healthPerTick: 2        // Health restored per tick
        };
        
        // Find nearest friendly helipad
        function getNearestFriendlyHelipad(x, y) {
            let nearest = null;
            let nearestDist = Infinity;
            
            for (const helipad of world.helipads) {
                if (helipad.faction !== FACTIONS.FRIENDLY && helipad.faction !== 'friendly') continue;
                
                const dx = helipad.x - x;
                const dy = helipad.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = { ...helipad, distance: dist };
                }
            }
            
            // Also check friendly bases for resupply
            for (const base of world.bases) {
                if (base.faction !== FACTIONS.FRIENDLY && base.faction !== 'friendly') continue;
                
                const dx = base.x - x;
                const dy = base.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Bases have larger resupply range
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = { ...base, distance: dist, isBase: true };
                }
            }
            
            return nearest;
        }
        
        // Check if player is at a resupply point
        function isAtResupplyPoint() {
            const px = camera.x;
            const py = camera.y;
            const nearest = getNearestFriendlyHelipad(px, py);
            
            if (!nearest) return false;
            
            // Must be within range
            const range = nearest.isBase ? RESUPPLY.range * 1.5 : RESUPPLY.range;
            if (nearest.distance > range) return false;
            
            // In Comanche mode, must be landed
            if (gameMode === GAME_MODES.COMANCHE) {
                return isHeliLanded(playerState.heli);
            }
            
            // In Delta mode, just need to be close
            return true;
        }
        
        // Perform resupply tick
        function updateResupply(currentTime) {
            if (!isAtResupplyPoint()) return;
            if (currentTime - RESUPPLY.lastResupply < RESUPPLY.interval) return;
            
            RESUPPLY.lastResupply = currentTime;
            let didResupply = false;
            
            if (gameMode === GAME_MODES.COMANCHE) {
                // Resupply helicopter weapons
                if (weaponState.rockets.ammo < WEAPONS.rockets.maxAmmo) {
                    weaponState.rockets.ammo = Math.min(weaponState.rockets.ammo + RESUPPLY.ammoPerTick, WEAPONS.rockets.maxAmmo);
                    didResupply = true;
                }
                if (weaponState.hellfire.ammo < WEAPONS.hellfire.maxAmmo) {
                    weaponState.hellfire.ammo = Math.min(weaponState.hellfire.ammo + RESUPPLY.ammoPerTick, WEAPONS.hellfire.maxAmmo);
                    didResupply = true;
                }
                if (weaponState.stinger.ammo < WEAPONS.stinger.maxAmmo) {
                    weaponState.stinger.ammo = Math.min(weaponState.stinger.ammo + RESUPPLY.ammoPerTick, WEAPONS.stinger.maxAmmo);
                    didResupply = true;
                }
                // Resupply countermeasures
                if (countermeasures.chaff.count < 10) {
                    countermeasures.chaff.count = Math.min(countermeasures.chaff.count + 1, 10);
                    didResupply = true;
                }
                if (countermeasures.flare.count < 10) {
                    countermeasures.flare.count = Math.min(countermeasures.flare.count + 1, 10);
                    didResupply = true;
                }
            } else if (gameMode === GAME_MODES.DELTA) {
                // Resupply soldier weapons (refill magazines)
                for (const weaponKey of Object.keys(soldierWeapon.weapons)) {
                    const state = soldierWeapon.weapons[weaponKey];
                    const maxMags = WEAPONS_DELTA[weaponKey]?.maxMags || 5;
                    if (state.mags < maxMags) {
                        state.mags = Math.min(state.mags + 1, maxMags);
                        didResupply = true;
                    }
                }
            }
            
            // Heal player slowly at resupply point
            if (playerHealth < maxPlayerHealth) {
                playerHealth = Math.min(playerHealth + RESUPPLY.healthPerTick, maxPlayerHealth);
                didResupply = true;
            }
        }

        function exitHeliToSoldier() {
            if (!isHeliLanded(playerState.heli)) return false;

            const previousMode = gameMode;

            // Save helicopter state from camera
            playerState.heli.x = camera.x;
            playerState.heli.y = camera.y;
            playerState.heli.z = camera.height;
            playerState.heli.angle = camera.angle;
            playerState.heli.bank = camera.bank;
            playerState.heli.forwardSpeed = camera.forwardSpeed;
            playerState.heli.lateralSpeed = camera.lateralSpeed;
            playerState.heli.verticalSpeed = camera.verticalSpeed;
            playerState.heli.visible = true;

            // Place soldier next to helicopter (offset to right side)
            const exitOffset = 15;
            playerState.soldier.x = camera.x + Math.cos(camera.angle + Math.PI / 2) * exitOffset;
            playerState.soldier.y = camera.y - Math.sin(camera.angle + Math.PI / 2) * exitOffset;

            // Switch to Delta mode
            playerState.mode = GAME_MODES.DELTA;
            playerState.activeVehicle = 'soldier';
            gameMode = GAME_MODES.DELTA;

            // Set camera for soldier view
            const terrainHeight = getTerrainHeight(playerState.soldier.x, playerState.soldier.y);
            camera.x = playerState.soldier.x;
            camera.y = playerState.soldier.y;
            camera.height = terrainHeight + SOLDIER.eyeHeights[SOLDIER.stance];
            camera.horizon = screenHeight * 0.5;
            camera.bank = 0;
            camera.bankVelocity = 0;
            camera.forwardSpeed = 0;
            camera.lateralSpeed = 0;
            camera.verticalSpeed = 0;

            // Reset soldier state
            SOLDIER.stance = 'stand';
            SOLDIER.velocity = { x: 0, y: 0 };
            SOLDIER.isSprinting = false;
            resetSoldierWeapons();

            trackEvent('mode_switch', { from: previousMode, to: gameMode });

            return true;
        }

        function canEnterHeli() {
            if (gameMode !== GAME_MODES.DELTA) return false;
            if (playerState.heli.destroyed) return false;

            const dx = camera.x - playerState.heli.x;
            const dy = camera.y - playerState.heli.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            return dist < 25; // Within 25 units
        }

        function enterHeli() {
            if (!canEnterHeli()) return false;

            const previousMode = gameMode;

            // Switch to Comanche mode
            playerState.mode = GAME_MODES.COMANCHE;
            playerState.activeVehicle = 'heli';
            gameMode = GAME_MODES.COMANCHE;
            playerState.heli.visible = false;

            // Restore camera from helicopter state
            camera.x = playerState.heli.x;
            camera.y = playerState.heli.y;
            camera.height = playerState.heli.z;
            camera.angle = playerState.heli.angle;
            camera.bank = playerState.heli.bank;
            camera.horizon = screenHeight * 0.4;
            camera.forwardSpeed = 0;
            camera.lateralSpeed = 0;
            camera.verticalSpeed = 0;

            trackEvent('mode_switch', { from: previousMode, to: gameMode });

            return true;
        }
        
        // ============================================
        // MISSION SYSTEM
        // ============================================
        function resetSoldierWeapons() {
            soldierWeapon.current = 'm4';
            soldierWeapon.weapons.m4.mag = WEAPONS_DELTA.m4.magSize;
            soldierWeapon.weapons.m4.mags = WEAPONS_DELTA.m4.maxMags;
            soldierWeapon.weapons.m4.lastFire = 0;
            soldierWeapon.weapons.sniper.mag = WEAPONS_DELTA.sniper.magSize;
            soldierWeapon.weapons.sniper.mags = WEAPONS_DELTA.sniper.maxMags;
            soldierWeapon.weapons.sniper.lastFire = 0;
            soldierWeapon.weapons.pistol.mag = WEAPONS_DELTA.pistol.magSize;
            soldierWeapon.weapons.pistol.mags = WEAPONS_DELTA.pistol.maxMags;
            soldierWeapon.weapons.pistol.lastFire = 0;
            soldierWeapon.weapons.javelin.mag = WEAPONS_DELTA.javelin.magSize;
            soldierWeapon.weapons.javelin.mags = WEAPONS_DELTA.javelin.maxMags;
            soldierWeapon.weapons.javelin.lastFire = 0;
            soldierWeapon.weapons.stinger.mag = WEAPONS_DELTA.stinger.magSize;
            soldierWeapon.weapons.stinger.mags = WEAPONS_DELTA.stinger.maxMags;
            soldierWeapon.weapons.stinger.lastFire = 0;
            soldierWeapon.weapons.c4.mag = WEAPONS_DELTA.c4.magSize;
            soldierWeapon.weapons.c4.mags = WEAPONS_DELTA.c4.maxMags;
            soldierWeapon.weapons.c4.lastFire = 0;
            soldierWeapon.weapons.airstrike.mag = WEAPONS_DELTA.airstrike.magSize;
            soldierWeapon.weapons.airstrike.mags = WEAPONS_DELTA.airstrike.maxMags;
            soldierWeapon.weapons.airstrike.lastFire = 0;
            soldierWeapon.isReloading = false;
            soldierWeapon.reloadStartTime = 0;
            // Clear any placed C4 charges
            placedC4Charges = [];
            airstrikeState.designating = false;
            airstrikeState.targetX = null;
            airstrikeState.targetY = null;
            airstrikeState.targetZ = null;
            airstrikeState.planesInbound = [];
            airstrikeState.lastCallTime = 0;
            airstrikeState.inboundMessageUntil = 0;
            soldierWeapon.viewBob = 0;
            soldierWeapon.recoilOffset = 0;
            soldierWeapon.muzzleFlashTime = 0;
        }

        function resetPlayerForMode(mode) {
            camera.bank = 0;
            camera.bankVelocity = 0;
            camera.pitch = 0;
            camera.yawRate = 0;
            camera.forwardSpeed = 0;
            camera.lateralSpeed = 0;
            camera.verticalSpeed = 0;

            if (mode === GAME_MODES.DELTA) {
                const terrainHeight = getTerrainHeight(camera.x, camera.y);
                SOLDIER.velocity.x = 0;
                SOLDIER.velocity.y = 0;
                SOLDIER.headBob = 0;
                SOLDIER.isSprinting = false;
                resetSoldierWeapons();
                camera.height = Math.max(CONFIG.MIN_ALTITUDE, terrainHeight + SOLDIER.eyeHeights[SOLDIER.stance]);
                camera.horizon = screenHeight * 0.5;
            } else {
                camera.height = 80;
                camera.horizon = screenHeight * 0.4;
            }
        }

        // Cache for loaded mission layouts
        const missionLayoutCache = {};

        async function loadMissionLayout(layoutFile) {
            // Check cache first
            if (missionLayoutCache[layoutFile]) {
                return missionLayoutCache[layoutFile];
            }
            
            try {
                const response = await fetch(layoutFile);
                if (!response.ok) {
                    console.warn(`Failed to load mission layout: ${layoutFile}`);
                    return null;
                }
                const layout = await response.json();
                missionLayoutCache[layoutFile] = layout;
                return layout;
            } catch (err) {
                console.warn(`Error loading mission layout: ${layoutFile}`, err);
                return null;
            }
        }

        function applyMissionLayout(layout, mission) {
            // Apply the layout from JSON file using existing applyCustomMissionConfig
            applyCustomMissionConfig(layout);
            
            // Set player start position if specified
            if (layout.playerStart) {
                camera.x = layout.playerStart.x;
                camera.y = layout.playerStart.y;
                if (typeof layout.playerStart.heading === 'number') {
                    camera.angle = layout.playerStart.heading;
                }
            }
            
            // Apply weather if specified
            if (layout.weather) {
                weatherCondition = layout.weather;
            }
            
            // Override mission properties from layout if present
            // This allows JSON files to define their own objectives, briefing, etc.
            if (layout.objectives && layout.objectives.length > 0) {
                mission.objectives = layout.objectives;
            }
            if (layout.briefing) {
                mission.briefing = layout.briefing;
            }
            if (layout.name) {
                mission.name = layout.name;
            }
            if (layout.difficulty) {
                mission.difficulty = layout.difficulty;
            }
            if (layout.timeLimit !== undefined) {
                mission.timeLimit = layout.timeLimit;
            }
            
            // Spawn mission targets based on mission definition (not layout)
            // The layout defines WHERE things go, mission defines HOW MANY
            spawnMissionTargets(mission);
        }

        function startMission(missionIndex, options = {}) {
            // Validate mission index
            if (typeof missionIndex !== 'number' || missionIndex < 0 || missionIndex >= MISSIONS.length) {
                console.error(`Invalid mission index: ${missionIndex}. Available missions: 0-${MISSIONS.length - 1}`);
                // Fall back to mission 0 or return to menu
                startTransition(GAME_STATES.CAMPAIGN, 500);
                return;
            }
            currentMissionIndex = missionIndex;
            const baseMission = MISSIONS[missionIndex];
            const mission = pendingAIMission ? buildMissionFromAI(pendingAIMission, baseMission) : baseMission;
            activeMission = mission;
            activeAIMission = pendingAIMission;
            pendingAIMission = null;
            aiMission = null;
            
            // Show loading
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.textContent = `LOADING ${mission.name}...`;
            
            // Load the correct map
            const mapIndex = activeAIMission && typeof aiMissionMapIndex === 'number' ? aiMissionMapIndex : mission.map;
            aiMissionMapIndex = null;
            loadMapForMission(mapIndex, async () => {
                // Reset player state
                playerHealth = maxPlayerHealth;
                score = 0;
                isPlayerDead = false;
                missionComplete = false;
                defeatReason = '';
                missionNoDamage = true;
                alertLevel = 0;
                alertTimer = 0;
                lastMissionElapsed = 0;
                resetSessionStats();
                updateStats('missionsPlayed', 1);
                
                // Reset weapons
                weaponState.cannon.ammo = Infinity;
                weaponState.rockets.ammo = WEAPONS.rockets.maxAmmo;
                weaponState.hellfire.ammo = WEAPONS.hellfire.maxAmmo;
                weaponState.stinger.ammo = WEAPONS.stinger.maxAmmo;
                currentWeaponIndex = 0;
                currentWeapon = weaponOrder[0];
                
                // Reset countermeasures
                countermeasures.chaff.count = 10;
                countermeasures.flare.count = 10;
                
                // Reset camera (may be overridden by layout)
                camera.x = 512;
                camera.y = 512;
                camera.angle = 0;
                resetPlayerForMode(gameMode);
                resetTelemetry();
                
                // Clear combat state
                targets = [];
                projectiles = [];
                enemyProjectiles = [];
                explosions = [];
                particles = [];
                particlePool = [];
                missileWarning = false;
                missileWarningTime = 0;
                screenFlashColor = null;
                screenFlashTime = 0;
                targetingSystem.reset();
                
                // Spawn mission targets - try to load layout file first
                if (activeAIMission) {
                    applyAIMission(activeAIMission);
                } else if (baseMission.layoutFile) {
                    // Load and apply the mission layout from JSON file
                    const layout = await loadMissionLayout(baseMission.layoutFile);
                    if (layout) {
                        applyMissionLayout(layout, mission);
                    } else {
                        // Fallback to random generation if layout fails to load
                        console.warn('Falling back to random generation');
                        generateWorldStructures();
                        spawnMissionTargets(mission);
                    }
                } else {
                    // No layout file, use random generation
                    generateWorldStructures();
                    spawnMissionTargets(mission);
                }
                
                // Start timer
                missionStartTime = performance.now();
                missionTime = mission.timeLimit || 0;
                
                // Initialize mission objectives tracking
                initObjectives(mission);
                
                // Hide loading and start playing
                loadingEl.style.display = 'none';
                gameState = GAME_STATES.PLAYING;

                trackEvent('game_start', {
                    mode: gameMode,
                    missionId: currentMissionIndex,
                    difficulty: mission ? mission.difficulty : null
                });
                
                // Start rotor sound
                startRotorSound();
                startWindSound();
                if (options.onReady) options.onReady();
            });
        }
        
        function startFreePlay(options = {}) {
            // Free play mode - use currently loaded map, no mission objectives
            // Map is already loaded from menu background, so start immediately

            activeMission = null;
            activeAIMission = null;
            
            // Reset player state
            playerHealth = maxPlayerHealth;
            score = 0;
            isPlayerDead = false;
            missionComplete = false;
            defeatReason = '';
            missionNoDamage = true;
            lastMissionElapsed = 0;
            resetSessionStats();
            
            // Reset weapons (full ammo for free play)
            weaponState.cannon.ammo = Infinity;
            weaponState.rockets.ammo = WEAPONS.rockets.maxAmmo;
            weaponState.hellfire.ammo = WEAPONS.hellfire.maxAmmo;
            weaponState.stinger.ammo = WEAPONS.stinger.maxAmmo;
            currentWeaponIndex = 0;
            currentWeapon = weaponOrder[0];
            
            // Reset countermeasures
            countermeasures.chaff.count = 10;
            countermeasures.flare.count = 10;
            
            // Reset camera
            camera.x = 512;
            camera.y = 512;
            camera.angle = 0;
            resetPlayerForMode(gameMode);
            resetTelemetry();
            
            // Clear combat state
            targets = [];
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            particles = [];
            particlePool = [];
            missileWarning = false;
            missileWarningTime = 0;
            targetingSystem.reset();
            screenFlashColor = null;
            screenFlashTime = 0;
            screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9, duration: 0 };
            muzzleFlashTime = 0;
            muzzleFlashIntensity = 0;
            hitMarkerTime = 0;
            hitMarkerIntensity = 0;
            damageVignetteTime = 0;
            damageVignetteIntensity = 0;
            
            const isDelta = gameMode === GAME_MODES.DELTA;

            // Spawn random targets for fun (lighter than missions)
            generateWorldStructures();
            if (isDelta) {
                for (let i = 0; i < 10; i++) spawnTarget('SOLDIER');
                for (let i = 0; i < 2; i++) spawnTarget('BUILDING');
            } else {
                for (let i = 0; i < 4; i++) spawnTarget('TANK');
                for (let i = 0; i < 2; i++) spawnTarget('BUILDING');
                for (let i = 0; i < 2; i++) spawnTarget('SAM_SITE');
            }
            
            // No time limit in free play
            missionStartTime = 0;
            missionTime = 0;
            currentMissionIndex = -1;  // Indicate free play mode

            trackEvent('game_start', {
                mode: gameMode,
                missionId: currentMissionIndex,
                difficulty: null
            });
            
            // Hide loading and start playing immediately
            document.getElementById('loading').style.display = 'none';
            gameState = GAME_STATES.PLAYING;
            startRotorSound();
            startWindSound();
            if (options.onReady) options.onReady();
        }

        function startRandomMission(options = {}) {
            // Pick a random map from the 29 available maps
            const randomMapIndex = Math.floor(Math.random() * maps.length);
            
            // Store callback to execute after map loads
            const onMapLoaded = () => {
                // Use startFreePlay logic but with the random map already loaded
                activeMission = null;
                activeAIMission = null;
                
                // Reset player state
                playerHealth = maxPlayerHealth;
                score = 0;
                isPlayerDead = false;
                missionComplete = false;
                defeatReason = '';
                missionNoDamage = true;
                lastMissionElapsed = 0;
                resetSessionStats();
                
                // Reset weapons (full ammo)
                weaponState.cannon.ammo = Infinity;
                weaponState.rockets.ammo = WEAPONS.rockets.maxAmmo;
                weaponState.hellfire.ammo = WEAPONS.hellfire.maxAmmo;
                weaponState.stinger.ammo = WEAPONS.stinger.maxAmmo;
                currentWeaponIndex = 0;
                currentWeapon = weaponOrder[0];
                
                // Reset countermeasures
                countermeasures.chaff.count = 10;
                countermeasures.flare.count = 10;
                
                // Reset camera
                camera.x = 512;
                camera.y = 512;
                camera.angle = 0;
                resetPlayerForMode(gameMode);
                resetTelemetry();
                
                // Clear combat state
                targets = [];
                projectiles = [];
                enemyProjectiles = [];
                explosions = [];
                particles = [];
                particlePool = [];
                missileWarning = false;
                missileWarningTime = 0;
                targetingSystem.reset();
                screenFlashColor = null;
                screenFlashTime = 0;
                screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9, duration: 0 };
                muzzleFlashTime = 0;
                muzzleFlashIntensity = 0;
                hitMarkerTime = 0;
                hitMarkerIntensity = 0;
                damageVignetteTime = 0;
                damageVignetteIntensity = 0;
                
                const isDelta = gameMode === GAME_MODES.DELTA;

                // Spawn random targets (slightly more than free play for challenge)
                generateWorldStructures();
                if (isDelta) {
                    for (let i = 0; i < 12; i++) spawnTarget('SOLDIER');
                    for (let i = 0; i < 3; i++) spawnTarget('BUILDING');
                    for (let i = 0; i < 1; i++) spawnTarget('SAM_SITE');
                } else {
                    for (let i = 0; i < 5; i++) spawnTarget('TANK');
                    for (let i = 0; i < 3; i++) spawnTarget('BUILDING');
                    for (let i = 0; i < 3; i++) spawnTarget('SAM_SITE');
                }
                
                // No time limit in random mission
                missionStartTime = performance.now();
                missionTime = 0;
                currentMissionIndex = -1;  // Free play style
                
                trackEvent('game_start', {
                    mode: gameMode,
                    missionId: -1,
                    missionType: 'random',
                    mapIndex: randomMapIndex,
                    difficulty: null
                });
                
                // Start playing
                document.getElementById('loading').style.display = 'none';
                gameState = GAME_STATES.PLAYING;
                startRotorSound();
                startWindSound();
                if (options.onReady) options.onReady();
            };
            
            // Use a polling approach to detect when map is loaded
            // loadMap sets loading display to 'none' when complete
            loadMap(randomMapIndex);
            
            const checkMapLoaded = setInterval(() => {
                const loadingEl = document.getElementById('loading');
                if (loadingEl.style.display === 'none' || loadingEl.textContent.includes('ERROR')) {
                    clearInterval(checkMapLoaded);
                    if (!loadingEl.textContent.includes('ERROR')) {
                        onMapLoaded();
                    }
                }
            }, 50);
        }

        function loadCustomMissionFromStorage() {
            // Check if there's a custom mission saved in localStorage from map editor
            const raw = localStorage.getItem(CUSTOM_MISSION_KEY);
            if (!raw) {
                startTransition(GAME_STATES.CUSTOM_MISSION, 400);
                return;
            }
            try {
                customMissionConfig = JSON.parse(raw);
                startTransition(GAME_STATES.CUSTOM_MISSION, 400);
            } catch (err) {
                console.error('Failed to parse custom mission:', err);
                customMissionConfig = null;
                startTransition(GAME_STATES.CUSTOM_MISSION, 400);
            }
        }

        function startCustomMission(options = {}) {
            if (!customMissionConfig) return;

            const config = customMissionConfig;
            
            // Show loading
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            loadingEl.textContent = `LOADING ${config.name || 'CUSTOM MISSION'}...`;

            // Load the map specified in config
            const mapIndex = (config.mapIndex || 1) - 1;  // Convert 1-based to 0-based
            loadMapForMission(mapIndex, () => {
                // Reset player state
                activeMission = {
                    name: config.name || 'Custom Mission',
                    difficulty: config.difficulty || 'medium',
                    timeLimit: 0,  // No time limit for custom missions
                    targets: {}
                };
                activeAIMission = null;

                playerHealth = maxPlayerHealth;
                score = 0;
                isPlayerDead = false;
                missionComplete = false;
                defeatReason = '';
                missionNoDamage = true;
                lastMissionElapsed = 0;
                resetSessionStats();

                // Reset weapons
                weaponState.cannon.ammo = Infinity;
                weaponState.rockets.ammo = WEAPONS.rockets.maxAmmo;
                weaponState.hellfire.ammo = WEAPONS.hellfire.maxAmmo;
                weaponState.stinger.ammo = WEAPONS.stinger.maxAmmo;
                currentWeaponIndex = 0;
                currentWeapon = weaponOrder[0];

                // Reset countermeasures
                countermeasures.chaff.count = 10;
                countermeasures.flare.count = 10;

                // Set player start position
                if (config.playerStart) {
                    camera.x = config.playerStart.x;
                    camera.y = config.playerStart.y;
                    camera.angle = typeof config.playerStart.heading === 'number' ? config.playerStart.heading : 0;
                } else {
                    camera.x = 512;
                    camera.y = 512;
                    camera.angle = 0;
                }
                resetPlayerForMode(gameMode);
                resetTelemetry();

                // Clear combat state
                targets = [];
                projectiles = [];
                enemyProjectiles = [];
                explosions = [];
                particles = [];
                particlePool = [];
                missileWarning = false;
                missileWarningTime = 0;
                screenFlashColor = null;
                screenFlashTime = 0;
                screenShake = { x: 0, y: 0, intensity: 0, decay: 0.9, duration: 0 };
                muzzleFlashTime = 0;
                muzzleFlashIntensity = 0;
                hitMarkerTime = 0;
                hitMarkerIntensity = 0;
                damageVignetteTime = 0;
                damageVignetteIntensity = 0;

                // Apply custom world structures
                applyCustomMissionConfig(config);

                // Apply weather if specified
                if (config.weather) {
                    weatherCondition = config.weather;
                }

                // No timer for custom missions
                missionStartTime = 0;
                missionTime = 0;
                currentMissionIndex = -2;  // Indicate custom mission mode (-1 = free play, -2 = custom)

                trackEvent('game_start', {
                    mode: gameMode,
                    missionId: 'custom',
                    difficulty: config.difficulty || 'medium'
                });

                // Hide loading and start playing
                loadingEl.style.display = 'none';
                gameState = GAME_STATES.PLAYING;
                startRotorSound();
                startWindSound();
                if (options.onReady) options.onReady();
            });
        }

        function applyCustomMissionConfig(config) {
            // Reset world structures
            world.stamps = [];
            world.airports = [];
            world.bases = [];
            world.helipads = [];
            airportSpawnTimers = {};
            helipadSpawnTimers = {};

            // Generate airports from config
            if (config.airports && config.airports.length > 0) {
                for (const airport of config.airports) {
                    const heading = airport.heading || Math.random() * Math.PI * 2;
                    const faction = airport.faction === 'friendly' ? FACTIONS.FRIENDLY : FACTIONS.ENEMY;
                    const result = generateAirport(airport.x, airport.y, heading, faction);
                    if (result.airport) {
                        world.stamps.push(...result.stamps);
                    }
                }
            }

            // Generate bases from config
            if (config.bases && config.bases.length > 0) {
                for (const base of config.bases) {
                    const faction = base.faction === 'friendly' ? FACTIONS.FRIENDLY : FACTIONS.ENEMY;
                    const size = base.size || 'medium';
                    const result = generateBase(base.x, base.y, faction, size);
                    world.stamps.push(...result.stamps);
                }
            }

            // Generate helipads from config
            if (config.helipads && config.helipads.length > 0) {
                for (const helipad of config.helipads) {
                    const faction = helipad.faction === 'friendly' ? FACTIONS.FRIENDLY : FACTIONS.ENEMY;
                    // Helipads are simpler - just create a small landing area
                    const result = generateHelipad(helipad.x, helipad.y, faction);
                    if (result) {
                        world.stamps.push(...result.stamps);
                    }
                }
            }
            
            // Always add a friendly "home base" helipad at player start
            // This ensures there's always somewhere to resupply
            const playerX = config.playerStart?.x || 512;
            const playerY = config.playerStart?.y || 512;
            const homeBaseResult = generateHelipad(playerX, playerY, FACTIONS.FRIENDLY);
            if (homeBaseResult) {
                world.stamps.push(...homeBaseResult.stamps);
            }

            // Apply all stamps to flatten terrain
            if (world.stamps.length > 0) {
                applyMissionStamps(world.stamps);
            }

            // Spawn enemies from spawn zones
            if (config.spawnZones && config.spawnZones.length > 0) {
                for (const zone of config.spawnZones) {
                    const count = zone.count || 10;
                    const radius = zone.radius || 80;
                    const types = zone.types || ['TANK', 'SOLDIER'];

                    for (let i = 0; i < count; i++) {
                        // Random position within zone radius
                        const angle = Math.random() * Math.PI * 2;
                        const dist = Math.random() * radius;
                        const x = zone.x + Math.cos(angle) * dist;
                        const y = zone.y + Math.sin(angle) * dist;

                        // Pick random type from allowed types
                        const typeKey = types[Math.floor(Math.random() * types.length)].toUpperCase();
                        if (TARGET_TYPES[typeKey]) {
                            spawnTargetAt(typeKey, x, y, FACTIONS.ENEMY);
                        }
                    }
                }
            }
            
            // Spawn individual units at specific positions
            if (config.units && config.units.length > 0) {
                for (const unit of config.units) {
                    const typeKey = (unit.type || '').toUpperCase();
                    if (TARGET_TYPES[typeKey]) {
                        const faction = unit.faction === 'friendly' ? FACTIONS.FRIENDLY : FACTIONS.ENEMY;
                        spawnTargetAt(typeKey, unit.x, unit.y, faction);
                    }
                }
            }
        }

        function generateHelipad(x, y, faction = FACTIONS.ENEMY) {
            // Simple helipad - a flattened circular area
            const helipad = {
                id: 'helipad_' + Date.now() + '_' + Math.random(),
                x,
                y,
                faction,
                radius: 15
            };
            world.helipads.push(helipad);

            // Also spawn a visible helipad target entity
            const target = spawnTargetAt('HELIPAD', x, y, faction);
            if (target) {
                helipad.targetId = target.id;
            }

            // Create stamp for flattening
            const stamps = [{
                type: 'helipad',
                x,
                y,
                radius: 20,
                height: getTerrainHeight(x, y)
            }];

            return { helipad, stamps };
        }
        
        function loadMapForMission(mapIndex, callback) {
            const loadingEl = document.getElementById('loading');
            loadingEl.style.display = 'block';
            
            // Update dropdown to match
            document.getElementById('mapSelector').value = (mapIndex + 1).toString();
            
             const mapData = maps[mapIndex];
             let loadedCount = 0;
             
             const colorImg = new Image();
             const heightImg = new Image();
             colorImg.crossOrigin = 'anonymous';
             heightImg.crossOrigin = 'anonymous';
             
             function checkLoaded() {
                 loadedCount++;
                 if (loadedCount === 2) {
                     processMapImages(colorImg, heightImg);
                     loadingEl.style.display = 'none';
                     if (callback) callback();
                 }
             }
             
             colorImg.onload = checkLoaded;
             heightImg.onload = checkLoaded;
             
             colorImg.onerror = () => {
                 loadingEl.textContent = 'ERROR LOADING COLOR MAP';
             };
             heightImg.onerror = () => {
                 loadingEl.textContent = 'ERROR LOADING HEIGHT MAP';
             };
             
             colorImg.src = mapData.color;
             heightImg.src = mapData.height;
        }
        
        function spawnMissionTargets(mission) {
            const isDelta = gameMode === GAME_MODES.DELTA;
            const targetConfig = isDelta
                ? (mission.targetsDelta || mission.targets)
                : mission.targets;

            const tankCount = targetConfig.tanks || 0;
            const soldierCount = targetConfig.soldiers || 0;
            const buildingCount = targetConfig.buildings || 0;
            const samCount = targetConfig.sams || 0;

            // Spawn tanks
            for (let i = 0; i < tankCount; i++) {
                spawnTarget('TANK');
            }
            // Spawn soldiers (with ~10% chance of being snipers for variety)
            for (let i = 0; i < soldierCount; i++) {
                if (Math.random() < 0.1) {
                    spawnTarget('SNIPER');
                } else {
                    spawnTarget('SOLDIER');
                }
            }
            
            // Spawn buildings
            for (let i = 0; i < buildingCount; i++) {
                spawnTarget('BUILDING');
            }
            
            // Spawn SAM sites
            for (let i = 0; i < samCount; i++) {
                spawnTarget('SAM_SITE');
            }
        }
        
        function spawnTarget(typeKey) {
            const targetType = TARGET_TYPES[typeKey];
            
            // Random position on map (avoid edges and player start)
            // Increased minimum distance from player spawn (512, 512) from 150 to 300 units
            let x, y, attempts = 0;
            do {
                x = 100 + Math.random() * (CONFIG.MAP_SIZE - 200);
                y = 100 + Math.random() * (CONFIG.MAP_SIZE - 200);
                attempts++;
            } while (Math.abs(x - 512) < 300 && Math.abs(y - 512) < 300 && attempts < 30);
            
            const terrainHeight = getTerrainHeight(x, y);
            
            // Create AI state for this target
            let aiState = null;
            if (targetType.ai) {
                if (targetType.ai.type === 'patrol') {
                    aiState = {
                        type: 'patrol',
                        speed: targetType.ai.speed,
                        patrolRadius: targetType.ai.patrolRadius,
                        patrolCenter: { x: x, y: y },
                        patrolAngle: Math.random() * Math.PI * 2,
                        patrolDirection: Math.random() > 0.5 ? 1 : -1,
                        detectRange: targetType.ai.detectRange,
                        engageRange: targetType.ai.engageRange,
                        fireRate: targetType.ai.fireRate,
                        bulletSpeed: targetType.ai.bulletSpeed,
                        bulletDamage: targetType.ai.bulletDamage,
                        lastFired: 0,
                        state: 'patrol'
                    };
                } else if (targetType.ai.type === 'sam') {
                    aiState = {
                        type: 'sam',
                        fireRate: targetType.ai.fireRate,
                        lastFired: 0,
                        range: targetType.ai.range,
                        missileSpeed: targetType.ai.missileSpeed,
                        missileDamage: targetType.ai.missileDamage
                    };
                } else if (targetType.ai.type === 'infantry') {
                    aiState = {
                        type: 'infantry',
                        state: 'patrol',
                        patrolCenter: { x: x, y: y },
                        patrolRadius: targetType.ai.patrolRadius,
                        patrolAngle: Math.random() * Math.PI * 2,
                        patrolSpeed: targetType.ai.patrolSpeed,
                        detectRange: targetType.ai.detectRange,
                        engageRange: targetType.ai.engageRange,
                        fireRate: targetType.ai.fireRate,
                        accuracy: targetType.ai.accuracy,
                        bulletSpeed: targetType.ai.bulletSpeed,
                        bulletDamage: targetType.ai.bulletDamage,
                        lastFired: 0,
                        facingAngle: Math.random() * Math.PI * 2,
                        pose: 'stand'
                    };
                } else if (targetType.ai.type === 'sniper') {
                    aiState = {
                        type: 'sniper',
                        state: 'overwatch',
                        patrolCenter: { x: x, y: y },
                        patrolRadius: targetType.ai.patrolRadius,
                        patrolAngle: Math.random() * Math.PI * 2,
                        patrolSpeed: targetType.ai.patrolSpeed,
                        detectRange: targetType.ai.detectRange,
                        engageRange: targetType.ai.engageRange,
                        fireRate: targetType.ai.fireRate,
                        accuracy: targetType.ai.accuracy,
                        bulletSpeed: targetType.ai.bulletSpeed,
                        bulletDamage: targetType.ai.bulletDamage,
                        lastFired: 0,
                        facingAngle: Math.random() * Math.PI * 2,
                        pose: 'crouch'
                    };
                } else if (targetType.ai.type === 'aircraft') {
                    aiState = {
                        type: 'aircraft',
                        role: targetType.ai.role,
                        speed: targetType.ai.speed,
                        turnRate: targetType.ai.turnRate,
                        climbRate: targetType.ai.climbRate,
                        preferredAlt: targetType.ai.preferredAlt,
                        detectRange: targetType.ai.detectRange,
                        engageRange: targetType.ai.engageRange,
                        fireRate: targetType.ai.fireRate,
                        weaponType: targetType.ai.weaponType,
                        bulletSpeed: targetType.ai.bulletSpeed,
                        bulletDamage: targetType.ai.bulletDamage,
                        attackCooldown: targetType.ai.attackCooldown || 0,
                        lastAttackTime: 0
                    };
                }
            }
            
            targets.push({
                x: x,
                y: y,
                z: terrainHeight + targetType.heightOffset,
                type: targetType.type,
                health: targetType.health,
                maxHealth: targetType.health,
                points: targetType.points,
                size: targetType.size,
                color: targetType.color,
                domain: targetType.domain,
                faction: targetType.faction,
                hitHeight: targetType.hitHeight,
                destroyed: false,
                ai: aiState
            });

            enforceEntityBudget();
        }

        function spawnTargetAt(typeKey, x, y, faction = FACTIONS.ENEMY, baseHeight = null) {
            const template = TARGET_TYPES[typeKey];
            if (!template) return null;

            // Check slope for BUILDINGS only (not mobile units like soldiers, tanks, SAMs)
            // Mobile units can be placed on slopes - they'll adapt
            const buildingTypes = ['building', 'hangar', 'control_tower', 'barracks', 'fuel_depot', 'helipad'];
            if (template.domain !== DOMAINS.AIR && baseHeight === null && buildingTypes.includes(template.type)) {
                const slope = estimateSlope(x, y, 10);
                const maxBuildingSlope = 15; // Allow 15 units height difference over sample radius
                if (slope > maxBuildingSlope) {
                    // Try to find a flatter nearby spot
                    let foundFlat = false;
                    for (let attempt = 0; attempt < 8; attempt++) {
                        const offsetX = (Math.random() - 0.5) * 30;
                        const offsetY = (Math.random() - 0.5) * 30;
                        const newX = ((x + offsetX) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                        const newY = ((y + offsetY) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                        if (estimateSlope(newX, newY, 10) <= maxBuildingSlope) {
                            x = newX;
                            y = newY;
                            foundFlat = true;
                            break;
                        }
                    }
                    // If no flat spot found, skip spawning this building
                    if (!foundFlat) {
                        return null;
                    }
                }
            }

            // Use provided baseHeight (for airport buildings on flattened terrain) or get from terrain
            // For buildings and ground units, sample terrain in a grid and use MAXIMUM height to prevent embedding
            let terrainHeight;
            if (baseHeight !== null) {
                terrainHeight = baseHeight;
            } else if (template.domain !== DOMAINS.AIR) {
                // Sample terrain in a grid and use the MAXIMUM height to prevent embedding on slopes
                // Buildings use larger sample radius, mobile units use smaller radius based on their size
                let maxHeight = getTerrainHeight(x, y);
                const isBuilding = buildingTypes.includes(template.type);
                const sampleRadius = isBuilding 
                    ? (template.size * 0.5 || 10)  // Buildings: larger radius
                    : (template.size * 0.3 || 5);  // Mobile units (soldiers, tanks, SAMs): smaller radius
                for (let ox = -sampleRadius; ox <= sampleRadius; ox += sampleRadius) {
                    for (let oy = -sampleRadius; oy <= sampleRadius; oy += sampleRadius) {
                        const sx = ((x + ox) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                        const sy = ((y + oy) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                        maxHeight = Math.max(maxHeight, getTerrainHeight(sx, sy));
                    }
                }
                terrainHeight = maxHeight;
            } else {
                terrainHeight = getTerrainHeight(x, y);
            }
            const heightOffset = (typeof template.heightOffset === 'number')
                ? template.heightOffset
                : (template.type === 'helipad' ? 1 : template.size * 0.5);

            let aiState = null;
            if (template.ai) {
                if (template.ai.type === 'patrol') {
                    aiState = {
                        type: 'patrol',
                        speed: template.ai.speed,
                        patrolRadius: template.ai.patrolRadius,
                        patrolCenter: { x: x, y: y },
                        patrolAngle: Math.random() * Math.PI * 2,
                        patrolDirection: Math.random() > 0.5 ? 1 : -1,
                        detectRange: template.ai.detectRange,
                        engageRange: template.ai.engageRange,
                        fireRate: template.ai.fireRate,
                        bulletSpeed: template.ai.bulletSpeed,
                        bulletDamage: template.ai.bulletDamage,
                        lastFired: 0,
                        state: 'patrol'
                    };
                } else if (template.ai.type === 'sam') {
                    aiState = {
                        type: 'sam',
                        fireRate: template.ai.fireRate,
                        lastFired: 0,
                        range: template.ai.range,
                        missileSpeed: template.ai.missileSpeed,
                        missileDamage: template.ai.missileDamage
                    };
                } else if (template.ai.type === 'infantry') {
                    aiState = {
                        type: 'infantry',
                        state: 'patrol',
                        patrolCenter: { x: x, y: y },
                        patrolRadius: template.ai.patrolRadius,
                        patrolAngle: Math.random() * Math.PI * 2,
                        patrolSpeed: template.ai.patrolSpeed,
                        detectRange: template.ai.detectRange,
                        engageRange: template.ai.engageRange,
                        fireRate: template.ai.fireRate,
                        accuracy: template.ai.accuracy,
                        bulletSpeed: template.ai.bulletSpeed,
                        bulletDamage: template.ai.bulletDamage,
                        lastFired: 0,
                        facingAngle: Math.random() * Math.PI * 2,
                        pose: 'stand'
                    };
                } else if (template.ai.type === 'aircraft') {
                    aiState = {
                        type: 'aircraft',
                        role: template.ai.role,
                        speed: template.ai.speed,
                        turnRate: template.ai.turnRate,
                        climbRate: template.ai.climbRate,
                        preferredAlt: template.ai.preferredAlt,
                        detectRange: template.ai.detectRange,
                        engageRange: template.ai.engageRange,
                        fireRate: template.ai.fireRate,
                        weaponType: template.ai.weaponType,
                        bulletSpeed: template.ai.bulletSpeed,
                        bulletDamage: template.ai.bulletDamage,
                        attackCooldown: template.ai.attackCooldown || 0,
                        burstCount: template.ai.burstCount || 0,
                        burstCooldown: template.ai.burstCooldown || 0,
                        lastAttackTime: 0,
                        lastFireTime: 0
                    };
                }
            }

            const target = {
                id: 'target_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                x: x,
                y: y,
                z: terrainHeight + heightOffset,
                type: template.type,
                domain: template.domain,
                faction: faction,
                health: template.health,
                maxHealth: template.health,
                size: template.size,
                hitHeight: template.hitHeight,
                color: template.color,
                points: template.points,
                destroyed: false,
                ai: aiState
            };

            targets.push(target);
            enforceEntityBudget();
            return target;
        }

        function enforceEntityBudget() {
            const activeTargets = targets.filter((target) => !target.destroyed);

            const groundTargets = activeTargets.filter((target) => target.domain === DOMAINS.GROUND);
            const airTargets = activeTargets.filter((target) => target.domain === DOMAINS.AIR);
            const structureTargets = activeTargets.filter((target) => target.domain === DOMAINS.STRUCTURE);

            const removeFarthest = (list, excess) => {
                if (excess <= 0) return;
                list.sort((a, b) => distance2D(b.x, b.y, camera.x, camera.y) - distance2D(a.x, a.y, camera.x, camera.y));
                for (let i = 0; i < excess && i < list.length; i++) {
                    list[i].destroyed = true;
                }
            };

            removeFarthest(groundTargets, groundTargets.length - ENTITY_BUDGET.maxGround);
            removeFarthest(airTargets, airTargets.length - ENTITY_BUDGET.maxAir);
            removeFarthest(structureTargets, structureTargets.length - ENTITY_BUDGET.maxStructures);

            const remaining = targets.filter((target) => !target.destroyed);
            if (remaining.length > ENTITY_BUDGET.maxTotal) {
                remaining.sort((a, b) => distance2D(b.x, b.y, camera.x, camera.y) - distance2D(a.x, a.y, camera.x, camera.y));
                for (let i = ENTITY_BUDGET.maxTotal; i < remaining.length; i++) {
                    remaining[i].destroyed = true;
                }
            }
        }

        function generateAirport(x, y, heading, faction = FACTIONS.ENEMY) {
            const id = 'airport_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            const runwayLength = 60;  // Reduced from 90 to fit naturally flat areas better
            const runwayWidth = 20;
            
            // Get the terrain height - we rely on naturally flat spots now
            // All airport buildings should sit at this height
            const runwayHeight = getTerrainHeight(x, y);
            if (runwayHeight < 15 || isWaterAt(x, y, runwayHeight)) {
                return { stamps: [], airport: null };
            }

            const airport = {
                id, x, y, heading, faction,
                length: runwayLength,
                width: runwayWidth,
                entities: [],
                baseHeight: runwayHeight  // Store for reference
            };

            // Create stamps for runway - NO flattening, just paint on naturally flat terrain
            const stamps = [
                // Paint runway color directly on terrain (no flatten stamp)
                { type: 'color', x, y, width: runwayWidth, length: runwayLength, heading, color: 0xFF2a2a2a, alpha: 1 },
                // Center line
                { type: 'color', x, y, width: 2, length: runwayLength - 10, heading, color: 0xFF4a4a4a, alpha: 1 }
            ];

            // Spawn buildings alongside runway - positions halved for shorter runway
            const cos = Math.cos(heading);
            const sin = Math.sin(heading);
            const sideOffset = runwayWidth + 15;

            // Hangar - offset reduced from 40 to 20
            const hangarX = x + cos * 20 + sin * sideOffset;
            const hangarY = y - sin * 20 + cos * sideOffset;
            const hangar = spawnTargetAt('HANGAR', hangarX, hangarY, faction, runwayHeight);
            if (hangar) airport.entities.push(hangar);

            // Control tower - offset reduced from -15 to -8
            const towerX = x - cos * 8 + sin * sideOffset;
            const towerY = y + sin * 8 + cos * sideOffset;
            const tower = spawnTargetAt('CONTROL_TOWER', towerX, towerY, faction, runwayHeight);
            if (tower) airport.entities.push(tower);

            // Fuel depot - offset reduced from 70 to 35
            const fuelX = x + cos * 35 + sin * sideOffset;
            const fuelY = y - sin * 35 + cos * sideOffset;
            const fuel = spawnTargetAt('FUEL_DEPOT', fuelX, fuelY, faction, runwayHeight);
            if (fuel) airport.entities.push(fuel);

            // SAM site for defense - offset reduced from -60 to -30
            const samX = x - cos * 30 - sin * (sideOffset + 20);
            const samY = y + sin * 30 - cos * (sideOffset + 20);
            const sam = spawnTargetAt('SAM_SITE', samX, samY, faction);
            if (sam) airport.entities.push(sam);

            world.airports.push(airport);
            return { stamps, airport };
        }

        function generateBase(x, y, faction = FACTIONS.ENEMY, size = 'medium') {
            const id = 'base_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            const baseRadius = size === 'small' ? 60 : size === 'large' ? 120 : 90;

            const base = {
                id, x, y, faction, size,
                buildings: [],
                defenses: []
            };

            // Flatten the base area
            // No flatten stamp - we rely on naturally flat terrain found by findFlatSpot()
            const stamps = [];

            // Spawn buildings in a rough layout
            const buildingCount = size === 'small' ? 2 : size === 'large' ? 5 : 3;

            // Barracks
            for (let i = 0; i < Math.min(2, buildingCount); i++) {
                const angle = (i / buildingCount) * Math.PI * 2 + Math.random() * 0.3;
                const dist = baseRadius * 0.5 + Math.random() * baseRadius * 0.3;
                const bx = x + Math.cos(angle) * dist;
                const by = y + Math.sin(angle) * dist;
                const barracks = spawnTargetAt('BARRACKS', bx, by, faction);
                if (barracks) base.buildings.push(barracks);
            }

            // Helipad
            const helipadX = x + (Math.random() - 0.5) * baseRadius * 0.6;
            const helipadY = y + (Math.random() - 0.5) * baseRadius * 0.6;
            const helipad = spawnTargetAt('HELIPAD', helipadX, helipadY, faction);
            if (helipad) {
                base.buildings.push(helipad);
                world.helipads.push({ id: helipad.id, x: helipadX, y: helipadY, faction });
                stamps.push(
                    { type: 'color', x: helipadX, y: helipadY, width: 26, length: 26, heading: 0, color: 0xFF2a2a2a, alpha: 1 },
                    { type: 'color', x: helipadX, y: helipadY, width: 18, length: 18, heading: 0, color: 0xFF3a3a3a, alpha: 1 }
                );
            }

            // Defenses - soldiers and maybe a tank
            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = baseRadius * 0.7 + Math.random() * baseRadius * 0.2;
                const sx = x + Math.cos(angle) * dist;
                const sy = y + Math.sin(angle) * dist;
                const soldier = spawnTargetAt('SOLDIER', sx, sy, faction);
                if (soldier) base.defenses.push(soldier);
            }

            if (size !== 'small') {
                const tankAngle = Math.random() * Math.PI * 2;
                const tankDist = baseRadius * 0.8;
                const tank = spawnTargetAt('TANK', x + Math.cos(tankAngle) * tankDist, y + Math.sin(tankAngle) * tankDist, faction);
                if (tank) base.defenses.push(tank);
            }

            // SAM site
            const samAngle = Math.random() * Math.PI * 2;
            const sam = spawnTargetAt('SAM_SITE', x + Math.cos(samAngle) * baseRadius, y + Math.sin(samAngle) * baseRadius, faction);
            if (sam) base.defenses.push(sam);

            world.bases.push(base);
            return { stamps, base };
        }

        function generateWorldStructures() {
            // Reset world
            world.stamps = [];
            world.airports = [];
            world.bases = [];
            world.helipads = [];
            airportSpawnTimers = {};
            helipadSpawnTimers = {};

            // Generate 1-2 airports - allow 15 units height difference over sample radius
            const airportCount = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < airportCount; i++) {
                const spot = findFlatSpot(300, 30, 15, 512, 512, 250 + i * 150);
                if (spot) {
                    const heading = Math.random() * Math.PI * 2;
                    const result = generateAirport(spot.x, spot.y, heading);
                    if (result.airport) {
                        world.stamps.push(...result.stamps);
                    }
                }
            }

            // Generate 2-4 bases - allow 20 units height difference for bases
            const baseCount = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < baseCount; i++) {
                const spot = findFlatSpot(300, 20, 20, 512, 512, 200 + i * 100);
                if (spot) {
                    const sizes = ['small', 'medium', 'large'];
                    const size = sizes[Math.floor(Math.random() * sizes.length)];
                    const result = generateBase(spot.x, spot.y, FACTIONS.ENEMY, size);
                    world.stamps.push(...result.stamps);
                }
            }

            // Generate friendly helipad at player start position for resupply
            const homeHelipad = generateHelipad(512, 512, FACTIONS.FRIENDLY);
            world.stamps.push(...homeHelipad.stamps);

            // Apply all stamps
            if (world.stamps.length > 0) {
                applyMissionStamps(world.stamps);
            }
        }

        function applyAIMission(mission) {
            if (!mission) return;

            if (mission.weather) {
                weatherCondition = mission.weather;
            }

            if (mission.timeLimit) {
                missionTime = mission.timeLimit;
            }

            world.stamps = [];
            world.airports = [];
            world.bases = [];
            world.helipads = [];
            airportSpawnTimers = {};
            helipadSpawnTimers = {};

            for (let i = 0; i < (mission.airportCount || 1); i++) {
                const spot = findFlatSpot(300, 30, 15, 512, 512, 250 + i * 150);
                if (spot) {
                    const heading = Math.random() * Math.PI * 2;
                    const result = generateAirport(spot.x, spot.y, heading);
                    if (result.airport) {
                        world.stamps.push(...result.stamps);
                    }
                }
            }

            for (let i = 0; i < (mission.baseCount || 2); i++) {
                const spot = findFlatSpot(300, 20, 20, 512, 512, 200 + i * 100);
                if (spot) {
                    const sizes = ['small', 'medium', 'large'];
                    const size = sizes[Math.floor(Math.random() * sizes.length)];
                    const result = generateBase(spot.x, spot.y, FACTIONS.ENEMY, size);
                    world.stamps.push(...result.stamps);
                }
            }

            // Generate friendly helipad at player start position for resupply
            const homeHelipad = generateHelipad(512, 512, FACTIONS.FRIENDLY);
            world.stamps.push(...homeHelipad.stamps);

            if (world.stamps.length > 0) {
                applyMissionStamps(world.stamps);
            }

            if (Array.isArray(mission.entities)) {
                for (const entitySpec of mission.entities) {
                    const typeKey = String(entitySpec.type || '').toUpperCase();
                    const rawCount = Number(entitySpec.count || 0);
                    const count = Math.max(0, Number.isFinite(rawCount) ? rawCount : 0);
                    if (TARGET_TYPES[typeKey]) {
                        for (let i = 0; i < count; i++) {
                            spawnTarget(typeKey);
                        }
                    }
                }
            }
        }

        function spawnAircraftFromAirport(airport) {
            if (!airport || airport.faction !== FACTIONS.ENEMY) return null;

            // Choose aircraft type based on role
            // Transport planes are rarer (appear ~15% of the time)
            const roll = Math.random();
            let typeKey;
            if (roll < 0.15) {
                typeKey = 'AIR_TRANSPORT';
            } else if (roll < 0.55) {
                typeKey = 'AIR_FIGHTER';
            } else {
                typeKey = 'AIR_ATTACK_HELI';
            }

            // Spawn at runway end
            const cos = Math.cos(airport.heading);
            const sin = Math.sin(airport.heading);
            const spawnX = airport.x + cos * (airport.length / 2 + 20);
            const spawnY = airport.y + sin * (airport.length / 2 + 20);

            const aircraft = spawnTargetAt(typeKey, spawnX, spawnY, airport.faction);
            if (aircraft) {
                aircraft.z = getTerrainHeight(spawnX, spawnY) + 30;  // Start airborne
                if (aircraft.ai) {
                    aircraft.ai.heading = airport.heading;
                    aircraft.ai.patrolCenter = { x: airport.x, y: airport.y };
                }
            }

            return aircraft;
        }

        function updateAirportSpawns(currentTime) {
            const spawnInterval = 30000;  // 30 seconds between spawns
            const maxAircraft = ENTITY_BUDGET.maxAir;  // Max aircraft in world

            // Count current aircraft
            const aircraftCount = targets.filter(t => t.domain === DOMAINS.AIR && !t.destroyed).length;
            if (aircraftCount >= maxAircraft) return;

            for (const airport of world.airports) {
                if (!airportSpawnTimers[airport.id]) {
                    airportSpawnTimers[airport.id] = currentTime + Math.random() * spawnInterval;
                }

                if (currentTime > airportSpawnTimers[airport.id]) {
                    spawnAircraftFromAirport(airport);
                    airportSpawnTimers[airport.id] = currentTime + spawnInterval + Math.random() * 10000;
                }
            }
        }

        function spawnHeliFromHelipad(helipad) {
            if (!helipad || helipad.faction === FACTIONS.FRIENDLY || helipad.faction === 'friendly') return null;

            // Helipads only spawn attack helicopters
            const aircraft = spawnTargetAt('AIR_ATTACK_HELI', helipad.x, helipad.y, FACTIONS.ENEMY);
            if (aircraft) {
                aircraft.z = getTerrainHeight(helipad.x, helipad.y) + 20;  // Start airborne
                if (aircraft.ai) {
                    aircraft.ai.heading = Math.random() * Math.PI * 2;
                    aircraft.ai.patrolCenter = { x: helipad.x, y: helipad.y };
                }
            }

            return aircraft;
        }

        function updateHelipadSpawns(currentTime) {
            const spawnInterval = 45000;  // 45 seconds between spawns (slower than airports)
            const maxAircraft = ENTITY_BUDGET.maxAir;

            // Count current aircraft
            const aircraftCount = targets.filter(t => t.domain === DOMAINS.AIR && !t.destroyed).length;
            if (aircraftCount >= maxAircraft) return;

            for (const helipad of world.helipads) {
                // Skip friendly helipads
                if (helipad.faction === FACTIONS.FRIENDLY || helipad.faction === 'friendly') continue;

                if (!helipadSpawnTimers[helipad.id]) {
                    helipadSpawnTimers[helipad.id] = currentTime + Math.random() * spawnInterval;
                }

                if (currentTime > helipadSpawnTimers[helipad.id]) {
                    spawnHeliFromHelipad(helipad);
                    helipadSpawnTimers[helipad.id] = currentTime + spawnInterval + Math.random() * 15000;
                }
            }
        }
        
        function updateMissionTimer() {
            if (gameState === GAME_STATES.PLAYING) {
                // Skip timer update in free play mode (currentMissionIndex === -1)
                if (currentMissionIndex < 0) return;
                
                const mission = getActiveMission();
                if (mission && mission.timeLimit) {
                    const elapsed = (performance.now() - missionStartTime) / 1000;
                    const remaining = mission.timeLimit - elapsed;
                    
                    if (remaining <= 0) {
                        // Time's up - mission failed
                        missionTime = 0;
                        endMission(false, 'TIME EXPIRED');
                        return;
                    }
                    
                    missionTime = remaining;
                }
            }
        }

        function updatePlaytime(deltaTime) {
            if (gameState !== GAME_STATES.PLAYING) return;
            playtimeAccumulator += deltaTime;
            if (playtimeAccumulator >= 1000) {
                const seconds = Math.floor(playtimeAccumulator / 1000);
                playtimeAccumulator -= seconds * 1000;
                updateStats('totalTimePlayed', seconds);
                checkAchievements('stats');
            }
        }

        function getMissionElapsedSeconds() {
            if (!missionStartTime) return 0;
            return Math.max(0, (performance.now() - missionStartTime) / 1000);
        }

        function calculateMissionScore(mission) {
            let timeBonus = 0;
            if (mission.timeLimit && missionTime > 0) {
                timeBonus = Math.floor(missionTime * 10);
            }
            const healthBonus = Math.floor(playerHealth * 10);
            const reward = mission.rewards.score;
            const totalScore = score + timeBonus + healthBonus + reward;
            return { timeBonus, healthBonus, reward, totalScore };
        }

        function calculateMissionStars(mission, elapsedSeconds) {
            let stars = 1;
            const healthPercent = playerHealth / maxPlayerHealth;
            if (healthPercent >= 0.8) stars++;
            if (mission.timeLimit) {
                if (elapsedSeconds <= mission.timeLimit * 0.6) stars++;
            } else if (elapsedSeconds > 0 && elapsedSeconds <= 120) {
                stars++;
            }
            return Math.min(3, stars);
        }
        
        function endMission(victory, reason = '') {
            // Stop all sounds when mission ends
            stopRotorSound();
            stopWarningAlarm();
            stopWindSound();

            const mission = getActiveMission();
            const elapsed = getMissionElapsedSeconds();
            lastMissionElapsed = elapsed;
            const timeElapsed = telemetry.flightTime + telemetry.groundTime;
            let finalScore = score;
            let scoreInfo = null;
            
            if (victory) {
                missionComplete = true;
                if (mission) {
                    scoreInfo = calculateMissionScore(mission);
                    finalScore = scoreInfo.totalScore;
                    const starsEarned = calculateMissionStars(mission, elapsed);
                    recordMissionCompletion(mission, scoreInfo.totalScore, starsEarned);
                    checkAchievements('score', { score: scoreInfo.totalScore });
                    recordHighScore(scoreInfo.totalScore);
                    checkAchievements('mission_complete', { noDamage: missionNoDamage, elapsed });
                    sessionStats.score = scoreInfo.totalScore;
                    postStatsEvent({ type: 'mission_complete', count: 1 });
                    submitSessionScore(scoreInfo.totalScore);
                }
                playVictoryStinger();
                startTransition(GAME_STATES.VICTORY, 900, {
                    onSwitch: () => {
                        gameState = GAME_STATES.VICTORY;
                    }
                });
            } else {
                isPlayerDead = true;
                defeatReason = reason;
                if (reason && reason !== 'TIME EXPIRED') {
                    trackEvent('player_death', {
                        mode: gameMode,
                        missionId: currentMissionIndex,
                        cause: reason
                    });
                }
                updateStats('totalDeaths', 1);
                sessionStats.deaths += 1;
                postStatsEvent({ type: 'death', count: 1 });
                submitSessionScore(score);
                playDefeatStinger();
                startTransition(GAME_STATES.DEFEAT, 900, {
                    onSwitch: () => {
                        gameState = GAME_STATES.DEFEAT;
                    }
                });
            }

            trackEvent('game_end', {
                mode: gameMode,
                missionId: currentMissionIndex,
                victory: victory,
                score: finalScore,
                kills: sessionStats.kills,
                accuracy: calculateAccuracy(),
                timeElapsed: timeElapsed
            });

        }
        
        // ============================================
        // COMBAT SYSTEM
        // ============================================
        function initCombat() {
            // This is now only called for background rendering in menu
            targets = [];
            projectiles = [];
            enemyProjectiles = [];
            explosions = [];
            particles = [];
            particlePool = [];
            score = 0;
            playerHealth = maxPlayerHealth;
            isPlayerDead = false;
            missionComplete = false;
            missileWarning = false;
            missileWarningTime = 0;
            screenFlashColor = null;
            screenFlashTime = 0;
            
            // Reset weapon ammo
            weaponState.cannon.ammo = Infinity;
            weaponState.rockets.ammo = WEAPONS.rockets.maxAmmo;
            weaponState.hellfire.ammo = WEAPONS.hellfire.maxAmmo;
            weaponState.stinger.ammo = WEAPONS.stinger.maxAmmo;
            currentWeaponIndex = 0;
            currentWeapon = weaponOrder[0];
            
            // Reset countermeasures
            countermeasures.chaff.count = 10;
            countermeasures.flare.count = 10;
            
            // Don't spawn targets in menu mode - they'll be spawned by startMission
        }
        
        // ============================================
        // WEAPON CYCLING
        // ============================================
        function nextWeapon() {
            currentWeaponIndex = (currentWeaponIndex + 1) % weaponOrder.length;
            currentWeapon = weaponOrder[currentWeaponIndex];
            // Reset lock state when weapon changes - allows auto-lock to restart for new weapon
            targetingSystem.lockedTarget = null;
            targetingSystem.lockProgress = 0;
            targetingSystem.isLocking = false;
        }
        
        function prevWeapon() {
            currentWeaponIndex = (currentWeaponIndex - 1 + weaponOrder.length) % weaponOrder.length;
            currentWeapon = weaponOrder[currentWeaponIndex];
            // Reset lock state when weapon changes - allows auto-lock to restart for new weapon
            targetingSystem.lockedTarget = null;
            targetingSystem.lockProgress = 0;
            targetingSystem.isLocking = false;
        }

        function switchSoldierWeapon(key) {
            if (!WEAPONS_DELTA[key]) return;
            soldierWeapon.current = key;
            soldierWeapon.isReloading = false;
            if (key !== 'airstrike') {
                airstrikeState.designating = false;
            }
            // Reset lock state when weapon changes - allows auto-lock to restart for new weapon
            targetingSystem.lockedTarget = null;
            targetingSystem.lockProgress = 0;
            targetingSystem.isLocking = false;
        }
        
        // Cycle through soldier weapons (Delta mode)
        const soldierWeaponOrder = ['m4', 'sniper', 'pistol', 'javelin', 'stinger', 'c4', 'airstrike'];
        function cycleSoldierWeapon(direction) {
            const currentIndex = soldierWeaponOrder.indexOf(soldierWeapon.current);
            const newIndex = (currentIndex + direction + soldierWeaponOrder.length) % soldierWeaponOrder.length;
            switchSoldierWeapon(soldierWeaponOrder[newIndex]);
        }

        function startSoldierReload() {
            if (gameMode !== GAME_MODES.DELTA) return;
            if (soldierWeapon.isReloading) return;
            const weapon = WEAPONS_DELTA[soldierWeapon.current];
            const state = soldierWeapon.weapons[soldierWeapon.current];
            if (!weapon || !state) return;
            if (soldierWeapon.current === 'airstrike') return;
            if (state.mag >= weapon.magSize) return;
            if (state.mags <= 0) return;
            soldierWeapon.isReloading = true;
            soldierWeapon.reloadStartTime = performance.now();
        }
        
        function fireWeapon(weaponKey) {
            const now = performance.now();
            const weapon = WEAPONS[weaponKey];
            const state = weaponState[weaponKey];

            // Player cannon has no burst cooldown - fires continuously
            // (Enemy helicopters have their own burst logic in AI update)
            
            if (now - lastFireTime < weapon.fireRate) return;
            if (state.ammo <= 0) return;
            
            lastFireTime = now;
            
            // Consume ammo (except for infinite ammo weapons)
            if (state.ammo !== Infinity) {
                state.ammo--;
            }
            
            // For guided missiles, check if we have a valid lock
            if (weapon.guided) {
                const lockedTarget = getLockedTargetForMissile();
                if (!lockedTarget) {
                    // No lock - don't fire guided missiles without a target
                    // Restore ammo since we didn't actually fire
                    if (state.ammo !== Infinity) {
                        state.ammo++;
                    }
                    return;
                }
            }
            
            // Play appropriate sound
            if (weaponKey === 'cannon') {
                playCannonSound();
            } else if (weaponKey === 'rockets') {
                playRocketSound();
            } else if (weaponKey === 'hellfire' || weaponKey === 'stinger') {
                playMissileSound();
            }

            // Combat feedback (muzzle flash + shake)
            const shakeIntensity = weaponKey === 'cannon' ? 1.2 : weaponKey === 'rockets' ? 2.6 : 3.2;
            const flashIntensity = weaponKey === 'cannon' ? 0.7 : weaponKey === 'rockets' ? 1.0 : 1.1;
            triggerMuzzleFlash(flashIntensity);
            addScreenShake(shakeIntensity, 120);
            
            // Apply spread
            const spreadAngle = camera.angle + (Math.random() - 0.5) * weapon.spread;
            
            // Calculate pitch based on horizon position
            // When horizon is HIGH, we're looking UP - bullets need HIGHER z to hit crosshair
            // When horizon is LOW, we're looking DOWN - bullets need LOWER z to hit crosshair
            // The divisor 240 matches the projection scale (screenY = (h - z) * 240/dist + horizon)
            const pitchFactor = (camera.horizon - screenHeight / 2) / 240.0;
            
            // Spawn projectile ahead of camera so it's immediately visible
            // (renderProjectiles has ry > 5 minimum distance check)
            const spawnOffset = 8;  // units ahead of camera
            
            // For guided missiles, get the locked target
            const lockedTarget = weapon.guided ? getLockedTargetForMissile() : null;
            
            projectiles.push({
                x: camera.x - Math.sin(spreadAngle) * spawnOffset,
                y: camera.y - Math.cos(spreadAngle) * spawnOffset,
                z: camera.height + pitchFactor * spawnOffset,  // Start at pitched height
                angle: spreadAngle,
                pitch: pitchFactor,
                speed: weapon.projectileSpeed,
                damage: weapon.damage,
                lifetime: 150,  // frames
                type: weaponKey,
                projectileType: weapon.projectileType,
                color: weapon.color,
                guided: weapon.guided || false,
                airToAir: weapon.airToAir || false,
                playerFired: true,
                lockedTargetId: lockedTarget?.id || null  // Store locked target ID
            });

            sessionStats.shotsFired += 1;
            telemetry.shotsFired += 1;
            if (weapon.projectileType === 'missile') {
                telemetry.missilesFired += 1;
            }
        }

        function getSoldierSpread(weapon) {
            let spread = weapon.spread;
            if (SOLDIER.stance === 'crouch') spread *= 0.6;
            if (SOLDIER.stance === 'prone') spread *= 0.35;
            if (SOLDIER.isSprinting) spread *= 1.6;
            return spread;
        }

        function fireSoldierWeapon(weaponKey, now) {
            const weapon = WEAPONS_DELTA[weaponKey];
            const state = soldierWeapon.weapons[weaponKey];
            if (!weapon || !state) return;
            if (soldierWeapon.isReloading) return;
            if (state.mag <= 0) return;
            if (now - state.lastFire < weapon.fireRate) return;

            // For guided missiles (Javelin, Stinger), check if we have a valid lock
            if (weapon.guided) {
                const lockedTarget = getLockedTargetForMissile();
                if (!lockedTarget) {
                    // No lock - don't fire guided missiles without a target
                    return;
                }
            }

            state.lastFire = now;
            state.mag--;

            const spread = getSoldierSpread(weapon);
            const spreadAngle = camera.angle + (Math.random() - 0.5) * spread;
            const pitchFactor = (camera.horizon - screenHeight / 2) / 240.0;
            const spawnOffset = 6;
            
            // For guided missiles, get the locked target
            const lockedTarget = weapon.guided ? getLockedTargetForMissile() : null;

            projectiles.push({
                x: camera.x - Math.sin(spreadAngle) * spawnOffset,
                y: camera.y - Math.cos(spreadAngle) * spawnOffset,
                z: camera.height + pitchFactor * spawnOffset,
                angle: spreadAngle,
                pitch: pitchFactor,
                speed: weapon.projectileSpeed,
                damage: weapon.damage,
                lifetime: 140,
                type: weaponKey,
                projectileType: weapon.projectileType || 'bullet',
                color: weapon.color,
                guided: weapon.guided || false,
                airToAir: weapon.airToAir || false,
                playerFired: true,
                lockedTargetId: lockedTarget?.id || null  // Store locked target ID for guided missiles
            });

            sessionStats.shotsFired += 1;
            telemetry.shotsFired += 1;

            const recoilKick = weaponKey === 'sniper' ? 6.5 : weaponKey === 'm4' ? 2.4 : 1.6;
            camera.horizon = Math.max(screenHeight * 0.25, Math.min(screenHeight * 0.75, camera.horizon - recoilKick));
            soldierWeapon.recoilOffset += recoilKick;

            const flashIntensity = weaponKey === 'sniper' ? 1.2 : weaponKey === 'm4' ? 0.9 : 0.7;
            triggerMuzzleFlash(flashIntensity * 0.6);
            soldierWeapon.muzzleFlashTime = 120;
        }
        
        // ============================================
        // C4 EXPLOSIVE SYSTEM
        // ============================================
        
        // Place a C4 charge at the player's current position
        function placeC4Charge() {
            const state = soldierWeapon.weapons.c4;
            const weapon = WEAPONS_DELTA.c4;
            if (!state || !weapon) return false;
            
            // Check if we have charges left
            const totalCharges = state.mag + state.mags;
            if (totalCharges <= 0) return false;
            
            // Consume a charge
            if (state.mag > 0) {
                state.mag--;
            } else if (state.mags > 0) {
                state.mags--;
            }
            
            // Get terrain height at player position
            const terrainZ = getTerrainHeight(camera.x, camera.y);
            
            // Place the charge slightly in front of player on the ground
            const placeOffset = 8;
            const chargeX = camera.x - Math.sin(camera.angle) * placeOffset;
            const chargeY = camera.y - Math.cos(camera.angle) * placeOffset;
            const chargeZ = getTerrainHeight(chargeX, chargeY) + 2;
            
            placedC4Charges.push({
                id: Date.now() + Math.random(),
                x: chargeX,
                y: chargeY,
                z: chargeZ,
                placedAt: performance.now(),
                armed: true
            });
            
            // Play placement sound (reuse an existing sound)
            playMenuConfirmSound();
            
            return true;
        }
        
        // Detonate all placed C4 charges
        function detonateAllC4() {
            if (placedC4Charges.length === 0) return false;
            
            const weapon = WEAPONS_DELTA.c4;
            const blastRadius = weapon.blastRadius || 60;
            const damage = weapon.damage;
            
            for (const charge of placedC4Charges) {
                // Create explosion at charge location
                explosions.push({
                    x: charge.x,
                    y: charge.y,
                    z: charge.z,
                    size: blastRadius,
                    maxSize: blastRadius,
                    lifetime: 40,
                    maxLifetime: 40,
                    type: 'c4'
                });
                
                // Play explosion sound
                playExplosionSound();
                
                // Screen shake
                addScreenShake(8, 300);
                
                // Deal damage to all targets in blast radius
                for (const target of targets) {
                    if (target.destroyed) continue;
                    if (target.faction === FACTIONS.FRIENDLY) continue;
                    
                    const dx = target.x - charge.x;
                    const dy = target.y - charge.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < blastRadius) {
                        // Damage falls off with distance
                        const falloff = 1 - (dist / blastRadius);
                        const category = getTargetDamageCategory(target);
                        const multiplier = DAMAGE_MULTIPLIERS.c4?.[category] || 1;
                        const finalDamage = damage * falloff * multiplier;
                        
                        target.health = (target.health || 100) - finalDamage;
                        
                        if (target.health <= 0) {
                            target.destroyed = true;
                            target.destroyedTime = performance.now();
                            score += target.points || 100;
                            sessionStats.targetsDestroyed += 1;
                            sessionStats.score = score;
                            telemetry.targetsDestroyed += 1;
                            
                            // Add secondary explosion for destroyed target
                            explosions.push({
                                x: target.x,
                                y: target.y,
                                z: target.z || getTerrainHeight(target.x, target.y) + 5,
                                size: 25,
                                maxSize: 25,
                                lifetime: 30,
                                maxLifetime: 30,
                                type: 'secondary'
                            });
                        }
                    }
                }
            }
            
            // Clear all charges after detonation
            placedC4Charges = [];
            
            return true;
        }
        
        // Handle C4 weapon action (place or detonate)
        function handleC4Action(now) {
            const state = soldierWeapon.weapons.c4;
            const weapon = WEAPONS_DELTA.c4;
            
            // Check fire rate cooldown
            if (now - state.lastFire < weapon.fireRate) return;
            state.lastFire = now;
            
            // If we have placed charges, detonate them
            if (placedC4Charges.length > 0) {
                detonateAllC4();
                return;
            }
            
            // Otherwise, place a new charge
            placeC4Charge();
        }

        // ============================================
        // AIRSTRIKE SYSTEM
        // ============================================

        function getAirstrikeAimPoint() {
            const maxRange = Math.min(camera.distance, 1400);
            const angle = camera.angle;
            const dirX = -Math.sin(angle);
            const dirY = -Math.cos(angle);
            const pitchFactor = (camera.horizon - screenHeight / 2) / 240.0;
            const dirZ = pitchFactor;

            let terrainDist = maxRange;
            const step = 6;
            for (let t = step; t <= maxRange; t += step) {
                const sampleX = ((camera.x + dirX * t) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                const sampleY = ((camera.y + dirY * t) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                const terrainHeight = getTerrainHeight(sampleX, sampleY);
                const rayZ = camera.height + dirZ * t;
                if (rayZ <= terrainHeight) {
                    terrainDist = t;
                    break;
                }
            }

            const aimX = ((camera.x + dirX * terrainDist) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
            const aimY = ((camera.y + dirY * terrainDist) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
            const aimZ = getTerrainHeight(aimX, aimY) + 2;

            return { x: aimX, y: aimY, z: aimZ, distance: terrainDist };
        }

        function getAirstrikeCharges(state) {
            return (state?.mag || 0) + (state?.mags || 0);
        }

        function consumeAirstrikeCharge(state) {
            if (!state) return false;
            if (state.mag > 0) {
                state.mag -= 1;
                return true;
            }
            if (state.mags > 0) {
                state.mags -= 1;
                return true;
            }
            return false;
        }

        function callAirstrike(targetX, targetY, targetZ) {
            // Get player position
            const playerX = camera.x;
            const playerY = camera.y;
            
            // Calculate direction from player to target
            const toTargetX = targetX - playerX;
            const toTargetY = targetY - playerY;
            const toTargetDist = Math.sqrt(toTargetX * toTargetX + toTargetY * toTargetY);
            
            // Normalize direction
            const dirX = toTargetDist > 0 ? toTargetX / toTargetDist : 1;
            const dirY = toTargetDist > 0 ? toTargetY / toTargetDist : 0;
            
            // Spawn plane on the opposite side of player from target, at map edge
            const spawnDist = 300; // Distance behind player
            let spawnX = playerX - dirX * spawnDist;
            let spawnY = playerY - dirY * spawnDist;
            
            // Ensure spawn is outside map bounds for dramatic entrance
            const buffer = 60;
            if (spawnX >= 0 && spawnX <= CONFIG.MAP_SIZE) {
                spawnX = dirX > 0 ? -buffer : CONFIG.MAP_SIZE + buffer;
            }
            if (spawnY >= 0 && spawnY <= CONFIG.MAP_SIZE) {
                spawnY = dirY > 0 ? -buffer : CONFIG.MAP_SIZE + buffer;
            }

            // Initial heading toward player
            const headingToPlayer = Math.atan2(playerY - spawnY, playerX - spawnX);

            airstrikeState.planesInbound.push({
                id: Date.now() + Math.random(),
                type: 'strike_aircraft',
                faction: FACTIONS.FRIENDLY,
                x: spawnX,
                y: spawnY,
                z: 400,  // High altitude to clear mountains
                playerX,  // Store player position at time of call
                playerY,
                targetX,
                targetY,
                targetZ,
                heading: headingToPlayer,
                speed: 0.18,  // Slow enough to see the flyover clearly
                phase: 'inbound',  // First phase: fly toward player
                hasFired: false,
                destroyed: false
            });

            airstrikeState.targetX = targetX;
            airstrikeState.targetY = targetY;
            airstrikeState.targetZ = targetZ;
            airstrikeState.inboundMessageUntil = performance.now() + 6000;
        }

        function fireAirstrikeMissile(aircraft) {
            // Calculate pitch to dive toward target
            const dx = aircraft.targetX - aircraft.x;
            const dy = aircraft.targetY - aircraft.y;
            const dz = aircraft.targetZ - aircraft.z;
            const horizDist = Math.sqrt(dx * dx + dy * dy);
            const pitch = horizDist > 0 ? dz / horizDist : -0.5;
            
            projectiles.push({
                x: aircraft.x,
                y: aircraft.y,
                z: aircraft.z - 5,  // Drop from under the aircraft
                angle: aircraft.heading,
                pitch: Math.max(-0.8, pitch),  // Dive angle toward target
                speed: 4.0,  // Fast missile
                damage: 250,
                blastRadius: 65,
                lifetime: 500,  // Long lifetime to reach distant targets
                type: 'airstrike',
                projectileType: 'missile',
                color: '#ffd166',
                guided: false,
                airToAir: false,
                playerFired: false,
                isAirstrike: true,
                targetX: aircraft.targetX,
                targetY: aircraft.targetY,
                targetZ: aircraft.targetZ,
                noWrap: true
            });

            playMissileSound();
        }

        function updateAirstrikePlanes(deltaTime) {
            if (airstrikeState.planesInbound.length === 0) return;
            const dt = Math.max(0, Math.min(3, deltaTime / 16.666));
            const now = performance.now();

            for (let i = airstrikeState.planesInbound.length - 1; i >= 0; i--) {
                const plane = airstrikeState.planesInbound[i];
                if (plane.destroyed) {
                    airstrikeState.planesInbound.splice(i, 1);
                    continue;
                }

                if (plane.phase === 'inbound') {
                    // Phase 1: Flying toward player position
                    const dx = plane.playerX - plane.x;
                    const dy = plane.playerY - plane.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    // Smoothly turn toward player
                    const targetHeading = Math.atan2(dy, dx);
                    const headingDiff = normalizeAngle(targetHeading - plane.heading);
                    plane.heading += Math.sign(headingDiff) * Math.min(Math.abs(headingDiff), 0.03 * dt);
                    
                    // Once near player, switch to attack run toward target
                    if (distToPlayer < 100) {
                        plane.phase = 'attack';
                    }
                } else if (plane.phase === 'attack') {
                    // Phase 2: Attack run toward target
                    const dx = plane.targetX - plane.x;
                    const dy = plane.targetY - plane.y;
                    const distToTarget = Math.sqrt(dx * dx + dy * dy);
                    
                    // Turn toward target
                    const targetHeading = Math.atan2(dy, dx);
                    const headingDiff = normalizeAngle(targetHeading - plane.heading);
                    plane.heading += Math.sign(headingDiff) * Math.min(Math.abs(headingDiff), 0.04 * dt);
                    
                    // Fire when directly over target (within 40 units)
                    if (distToTarget < 40 && !plane.hasFired) {
                        fireAirstrikeMissile(plane);
                        plane.hasFired = true;
                        plane.phase = 'egress';
                    }
                }

                // Move plane forward
                plane.x += Math.cos(plane.heading) * plane.speed * dt * 60;
                plane.y += Math.sin(plane.heading) * plane.speed * dt * 60;

                if (plane.phase === 'egress') {
                    // Continue straight after firing, exit map
                    if (plane.x < -120 || plane.x > CONFIG.MAP_SIZE + 120 || plane.y < -120 || plane.y > CONFIG.MAP_SIZE + 120) {
                        plane.destroyed = true;
                    }
                }
            }

            if (airstrikeState.planesInbound.length === 0 && !airstrikeState.designating && now > airstrikeState.inboundMessageUntil) {
                airstrikeState.targetX = null;
                airstrikeState.targetY = null;
                airstrikeState.targetZ = null;
            }
        }

        function applyBlastDamage(x, y, z, blastRadius, damage, weaponType) {
            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.faction === FACTIONS.FRIENDLY) continue;

                const dx = target.x - x;
                const dy = target.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist >= blastRadius) continue;

                const falloff = 1 - (dist / blastRadius);
                const category = getTargetDamageCategory(target);
                const multiplier = DAMAGE_MULTIPLIERS[weaponType]?.[category] || 1;
                const finalDamage = damage * falloff * multiplier;

                target.health = (target.health || 100) - finalDamage;

                if (target.health <= 0) {
                    target.destroyed = true;
                    target.destroyedTime = performance.now();
                    score += target.points || 100;
                    sessionStats.targetsDestroyed += 1;
                    sessionStats.score = score;
                    telemetry.targetsDestroyed += 1;

                    explosions.push({
                        x: target.x,
                        y: target.y,
                        z: target.z || getTerrainHeight(target.x, target.y) + 5,
                        size: 25,
                        maxSize: 25,
                        lifetime: 30,
                        maxLifetime: 30,
                        type: 'secondary'
                    });
                }
            }
        }

        function updateAirstrikeMissile(projectile, dt, index) {
            let dx = projectile.targetX - projectile.x;
            let dy = projectile.targetY - projectile.y;
            let dz = projectile.targetZ - projectile.z;
            let dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist > 0) {
                const dirX = dx / dist;
                const dirY = dy / dist;
                const dirZ = dz / dist;
                projectile.x += dirX * projectile.speed * dt;
                projectile.y += dirY * projectile.speed * dt;
                projectile.z += dirZ * projectile.speed * dt;
                projectile.angle = Math.atan2(-dirX, -dirY);
                projectile.pitch = dirZ;
            }

            if (Math.random() < 0.3) {
                spawnParticles(projectile.x, projectile.y, projectile.z, 'trail_smoke', 1);
            }

            projectile.lifetime -= dt;

            dx = projectile.targetX - projectile.x;
            dy = projectile.targetY - projectile.y;
            dz = projectile.targetZ - projectile.z;
            dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            const terrainHeight = getTerrainHeight(projectile.x, projectile.y);
            const impactZ = Math.max(terrainHeight, projectile.targetZ || terrainHeight);
            const impactDist = Math.sqrt(dx * dx + dy * dy);
            const hasHit = dist < 8 || projectile.z <= terrainHeight || impactDist < 6;

            if (hasHit) {
                createExplosion(projectile.x, projectile.y, impactZ, 'large');
                applyBlastDamage(projectile.x, projectile.y, impactZ, projectile.blastRadius, projectile.damage, 'airstrike');
                projectiles.splice(index, 1);
                return true;
            }

            if (projectile.lifetime <= 0) {
                projectiles.splice(index, 1);
                return true;
            }

            if (projectile.noWrap) {
                if (projectile.x < -200 || projectile.x > CONFIG.MAP_SIZE + 200 || projectile.y < -200 || projectile.y > CONFIG.MAP_SIZE + 200) {
                    projectiles.splice(index, 1);
                    return true;
                }
            }

            return false;
        }

        function handleAirstrikeAction(now) {
            const state = soldierWeapon.weapons.airstrike;
            if (!state) return;
            if (now - state.lastFire < 450) return;

            if (airstrikeState.designating) {
                const aimPoint = getAirstrikeAimPoint();
                if (!aimPoint) return;
                if (!consumeAirstrikeCharge(state)) {
                    airstrikeState.designating = false;
                    return;
                }
                state.lastFire = now;
                airstrikeState.designating = false;
                airstrikeState.lastCallTime = now;
                callAirstrike(aimPoint.x, aimPoint.y, aimPoint.z);
            } else {
                if (getAirstrikeCharges(state) <= 0) return;
                state.lastFire = now;
                airstrikeState.designating = true;
            }
        }
        
        // ============================================
        // TARGETING SYSTEM FUNCTIONS
        // ============================================
        
        // Get camera object for Delta mode (soldier view)
        function getDeltaCamera() {
            // In Delta mode, camera is already positioned at soldier location
            // Just return the camera object
            return camera;
        }
        
        // Get all valid targets in view, sorted by angle from crosshair
        function getTargetsInView(cam, maxRange = 800) {
            const validTypes = targetingSystem.getValidTargetTypes();
            
            // No targeting for weapons that don't need lock
            if (!validTypes.requiresLock) return [];
            
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            const pitchFactor = (cam.horizon - screenHeight / 2) / 240.0;
            
            const visibleTargets = [];
            
            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.faction !== FACTIONS.ENEMY) continue;
                
                // Never target soldiers - they are too small for vehicle/aircraft targeting systems
                if (target.type === 'soldier') continue;
                
                // Filter by domain if weapon requires specific target type
                if (validTypes.domain) {
                    if (validTypes.domain === 'surface') {
                        // Surface targets = ground + structure (not air)
                        if (target.domain === DOMAINS.AIR) continue;
                    } else if (target.domain !== validTypes.domain) {
                        continue;
                    }
                }
                
                // Calculate relative position
                let dx = target.x - cam.x;
                let dy = target.y - cam.y;
                
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxRange || dist < 10) continue;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Must be in front of camera
                if (ry < 10) continue;
                
                // Calculate angle from crosshair
                const angleToTarget = Math.atan2(rx, ry);
                const dz = target.z - cam.height;
                const verticalAngle = Math.atan2(dz, dist);
                const verticalDiff = verticalAngle - pitchFactor;
                
                // Only include targets within ~60 degree forward cone
                if (Math.abs(angleToTarget) > 0.6) continue;
                
                // Check line of sight - can't lock targets behind terrain
                const losSteps = 5;
                let hasLineOfSight = true;
                for (let i = 1; i < losSteps; i++) {
                    const t = i / losSteps;
                    const checkX = cam.x + dx * t;
                    const checkY = cam.y + dy * t;
                    const checkZ = cam.height + (target.z - cam.height) * t;
                    
                    const mapX = Math.floor(checkX) & (CONFIG.MAP_SIZE - 1);
                    const mapY = Math.floor(checkY) & (CONFIG.MAP_SIZE - 1);
                    const terrainHeight = currentMap.altitude[(mapY << CONFIG.MAP_SHIFT) + mapX];
                    
                    if (checkZ < terrainHeight + 5) { // +5 for some tolerance
                        hasLineOfSight = false;
                        break;
                    }
                }
                if (!hasLineOfSight) continue;
                
                const totalAngle = Math.sqrt(angleToTarget * angleToTarget + verticalDiff * verticalDiff);
                
                visibleTargets.push({
                    target,
                    dist,
                    angleFromCrosshair: totalAngle,
                    screenAngleX: angleToTarget,
                    screenAngleY: verticalDiff,
                    rx, ry
                });
            }
            
            // Sort by angle from crosshair (closest to center first)
            visibleTargets.sort((a, b) => a.angleFromCrosshair - b.angleFromCrosshair);
            
            return visibleTargets;
        }
        
        // Cycle to next target
        function cycleTarget(direction = 1) {
            const now = performance.now();
            if (now - targetingSystem.lastCycleTime < 200) return; // Debounce
            targetingSystem.lastCycleTime = now;
            
            const cam = gameMode === GAME_MODES.DELTA ? getDeltaCamera() : camera;
            const visibleTargets = getTargetsInView(cam, targetingSystem.getTargetingRange());
            
            if (visibleTargets.length === 0) {
                targetingSystem.selectedTarget = null;
                targetingSystem.lockedTarget = null;
                return;
            }
            
            // Find current target index
            let currentIndex = -1;
            if (targetingSystem.selectedTarget) {
                currentIndex = visibleTargets.findIndex(t => t.target === targetingSystem.selectedTarget);
            }
            
            // Cycle to next/prev
            let newIndex;
            if (currentIndex === -1) {
                newIndex = 0; // Select first target
            } else {
                newIndex = (currentIndex + direction + visibleTargets.length) % visibleTargets.length;
            }
            
            const newTarget = visibleTargets[newIndex]?.target;
            
            // If target changed, reset lock
            if (newTarget !== targetingSystem.selectedTarget) {
                targetingSystem.selectedTarget = newTarget;
                targetingSystem.lockedTarget = null;
                targetingSystem.lockProgress = 0;
                targetingSystem.isLocking = false;
            }
        }
        
        // Select the target closest to crosshairs (T key)
        function selectTargetInCrosshairs() {
            const cam = gameMode === GAME_MODES.DELTA ? getDeltaCamera() : camera;
            const visibleTargets = getTargetsInView(cam, targetingSystem.getTargetingRange());
            
            if (visibleTargets.length === 0) return;
            
            // getTargetsInView already sorts by angle from crosshair, so first one is closest to center
            const closestTarget = visibleTargets[0].target;
            
            // Only select if reasonably close to crosshairs (within ~15 degrees)
            if (visibleTargets[0].angleFromCrosshair > 0.26) return;
            
            // Select this target and reset lock
            if (closestTarget !== targetingSystem.selectedTarget) {
                targetingSystem.selectedTarget = closestTarget;
                targetingSystem.lockedTarget = null;
                targetingSystem.lockProgress = 0;
                targetingSystem.isLocking = false;
            }
        }
        
        // Update targeting system (called each frame)
        function updateTargetingSystem(deltaTime) {
            const cam = gameMode === GAME_MODES.DELTA ? getDeltaCamera() : camera;
            const validTypes = targetingSystem.getValidTargetTypes();
            const targetingRange = targetingSystem.getTargetingRange();
            
            // Auto-select nearest target if none selected
            if (!targetingSystem.selectedTarget || targetingSystem.selectedTarget.destroyed) {
                const visibleTargets = getTargetsInView(cam, targetingRange);
                targetingSystem.selectedTarget = visibleTargets[0]?.target || null;
                targetingSystem.lockedTarget = null;
                targetingSystem.lockProgress = 0;
            }
            
            // Check if selected target is still valid and in view
            if (targetingSystem.selectedTarget) {
                const visibleTargets = getTargetsInView(cam, targetingRange);
                const stillVisible = visibleTargets.some(t => t.target === targetingSystem.selectedTarget);
                
                if (!stillVisible || targetingSystem.selectedTarget.destroyed) {
                    // Target lost - reset
                    targetingSystem.selectedTarget = visibleTargets[0]?.target || null;
                    targetingSystem.lockedTarget = null;
                    targetingSystem.lockProgress = 0;
                    targetingSystem.isLocking = false;
                }
            }
            
            // Auto-start lock acquisition when target is selected and weapon requires lock
            if (targetingSystem.selectedTarget && validTypes.requiresLock && !targetingSystem.isLocking && !targetingSystem.lockedTarget) {
                targetingSystem.isLocking = true;
                targetingSystem.lockStartTime = performance.now();
                targetingSystem.lockProgress = 0;
            }
            
            // Handle lock acquisition
            if (targetingSystem.isLocking && targetingSystem.selectedTarget && validTypes.requiresLock) {
                const lockTime = targetingSystem.getLockTime();
                const elapsed = performance.now() - targetingSystem.lockStartTime;
                targetingSystem.lockProgress = Math.min(100, (elapsed / lockTime) * 100);
                
                // Check if target is still near crosshair (must maintain aim) - use full targeting range
                const visibleTargets = getTargetsInView(cam, targetingRange);
                const targetInfo = visibleTargets.find(t => t.target === targetingSystem.selectedTarget);
                
                if (!targetInfo || targetInfo.angleFromCrosshair > 0.2) {
                    // Lost aim - reset lock progress
                    targetingSystem.lockProgress = Math.max(0, targetingSystem.lockProgress - deltaTime * 0.1);
                    if (targetingSystem.lockProgress <= 0) {
                        targetingSystem.isLocking = false;
                    }
                } else if (targetingSystem.lockProgress >= 100) {
                    // Lock acquired!
                    targetingSystem.lockedTarget = targetingSystem.selectedTarget;
                    targetingSystem.isLocking = false;
                }
            }
            
            // Clear lock if target destroyed
            if (targetingSystem.lockedTarget?.destroyed) {
                targetingSystem.lockedTarget = null;
                targetingSystem.lockProgress = 0;
            }
        }
        
        // Start lock acquisition
        function startLockAcquisition() {
            if (!targetingSystem.selectedTarget) return;
            
            const validTypes = targetingSystem.getValidTargetTypes();
            if (!validTypes.requiresLock) return; // Weapon doesn't need lock
            
            if (!targetingSystem.isLocking) {
                targetingSystem.isLocking = true;
                targetingSystem.lockStartTime = performance.now();
                targetingSystem.lockProgress = 0;
            }
        }
        
        // Stop lock acquisition
        function stopLockAcquisition() {
            targetingSystem.isLocking = false;
            // Keep partial progress for a moment
        }
        
        // Get the target that a missile should track
        function getLockedTargetForMissile() {
            // If we have a hard lock, use it
            if (targetingSystem.lockedTarget && !targetingSystem.lockedTarget.destroyed) {
                return targetingSystem.lockedTarget;
            }
            // Fall back to selected target if lock progress > 50%
            if (targetingSystem.selectedTarget && 
                !targetingSystem.selectedTarget.destroyed && 
                targetingSystem.lockProgress > 50) {
                return targetingSystem.selectedTarget;
            }
            return null;
        }
        
        // ============================================
        // GUIDED MISSILE SYSTEM
        // ============================================
        function findTargetInCrosshair(cam, maxRange = 500) {
            // Cast a ray from camera in look direction
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            
            // Get pitch from horizon offset
            const pitchFactor = (cam.horizon - screenHeight / 2) / 240.0;
            
            let bestTarget = null;
            let bestDist = maxRange;
            const crosshairTolerance = 0.15; // How close to center of screen (in radians)
            
            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.faction !== FACTIONS.ENEMY) continue;
                
                // Calculate relative position
                let dx = target.x - cam.x;
                let dy = target.y - cam.y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxRange || dist < 10) continue;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Must be in front of camera
                if (ry < 10) continue;
                
                // Calculate angle to target from camera's forward direction
                const angleToTarget = Math.atan2(rx, ry);
                
                // Calculate vertical angle to target
                const dz = target.z - cam.height;
                const verticalAngle = Math.atan2(dz, dist);
                const verticalDiff = Math.abs(verticalAngle - pitchFactor);
                
                // Check if target is within crosshair tolerance
                const totalAngleDiff = Math.sqrt(angleToTarget * angleToTarget + verticalDiff * verticalDiff);
                
                if (totalAngleDiff < crosshairTolerance && dist < bestDist) {
                    bestTarget = target;
                    bestDist = dist;
                }
            }
            
            // If nothing in crosshair, fall back to nearest in forward cone
            if (!bestTarget) {
                const coneTolerance = 0.4; // Wider cone for fallback
                for (const target of targets) {
                    if (target.destroyed) continue;
                    if (target.faction !== FACTIONS.ENEMY) continue;
                    
                    let dx = target.x - cam.x;
                    let dy = target.y - cam.y;
                    if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                    if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                    if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                    if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                    
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > maxRange || dist < 10) continue;
                    
                    const rx = dx * cosAngle - dy * sinAngle;
                    const ry = -dx * sinAngle - dy * cosAngle;
                    if (ry < 10) continue;
                    
                    const angleToTarget = Math.atan2(rx, ry);
                    if (Math.abs(angleToTarget) < coneTolerance && dist < bestDist) {
                        bestTarget = target;
                        bestDist = dist;
                    }
                }
            }
            
            return bestTarget;
        }
        
        function findNearestTarget(x, y, options = {}) {
            const { airToAir = false, faction = FACTIONS.ENEMY, maxRange = Infinity } = options;
            let nearest = null;
            let nearestDist = maxRange;
            
            for (const target of targets) {
                if (target.destroyed) continue;
                if (faction && target.faction !== faction) continue;
                
                // Air-to-air missiles only target air units (future feature)
                if (airToAir && target.domain !== DOMAINS.AIR) continue;
                
                let dx = target.x - x;
                let dy = target.y - y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = target;
                }
            }
            
            return nearest;
        }
        
        function normalizeAngle(angle) {
            while (angle > Math.PI) angle -= Math.PI * 2;
            while (angle < -Math.PI) angle += Math.PI * 2;
            return angle;
        }
        
        function updateGuidedMissile(projectile, dt) {
            // For player-fired guided missiles, use the locked target
            // For AI missiles, use nearest target
            let target;
            if (projectile.playerFired && projectile.lockedTargetId) {
                // Find the locked target by ID
                target = targets.find(t => t.id === projectile.lockedTargetId && !t.destroyed);
                // If locked target is destroyed, missile goes dumb
                if (!target) {
                    projectile.guided = false; // Missile loses guidance
                    return;
                }
            } else if (projectile.playerFired) {
                // Fallback to crosshair targeting (shouldn't happen with new system)
                target = findTargetInCrosshair(camera, 600);
            } else {
                target = findNearestTarget(projectile.x, projectile.y, { airToAir: projectile.airToAir });
            }
            
            if (target) {
                // Calculate relative position with map wrapping
                let dx = target.x - projectile.x;
                let dy = target.y - projectile.y;
                
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                // Calculate angle to target
                const targetAngle = Math.atan2(-dx, -dy);
                
                // Gradually turn toward target (homing behavior)
                const turnRate = 0.08 * dt;
                const angleDiff = normalizeAngle(targetAngle - projectile.angle);
                projectile.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);
            }
            
            // Move in current direction
            projectile.x -= Math.sin(projectile.angle) * projectile.speed * dt;
            projectile.y -= Math.cos(projectile.angle) * projectile.speed * dt;
            // Apply pitch (guided missiles adjust pitch toward target, but start with initial pitch)
            if (projectile.pitch !== undefined) {
                projectile.z += projectile.pitch * projectile.speed * dt;
            }
        }
        
        function updateProjectiles(deltaTime) {
            const dt = Math.max(0, Math.min(3, deltaTime / 16.666));
            if (dt <= 0) return;
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];

                if (p.isAirstrike) {
                    const removed = updateAirstrikeMissile(p, dt, i);
                    if (!removed) {
                        if (p.lifetime <= 0) {
                            projectiles.splice(i, 1);
                        }
                    }
                    continue;
                }
                
                // Guided missiles have special movement
                if (p.guided) {
                    updateGuidedMissile(p, dt);
                } else {
                    // Move projectile forward
                    p.x -= Math.sin(p.angle) * p.speed * dt;
                    p.y -= Math.cos(p.angle) * p.speed * dt;
                    // Apply pitch to altitude
                    p.z += p.pitch * p.speed * dt;
                }
                
                // Despawn projectiles that leave map boundaries (no wrapping)
                if (isOutsideBoundary(p.x, p.y)) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // Rocket/missile smoke trail - subtle, 30% spawn rate
                if ((p.projectileType === 'missile' || p.projectileType === 'rocket') && Math.random() < 0.3) {
                    spawnParticles(p.x, p.y, p.z, 'trail_smoke', 1);
                }
                
                p.lifetime -= dt;
                
                // Check terrain collision
                const terrainHeight = getTerrainHeight(p.x, p.y);
                
                // IMPORTANT: Check target hits BEFORE terrain removal
                // This allows hitting targets that are at or slightly below terrain level
                // (e.g., soldiers on slopes where bullet might graze terrain)
                let hitTarget = false;
                if (p.playerFired) {
                    hitTarget = checkSingleProjectileHit(p, i);
                }
                
                if (!hitTarget && p.z <= terrainHeight) {
                    const explosionSize = (p.projectileType === 'missile' || p.projectileType === 'rocket') ? 'large' : 'small';
                    createExplosion(p.x, p.y, terrainHeight, explosionSize);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check if expired
                if (p.lifetime <= 0 || hitTarget) {
                    projectiles.splice(i, 1);
                }
            }
        }

        // Check if a single projectile hits any target - returns true if hit
        function checkSingleProjectileHit(proj, projIndex) {
            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.faction === FACTIONS.FRIENDLY) continue;
                
                let dx = proj.x - target.x;
                let dy = proj.y - target.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist2D = Math.sqrt(dx * dx + dy * dy);
                
                // Check vertical (Z) distance
                const targetHeight = target.size * 0.75;
                const targetBottom = target.z - 5;
                const targetTop = target.z + targetHeight;
                const zInRange = proj.z >= targetBottom && proj.z <= targetTop;
                
                // Hitbox size
                const isBuilding = target.type && (target.type === 'building' || target.type === 'hangar' || 
                    target.type === 'control_tower' || target.type === 'fuel_depot' || 
                    target.type === 'barracks' || target.type === 'radar');
                const hitboxSize = isBuilding ? target.size * 0.5 : target.size;
                
                if (dist2D < hitboxSize && zInRange) {
                    // Hit! Apply damage
                    sessionStats.hits += 1;
                    telemetry.shotsHit += 1;
                    if (proj.projectileType === 'missile') {
                        telemetry.missilesHit += 1;
                    }
                    
                    const multiplier = getDamageMultiplier(proj.type, target);
                    const adjustedDamage = proj.damage * multiplier;
                    const damageDealt = Math.min(adjustedDamage, target.health);
                    telemetry.damageDealt += damageDealt;
                    target.health -= adjustedDamage;
                    
                    triggerHitMarker(proj.projectileType === 'bullet' ? 0.8 : 1.0);
                    if (proj.projectileType === 'bullet') {
                        playHitSound();
                    }
                    
                    if (target.health <= 0) {
                        target.destroyed = true;
                        score += target.points;
                        sessionStats.score += target.points;
                        sessionStats.kills += 1;
                        
                        // Update objective progress for target destruction
                        updateObjectiveProgress('target_destroyed', { 
                            type: target.type.toUpperCase(), 
                            id: target.id 
                        });
                        
                        trackEvent('kill', {
                            targetType: target.type,
                            weapon: gameMode === GAME_MODES.DELTA ? soldierWeapon.current : currentWeapon,
                            mode: gameMode
                        });
                        postStatsEvent({ type: 'kill', count: 1 });
                        updateStats('totalKills', 1);
                        if (target.type === 'tank') updateStats('tanksDestroyed', 1);
                        if (target.type === 'sam') updateStats('samsDestroyed', 1);
                        if (target.type === 'building') updateStats('buildingsDestroyed', 1);
                        checkAchievements('kill', { targetType: target.type });
                        if (currentMissionIndex === -1) {
                            recordHighScore(score);
                        }
                        
                        if (target.type === 'soldier') {
                            spawnParticles(target.x, target.y, target.z, 'blood', 8 + Math.floor(Math.random() * 5));
                            spawnParticles(target.x, target.y, target.z, 'dust', 4 + Math.floor(Math.random() * 3));
                        } else {
                            const explosionSize = target.type === 'building' ? 'large' : 'medium';
                            createExplosion(target.x, target.y, target.z, explosionSize);
                            spawnParticles(target.x, target.y, target.z, 'spark', 10 + Math.floor(Math.random() * 6));
                            spawnParticles(target.x, target.y, target.z, 'smoke', 5 + Math.floor(Math.random() * 4));
                            spawnParticles(target.x, target.y, target.z, 'debris', 5 + Math.floor(Math.random() * 4));
                        }
                    } else {
                        if (target.type === 'soldier') {
                            spawnParticles(proj.x, proj.y, proj.z, 'blood', 3 + Math.floor(Math.random() * 3));
                        } else {
                            const explosionSize = (proj.projectileType === 'missile' || proj.projectileType === 'rocket') ? 'medium' : 'small';
                            createExplosion(proj.x, proj.y, proj.z, explosionSize);
                            spawnParticles(proj.x, proj.y, proj.z, 'spark', 3);
                        }
                    }
                    
                    return true; // Hit a target
                }
            }
            return false; // No hit
        }
        
        function checkProjectileHits() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                // Skip player-fired projectiles - they're handled in updateProjectiles
                // to ensure target hits are checked before terrain collision
                if (proj.playerFired) continue;

                const candidates = [];
                for (const target of targets) {
                    if (target.destroyed) continue;
                    let dx = proj.x - target.x;
                    let dy = proj.y - target.y;
                    if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                    if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                    if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                    if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                    const dist2D = Math.sqrt(dx * dx + dy * dy);
                    candidates.push({ target, dx, dy, dist2D });
                }

                candidates.sort((a, b) => a.dist2D - b.dist2D);

                for (const entry of candidates) {
                    const target = entry.target;
                    const dist2D = entry.dist2D;

                    // Check vertical (Z) distance
                    // Target's vertical hitbox: from ground level to target.z + height
                    // Height is proportional to size (targets are roughly as tall as they are wide)
                    const targetHeight = target.size * 0.75;
                    const targetBottom = target.z - 5;  // Small margin below target center
                    const targetTop = target.z + targetHeight;
                    const zInRange = proj.z >= targetBottom && proj.z <= targetTop;

                    // Must be within both horizontal AND vertical range to hit
                    // Reduce hitbox for buildings/structures (they're visually large but shouldn't be easy to hit)
                    const isBuilding = target.type && (target.type === 'building' || target.type === 'hangar' || 
                        target.type === 'control_tower' || target.type === 'fuel_depot' || 
                        target.type === 'barracks' || target.type === 'radar');
                    const hitboxSize = isBuilding ? target.size * 0.5 : target.size;
                    if (dist2D < hitboxSize && zInRange) {
                            sessionStats.hits += 1;
                            telemetry.shotsHit += 1;
                            if (proj.projectileType === 'missile') {
                                telemetry.missilesHit += 1;
                            }
                            const multiplier = getDamageMultiplier(proj.type, target);
                            const adjustedDamage = proj.damage * multiplier;
                            const damageDealt = Math.min(adjustedDamage, target.health);
                            telemetry.damageDealt += damageDealt;
                            target.health -= adjustedDamage;

                            // Hit confirmation feedback
                            triggerHitMarker(proj.projectileType === 'bullet' ? 0.8 : 1.0);
                            
                            // Play hit sound for bullet impacts
                            if (proj.projectileType === 'bullet') {
                                playHitSound();
                            }
                            
                                if (target.health <= 0) {
                                    target.destroyed = true;
                                    score += target.points;
                                    sessionStats.score += target.points;
                                    sessionStats.kills += 1;
                                    trackEvent('kill', {
                                        targetType: target.type,
                                        weapon: gameMode === GAME_MODES.DELTA ? soldierWeapon.current : currentWeapon,
                                        mode: gameMode
                                    });
                                    postStatsEvent({ type: 'kill', count: 1 });
                                    updateStats('totalKills', 1);
                                if (target.type === 'tank') updateStats('tanksDestroyed', 1);
                                if (target.type === 'sam') updateStats('samsDestroyed', 1);
                                if (target.type === 'building') updateStats('buildingsDestroyed', 1);
                                checkAchievements('kill', { targetType: target.type });
                                if (currentMissionIndex === -1) {
                                    recordHighScore(score);
                                }
                                
                                // Different death effects based on target type
                                if (target.type === 'soldier') {
                                    // Soldiers don't explode - just blood/dust puff
                                    spawnParticles(target.x, target.y, target.z, 'blood', 8 + Math.floor(Math.random() * 5));
                                    spawnParticles(target.x, target.y, target.z, 'dust', 4 + Math.floor(Math.random() * 3));
                                } else {
                                    // Vehicles and buildings explode
                                    const explosionSize = target.type === 'building' ? 'large' : 'medium';
                                    createExplosion(target.x, target.y, target.z, explosionSize);
                                    spawnParticles(target.x, target.y, target.z, 'spark', 10 + Math.floor(Math.random() * 6));
                                    spawnParticles(target.x, target.y, target.z, 'smoke', 5 + Math.floor(Math.random() * 4));
                                    spawnParticles(target.x, target.y, target.z, 'debris', 5 + Math.floor(Math.random() * 4));
                                }
                            } else {
                                // Hit but not killed - small impact effect
                                if (target.type === 'soldier') {
                                    // Blood splatter on hit
                                    spawnParticles(proj.x, proj.y, proj.z, 'blood', 3 + Math.floor(Math.random() * 3));
                                } else {
                                    // Spark/ricochet on vehicles
                                    const explosionSize = (proj.projectileType === 'missile' || proj.projectileType === 'rocket') ? 'medium' : 'small';
                                    createExplosion(proj.x, proj.y, proj.z, explosionSize);
                                }
                            }
                            
                            // Remove projectile
                            projectiles.splice(i, 1);
                            break;
                        }
                }
            }
        }
        
        function distance2D(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function createExplosion(x, y, z, size) {
            const sizes = {
                small: { size: 15, lifetime: 15 },
                medium: { size: 25, lifetime: 20 },
                large: { size: 40, lifetime: 30 }
            };
            const s = sizes[size] || sizes.small;
            
            // Play explosion sound
            playExplosionSound(size);

            // Explosion punch (shake scales with size and proximity)
            const dist = distance3D(x, y, z, camera.x, camera.y, camera.height);
            const maxDist = size === 'large' ? 450 : size === 'medium' ? 300 : 180;
            const proximity = Math.max(0, 1 - dist / maxDist);
            if (proximity > 0) {
                const baseShake = size === 'large' ? 8 : size === 'medium' ? 4.5 : 2.5;
                addScreenShake(baseShake * proximity, 220);
                if (size === 'large' && proximity > 0.25) {
                    screenFlash('white', 120 + proximity * 80);
                }
            }

            // Particle aftermath
            spawnParticles(x, y, z, 'smoke', 3 + Math.floor(Math.random() * 3));
            const groundHeight = getTerrainHeight(x, y);
            if (Math.abs(z - groundHeight) < 10) {
                spawnParticles(x, y, groundHeight, 'dust', 1);
            }
            
            explosions.push({
                x: x,
                y: y,
                z: z,
                size: s.size,
                maxSize: s.size,
                lifetime: s.lifetime,
                maxLifetime: s.lifetime
            });
        }
        
        function updateExplosions(deltaTime) {
            const dt = Math.max(0, Math.min(3, deltaTime / 16.666));
            for (let i = explosions.length - 1; i >= 0; i--) {
                explosions[i].lifetime -= dt;
                if (explosions[i].lifetime <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        // ============================================
        // ENEMY AI SYSTEMS
        // ============================================
        function findNearestTargetOfFaction(fromUnit, targetFaction) {
            let nearest = null;
            let nearestDist = Infinity;

            for (const candidate of targets) {
                if (candidate.destroyed) continue;
                if (candidate === fromUnit) continue;
                if (candidate.faction !== targetFaction) continue;

                const dist = distance3D(
                    fromUnit.x,
                    fromUnit.y,
                    fromUnit.z ?? 0,
                    candidate.x,
                    candidate.y,
                    candidate.z ?? 0,
                );
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = candidate;
                }
            }

            return nearest;
        }

        function getAITarget(unit) {
            const faction = unit?.faction || FACTIONS.ENEMY;
            if (faction === FACTIONS.NEUTRAL) return null;

            const playerTarget = { x: camera.x, y: camera.y, z: camera.height };

            if (faction === FACTIONS.ENEMY) {
                const nearestFriendly = findNearestTargetOfFaction(unit, FACTIONS.FRIENDLY);
                if (nearestFriendly) {
                    const friendlyDist = distance3D(unit.x, unit.y, unit.z ?? 0, nearestFriendly.x, nearestFriendly.y, nearestFriendly.z ?? 0);
                    const playerDist = distance3D(unit.x, unit.y, unit.z ?? 0, playerTarget.x, playerTarget.y, playerTarget.z);
                    if (friendlyDist < playerDist) {
                        return { x: nearestFriendly.x, y: nearestFriendly.y, z: nearestFriendly.z, target: nearestFriendly, isPlayer: false };
                    }
                }
                return { x: playerTarget.x, y: playerTarget.y, z: playerTarget.z, target: 'player', isPlayer: true };
            }

            if (faction === FACTIONS.FRIENDLY) {
                const nearestEnemy = findNearestTargetOfFaction(unit, FACTIONS.ENEMY);
                if (!nearestEnemy) return null;
                return { x: nearestEnemy.x, y: nearestEnemy.y, z: nearestEnemy.z, target: nearestEnemy, isPlayer: false };
            }

            return null;
        }

        function raiseAlert() {
            if (gameMode !== GAME_MODES.DELTA) return;
            alertLevel = Math.min(alertLevel + 1, 3);
            alertTimer = ALERT_DURATION;
        }

        function updateAlertLevel(deltaTime) {
            if (gameMode !== GAME_MODES.DELTA) {
                alertLevel = 0;
                alertTimer = 0;
                return;
            }
            if (alertTimer > 0) {
                alertTimer -= deltaTime;
                if (alertTimer <= 0 && alertLevel > 0) {
                    alertLevel = Math.max(alertLevel - 1, 0);
                    if (alertLevel > 0) alertTimer = ALERT_DURATION;
                }
            }
        }

        function getAlertedDetectRange(baseRange) {
            if (gameMode !== GAME_MODES.DELTA) return baseRange;
            if (alertLevel === 0) return baseRange * 0.6;
            if (alertLevel === 1) return baseRange * 0.8;
            if (alertLevel === 2) return baseRange * 1.0;
            return baseRange * 1.5;
        }
        function updateEnemyAI(deltaTime, currentTime) {
            for (const target of targets) {
                if (target.destroyed || !target.ai) continue;
                
                if (target.ai.type === 'patrol') {
                    updateTankAI(target, deltaTime, currentTime);
                } else if (target.ai.type === 'sam') {
                    updateSamAI(target, currentTime);
                } else if (target.ai.type === 'infantry') {
                    updateSoldierAI(target, deltaTime, currentTime);
                } else if (target.ai.type === 'sniper') {
                    updateSniperAI(target, deltaTime, currentTime);
                } else if (target.ai.type === 'aircraft') {
                    updateAircraftAI(target, deltaTime, currentTime);
                }
            }
        }
        
        function updateTankAI(target, deltaTime, currentTime) {
            const ai = target.ai;

            // Circular patrol movement
            ai.patrolAngle += ai.speed * ai.patrolDirection * deltaTime * 0.001;
            target.x = ai.patrolCenter.x + Math.cos(ai.patrolAngle) * ai.patrolRadius;
            target.y = ai.patrolCenter.y + Math.sin(ai.patrolAngle) * ai.patrolRadius;

            // Clamp to map boundaries (no wrapping)
            const clamped = clampToBoundary(target.x, target.y);
            target.x = clamped.x;
            target.y = clamped.y;

            // Update Z position based on terrain
            const terrainHeight = getTerrainHeight(target.x, target.y);
            target.z = terrainHeight + TARGET_TYPES.TANK.heightOffset;
            ai.heading = normalizeAngle(ai.patrolAngle + (ai.patrolDirection >= 0 ? Math.PI / 2 : -Math.PI / 2));

            const canEngage = gameMode === GAME_MODES.DELTA;
            if (!canEngage) {
                ai.state = 'patrol';
                return;
            }

            const targetInfo = getAITarget(target);
            if (!targetInfo) {
                ai.state = 'patrol';
                return;
            }

            let dx = targetInfo.x - target.x;
            let dy = targetInfo.y - target.y;
            if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
            if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
            if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
            if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

            const dist = Math.sqrt(dx * dx + dy * dy);
            const tankOrigin = { x: target.x, y: target.y, height: target.z };
            const targetPos = targetInfo.isPlayer ? { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z } : (targetInfo.target || { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z });
            const hasLineOfSight = !isTargetOccluded(targetPos, tankOrigin, dx, dy, dist);

            if (dist <= ai.detectRange && hasLineOfSight) {
                ai.state = 'engage';
            } else if (ai.state === 'engage' && (!hasLineOfSight || dist > ai.detectRange * 1.2)) {
                ai.state = 'patrol';
            }

            if (ai.state === 'engage' && dist <= ai.engageRange && currentTime - ai.lastFired > ai.fireRate) {
                const aimAngle = Math.atan2(dx, dy);
                const dz = targetInfo.z - (target.z + 6);
                let pitch = dist > 0 ? dz / dist : 0;
                pitch += (Math.random() - 0.5) * 0.02;

                enemyProjectiles.push({
                    x: target.x,
                    y: target.y,
                    z: target.z + 6,
                    angle: aimAngle,
                    pitch: pitch,
                    speed: ai.bulletSpeed,
                    damage: ai.bulletDamage,
                    type: 'tank_shell',
                    lifetime: 200,
                    faction: target.faction
                });

                // Muzzle flash for tank firing
                spawnParticles(target.x, target.y, target.z + 8, 'muzzle_flash', 1);

                ai.lastFired = currentTime;
            }
        }
        
        function updateSamAI(target, currentTime) {
            if (gameMode !== GAME_MODES.COMANCHE) return;
            const targetInfo = getAITarget(target);
            if (!targetInfo) return;
            // Calculate distance to target with map wrapping
            let dx = targetInfo.x - target.x;
            let dy = targetInfo.y - target.y;
            if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
            if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
            if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
            if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
            
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Check line-of-sight before firing - SAM needs to see the player
            const playerTarget = targetInfo.isPlayer ? { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z } : (targetInfo.target || { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z });
            const samCam = { x: target.x, y: target.y, height: target.z + 10 };
            const hasLineOfSight = !isTargetOccluded(playerTarget, samCam, dx, dy, dist);
            
            // In range, has LOS, and can fire
            if (dist < target.ai.range && hasLineOfSight && currentTime - target.ai.lastFired > target.ai.fireRate) {
                // Launch missile VERTICALLY first, then track after reaching altitude
                enemyProjectiles.push({
                    x: target.x,
                    y: target.y,
                    z: target.z + 10,
                    vx: 0,  // No horizontal velocity initially
                    vy: 0,
                    vz: target.ai.missileSpeed * 3,  // FASTER vertical launch (was 1.5)
                    targetX: targetInfo.x,
                    targetY: targetInfo.y,
                    targetZ: targetInfo.z,
                    speed: target.ai.missileSpeed,
                    damage: target.ai.missileDamage,
                    type: 'sam_missile',
                    lifetime: 800,  // LONGER lifetime (was 400)
                    phase: 'launch',  // 'launch' then 'track'
                    launchAltitude: target.z + 60,  // Lower altitude to start tracking sooner (was 80)
                    angle: 0,  // Will be set when tracking begins
                    faction: target.faction,
                    targetId: targetInfo.isPlayer ? 'player' : targetInfo.target?.id
                });
                
                // Muzzle flash for SAM launch
                spawnParticles(target.x, target.y, target.z + 12, 'muzzle_flash', 1);
                
                target.ai.lastFired = currentTime;
                
                // Warning sound/indicator
                if (targetInfo.isPlayer) {
                    showMissileWarning();
                }
            }
        }

        function updateSoldierAI(target, deltaTime, currentTime) {
            const ai = target.ai;
            const targetInfo = getAITarget(target);
            let dx = 0;
            let dy = 0;
            let dist = Infinity;
            let hasLineOfSight = false;
            if (targetInfo) {
                dx = targetInfo.x - target.x;
                dy = targetInfo.y - target.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

                dist = Math.sqrt(dx * dx + dy * dy);
                const soldierCam = { x: target.x, y: target.y, height: target.z };
                const playerTarget = targetInfo.isPlayer ? { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z } : (targetInfo.target || { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z });
                hasLineOfSight = !isTargetOccluded(playerTarget, soldierCam, dx, dy, dist);

                const detectRange = getAlertedDetectRange(ai.detectRange);
                if (dist <= detectRange && hasLineOfSight) {
                    if (targetInfo.isPlayer) raiseAlert();
                    ai.state = 'engage';
                } else if (ai.state === 'engage' && (!hasLineOfSight || dist > detectRange * 1.15)) {
                    ai.state = 'patrol';
                }
            } else {
                ai.state = 'patrol';
            }

            if (ai.state === 'patrol') {
                ai.patrolAngle += ai.patrolSpeed * deltaTime * 0.001;
                target.x = ai.patrolCenter.x + Math.cos(ai.patrolAngle) * ai.patrolRadius;
                target.y = ai.patrolCenter.y + Math.sin(ai.patrolAngle) * ai.patrolRadius;
                ai.facingAngle = ai.patrolAngle + Math.PI * 0.5;
                ai.pose = 'stand';
            } else {
                ai.facingAngle = Math.atan2(dx, dy);

                if (dist > ai.engageRange) {
                    const advanceSpeed = ai.patrolSpeed * 0.9;
                    target.x += Math.sin(ai.facingAngle) * advanceSpeed * deltaTime * 0.06;
                    target.y += Math.cos(ai.facingAngle) * advanceSpeed * deltaTime * 0.06;
                }

                if (targetInfo && dist <= ai.engageRange && currentTime - ai.lastFired > ai.fireRate) {
                    const spread = (Math.random() - 0.5) * ai.accuracy;
                    const aimAngle = ai.facingAngle + spread;
                    const dz = targetInfo.z - target.z;
                    let pitch = dist > 0 ? dz / dist : 0;
                    pitch += (Math.random() - 0.5) * ai.accuracy * 0.4;

                    enemyProjectiles.push({
                        x: target.x,
                        y: target.y,
                        z: target.z + 4,
                        angle: aimAngle,
                        pitch: pitch,
                        speed: ai.bulletSpeed,
                        damage: ai.bulletDamage,
                        type: 'infantry_bullet',
                        lifetime: 140,
                        faction: target.faction
                    });

                    // Muzzle flash for soldier firing
                    spawnParticles(target.x, target.y, target.z + 5, 'muzzle_flash', 1);

                    ai.lastFired = currentTime;
                    ai.pose = 'shoot';
                } else {
                    ai.pose = 'stand';
                }
            }

            // Clamp to map boundaries (no wrapping)
            const soldierClamped = clampToBoundary(target.x, target.y);
            target.x = soldierClamped.x;
            target.y = soldierClamped.y;

            const terrainHeight = getTerrainHeight(target.x, target.y);
            target.z = terrainHeight + TARGET_TYPES.SOLDIER.heightOffset;
        }
        
        function updateSniperAI(target, deltaTime, currentTime) {
            const ai = target.ai;
            const targetInfo = getAITarget(target);
            let dx = 0;
            let dy = 0;
            let dist = Infinity;
            let hasLineOfSight = false;
            if (targetInfo) {
                dx = targetInfo.x - target.x;
                dy = targetInfo.y - target.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

                dist = Math.sqrt(dx * dx + dy * dy);
                const sniperCam = { x: target.x, y: target.y, height: target.z };
                const playerTarget = targetInfo.isPlayer ? { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z } : (targetInfo.target || { x: targetInfo.x, y: targetInfo.y, z: targetInfo.z });
                hasLineOfSight = !isTargetOccluded(playerTarget, sniperCam, dx, dy, dist);

                // Snipers have longer detection range but stay in place
                const detectRange = getAlertedDetectRange(ai.detectRange);
                if (dist <= detectRange && hasLineOfSight) {
                    if (targetInfo.isPlayer) raiseAlert();
                    ai.state = 'engage';
                } else if (ai.state === 'engage' && (!hasLineOfSight || dist > detectRange * 1.1)) {
                    ai.state = 'overwatch';  // Snipers go to overwatch instead of patrol
                }
            } else {
                ai.state = 'overwatch';
            }

            if (ai.state === 'patrol' || ai.state === 'overwatch') {
                // Snipers barely move - they hold position
                ai.patrolAngle += ai.patrolSpeed * deltaTime * 0.0005;  // Very slow rotation
                target.x = ai.patrolCenter.x + Math.cos(ai.patrolAngle) * ai.patrolRadius * 0.5;
                target.y = ai.patrolCenter.y + Math.sin(ai.patrolAngle) * ai.patrolRadius * 0.5;
                ai.facingAngle = ai.patrolAngle;
                ai.pose = 'crouch';  // Snipers stay crouched when not shooting
            } else if (ai.state === 'engage') {
                ai.facingAngle = Math.atan2(dx, dy);
                
                // Snipers DON'T advance - they stay at range
                // Only fire when in optimal range (not too close)
                const optimalRange = ai.engageRange * 0.8;  // Prefer longer range shots
                
                if (targetInfo && dist <= ai.engageRange && currentTime - ai.lastFired > ai.fireRate) {
                    // Very accurate shot with small spread
                    const spread = (Math.random() - 0.5) * ai.accuracy;
                    const aimAngle = ai.facingAngle + spread;
                    const dz = targetInfo.z - target.z;
                    let pitch = dist > 0 ? dz / dist : 0;
                    pitch += (Math.random() - 0.5) * ai.accuracy * 0.2;  // Less vertical spread

                    enemyProjectiles.push({
                        x: target.x,
                        y: target.y,
                        z: target.z + 3,  // Lower firing position (prone/crouch)
                        angle: aimAngle,
                        pitch: pitch,
                        speed: ai.bulletSpeed,
                        damage: ai.bulletDamage,
                        type: 'sniper_bullet',  // Different bullet type
                        lifetime: 200,  // Longer range
                        tracerColor: '#ff4400',  // Red tracer for sniper rounds
                        faction: target.faction
                    });

                    // Smaller muzzle flash (suppressed)
                    spawnParticles(target.x, target.y, target.z + 3, 'muzzle_flash', 1);

                    ai.lastFired = currentTime;
                    ai.pose = 'shoot';
                } else {
                    ai.pose = 'crouch';
                }
            }

            // Clamp to map boundaries (no wrapping)
            const sniperClamped = clampToBoundary(target.x, target.y);
            target.x = sniperClamped.x;
            target.y = sniperClamped.y;

            const terrainHeight = getTerrainHeight(target.x, target.y);
            target.z = terrainHeight + TARGET_TYPES.SNIPER.heightOffset;
        }

        function updateAircraftAI(entity, deltaTime, currentTime) {
            if (!entity.ai || entity.ai.type !== 'aircraft') return;

            const ai = entity.ai;
            const dt = deltaTime * 0.001;
            const targetInfo = getAITarget(entity);
            const hasTarget = !!targetInfo;
            const targetX = targetInfo?.x ?? entity.x;
            const targetY = targetInfo?.y ?? entity.y;
            const targetZ = targetInfo?.z ?? entity.z;
            let targetDx = targetX - entity.x;
            let targetDy = targetY - entity.y;
            if (targetDx > CONFIG.MAP_SIZE / 2) targetDx -= CONFIG.MAP_SIZE;
            if (targetDx < -CONFIG.MAP_SIZE / 2) targetDx += CONFIG.MAP_SIZE;
            if (targetDy > CONFIG.MAP_SIZE / 2) targetDy -= CONFIG.MAP_SIZE;
            if (targetDy < -CONFIG.MAP_SIZE / 2) targetDy += CONFIG.MAP_SIZE;
            const targetDist = hasTarget ? Math.sqrt(targetDx * targetDx + targetDy * targetDy) : Infinity;

            // Initialize state if needed
            if (!ai.state) {
                ai.state = 'patrol';
                ai.patrolCenter = { x: entity.x, y: entity.y };
                ai.patrolAngle = Math.random() * Math.PI * 2;
                ai.heading = ai.patrolAngle;
                ai.lastFireTime = 0;
                ai.lastAttackTime = ai.lastAttackTime || 0;
                ai.targetId = null;
                // Burst fire state for attack helicopters
                ai.burstShotsFired = 0;
                ai.burstCooldownStart = 0;
                ai.inBurstCooldown = false;
            }

            const isPlayerInAir = gameMode === GAME_MODES.COMANCHE;

            // State machine
            switch (ai.state) {
                case 'patrol': {
                    // Circle around patrol center
                    ai.patrolAngle += ai.turnRate * 0.5 * dt * 60;
                    const patrolRadius = 150;
                    const targetX = ai.patrolCenter.x + Math.cos(ai.patrolAngle) * patrolRadius;
                    const targetY = ai.patrolCenter.y + Math.sin(ai.patrolAngle) * patrolRadius;

                    airSteerToward(entity, targetX, targetY, ai.turnRate, dt);
                    airHoldAltitude(entity, ai.preferredAlt, ai.climbRate, dt);

                    // Check for player detection
                    if (hasTarget && ((targetInfo?.isPlayer && isPlayerInAir) || !targetInfo?.isPlayer) && targetDist < ai.detectRange && ai.engageRange > 0) {
                        ai.state = 'intercept';
                        ai.targetId = targetInfo?.isPlayer ? 'player' : targetInfo?.target?.id || null;
                    }
                    break;
                }
                case 'intercept': {
                    if (!hasTarget) {
                        ai.state = 'patrol';
                        break;
                    }
                    // Close distance to target
                    airSteerToward(entity, targetX, targetY, ai.turnRate, dt);

                    // Gain altitude advantage
                    const targetAlt = Math.max(ai.preferredAlt, targetZ + 20);
                    airHoldAltitude(entity, targetAlt, ai.climbRate, dt);

                    // Switch to attack when in range
                    if (targetDist < ai.engageRange) {
                        ai.state = 'attack_run';
                    } else if (targetDist > ai.detectRange * 1.5) {
                        ai.state = 'patrol';
                    }
                    break;
                }
                case 'attack_run': {
                    if (!hasTarget) {
                        ai.state = 'patrol';
                        break;
                    }
                    // Align and fire
                    airSteerToward(entity, targetX, targetY, ai.turnRate * 1.2, dt);

                    // Descend toward target altitude
                    airHoldAltitude(entity, targetZ + 10, ai.climbRate * 0.5, dt);

                    // Fire weapons
                    if (ai.weaponType) {
                        if (ai.role === 'fighter') {
                            const cooldown = ai.attackCooldown || 8000;
                            if (currentTime - ai.lastAttackTime >= cooldown) {
                                fireAircraftWeapon(entity, targetX, targetY, targetZ);
                                ai.lastAttackTime = currentTime;
                                ai.lastFireTime = currentTime;
                                ai.state = 'extend';
                                ai.extendTime = currentTime;
                            }
                        } else if (ai.role === 'attack_heli' && ai.burstCount && ai.burstCooldown) {
                            // Attack helicopter burst fire logic
                            if (ai.inBurstCooldown) {
                                // Check if cooldown is over
                                if (currentTime - ai.burstCooldownStart >= ai.burstCooldown) {
                                    ai.inBurstCooldown = false;
                                    ai.burstShotsFired = 0;
                                }
                            } else if (currentTime - ai.lastFireTime > ai.fireRate) {
                                // Fire a shot in the burst
                                fireAircraftWeapon(entity, targetX, targetY, targetZ);
                                ai.lastFireTime = currentTime;
                                ai.burstShotsFired = (ai.burstShotsFired || 0) + 1;
                                
                                // Check if burst is complete
                                if (ai.burstShotsFired >= ai.burstCount) {
                                    ai.inBurstCooldown = true;
                                    ai.burstCooldownStart = currentTime;
                                }
                            }
                        } else if (currentTime - ai.lastFireTime > ai.fireRate) {
                            fireAircraftWeapon(entity, targetX, targetY, targetZ);
                            ai.lastFireTime = currentTime;
                        }
                    }

                    // After attack run, extend and re-engage
                    if (ai.role !== 'fighter') {
                        if (targetDist < 50) {
                            ai.state = 'extend';
                            ai.extendTime = currentTime;
                        } else if (targetDist > ai.engageRange * 1.5) {
                            ai.state = 'intercept';
                        }
                    } else if (ai.state === 'attack_run' && targetDist > ai.engageRange * 1.5) {
                        ai.state = 'intercept';
                    }

                    // Take damage -> evade
                    if (entity.health < entity.maxHealth * 0.5) {
                        ai.state = 'evade';
                        ai.evadeTime = currentTime;
                    }
                    break;
                }
                case 'extend': {
                    if (!hasTarget) {
                        ai.state = 'patrol';
                        break;
                    }
                    // Fly away briefly before re-engaging
                    const awayAngle = Math.atan2(entity.y - targetY, entity.x - targetX);
                    const extendX = entity.x + Math.cos(awayAngle) * 100;
                    const extendY = entity.y + Math.sin(awayAngle) * 100;
                    airSteerToward(entity, extendX, extendY, ai.turnRate, dt);
                    airHoldAltitude(entity, ai.preferredAlt + 30, ai.climbRate, dt);

                    const extendDuration = ai.role === 'fighter' ? (ai.attackCooldown || 8000) : 3000;
                    if (currentTime - ai.extendTime > extendDuration) {
                        ai.state = 'intercept';
                    }
                    break;
                }
                case 'evade': {
                    if (!hasTarget) {
                        ai.state = 'patrol';
                        break;
                    }
                    // Defensive maneuvers
                    const evadeAngle = Math.atan2(entity.y - targetY, entity.x - targetX) + (Math.random() - 0.5) * Math.PI;
                    const evadeX = entity.x + Math.cos(evadeAngle) * 150;
                    const evadeY = entity.y + Math.sin(evadeAngle) * 150;
                    airSteerToward(entity, evadeX, evadeY, ai.turnRate * 1.5, dt);
                    airHoldAltitude(entity, ai.preferredAlt + 50, ai.climbRate * 1.5, dt);

                    if (currentTime - ai.evadeTime > 5000) {
                        ai.state = entity.health > entity.maxHealth * 0.3 ? 'intercept' : 'patrol';
                    }
                    break;
                }
            }

            // Move aircraft forward
            entity.x += Math.cos(ai.heading) * ai.speed * dt * 60;
            entity.y += Math.sin(ai.heading) * ai.speed * dt * 60;

            // Map boundary enforcement for AI aircraft (auto-turn at edges)
            const boundaryResult = enforceMapBoundary(entity.x, entity.y, ai.heading, dt);
            entity.x = boundaryResult.x;
            entity.y = boundaryResult.y;
            ai.heading = boundaryResult.angle;
        }

        function airSteerToward(entity, targetX, targetY, maxTurnRate, dt) {
            const ai = entity.ai;
            const dx = targetX - entity.x;
            const dy = targetY - entity.y;
            const targetHeading = Math.atan2(dy, dx);

            let diff = normalizeAngle(targetHeading - ai.heading);
            const turn = Math.sign(diff) * Math.min(Math.abs(diff), maxTurnRate * dt * 60);
            ai.heading = normalizeAngle(ai.heading + turn);
        }

        function airHoldAltitude(entity, targetAlt, climbRate, dt) {
            const diff = targetAlt - entity.z;
            const climb = Math.sign(diff) * Math.min(Math.abs(diff), climbRate * dt * 60);
            entity.z += climb;

            // Minimum altitude
            const terrainHeight = getTerrainHeight(entity.x, entity.y);
            entity.z = Math.max(entity.z, terrainHeight + 20);
        }

        function fireAircraftWeapon(entity, targetX, targetY, targetZ) {
            const ai = entity.ai;
            if (!ai.weaponType) return;

            const dx = targetX - entity.x;
            const dy = targetY - entity.y;
            const dz = targetZ - entity.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

            if (dist <= 0) return;

            // Normalize direction
            const dirX = dx / dist;
            const dirY = dy / dist;
            const dirZ = dz / dist;

            // Add some spread
            const spread = ai.weaponType === 'air_cannon' ? 0.05 : ai.weaponType === 'air_missile' ? 0.01 : 0.02;
            const spreadX = (Math.random() - 0.5) * spread;
            const spreadY = (Math.random() - 0.5) * spread;

            const projectile = {
                type: ai.weaponType,
                x: entity.x,
                y: entity.y,
                z: entity.z,
                vx: (dirX + spreadX) * ai.bulletSpeed,
                vy: (dirY + spreadY) * ai.bulletSpeed,
                vz: dirZ * ai.bulletSpeed,
                damage: ai.bulletDamage,
                sourceId: entity.id,
                life: 3000,  // 3 seconds
                spawnTime: performance.now(),
                faction: entity.faction
            };

            enemyProjectiles.push(projectile);
            
            // Muzzle flash for aircraft firing
            spawnParticles(entity.x, entity.y, entity.z, 'muzzle_flash', 1);
        }
        
        // ============================================
        // ENEMY PROJECTILES
        // ============================================
        function getProjectileTargetPosition(projectile) {
            if (projectile.targetId === 'player') {
                return { x: camera.x, y: camera.y, z: camera.height };
            }

            if (projectile.targetId) {
                const target = targets.find((candidate) => candidate.id === projectile.targetId && !candidate.destroyed);
                if (target) {
                    return { x: target.x, y: target.y, z: target.z };
                }
            }

            if (typeof projectile.targetX === 'number' && typeof projectile.targetY === 'number' && typeof projectile.targetZ === 'number') {
                return { x: projectile.targetX, y: projectile.targetY, z: projectile.targetZ };
            }

            return null;
        }

        function getHostileFaction(faction) {
            if (faction === FACTIONS.ENEMY) return FACTIONS.FRIENDLY;
            if (faction === FACTIONS.FRIENDLY) return FACTIONS.ENEMY;
            return null;
        }

        function applyAIDamageToTarget(target, damage, projectileType, impactX, impactY, impactZ) {
            target.health -= damage;

            if (target.health <= 0) {
                target.destroyed = true;

                updateObjectiveProgress('target_destroyed', {
                    type: target.type.toUpperCase(),
                    id: target.id
                });

                if (target.type === 'soldier') {
                    spawnParticles(target.x, target.y, target.z, 'blood', 8 + Math.floor(Math.random() * 5));
                    spawnParticles(target.x, target.y, target.z, 'dust', 4 + Math.floor(Math.random() * 3));
                } else {
                    const explosionSize = target.type === 'building' ? 'large' : 'medium';
                    createExplosion(target.x, target.y, target.z, explosionSize);
                    spawnParticles(target.x, target.y, target.z, 'spark', 10 + Math.floor(Math.random() * 6));
                    spawnParticles(target.x, target.y, target.z, 'smoke', 5 + Math.floor(Math.random() * 4));
                    spawnParticles(target.x, target.y, target.z, 'debris', 5 + Math.floor(Math.random() * 4));
                }
            } else {
                if (target.type === 'soldier') {
                    spawnParticles(impactX, impactY, impactZ, 'blood', 3 + Math.floor(Math.random() * 3));
                } else {
                    const explosionSize = (projectileType === 'sam_missile' || projectileType === 'tank_shell' || projectileType === 'air_missile' || projectileType === 'air_rocket')
                        ? 'medium'
                        : 'small';
                    createExplosion(impactX, impactY, impactZ, explosionSize);
                }
            }
        }

        function checkAIProjectileTargetHit(projectile) {
            const projectileFaction = projectile.faction || FACTIONS.ENEMY;
            const hostileFaction = getHostileFaction(projectileFaction);
            if (!hostileFaction) return false;

            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.faction !== hostileFaction) continue;

                let dx = projectile.x - target.x;
                let dy = projectile.y - target.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

                const dist2D = Math.sqrt(dx * dx + dy * dy);
                const targetHeight = target.size * 0.75;
                const targetBottom = target.z - 5;
                const targetTop = target.z + targetHeight;
                const zInRange = projectile.z >= targetBottom && projectile.z <= targetTop;

                const isBuilding = target.type && (target.type === 'building' || target.type === 'hangar' ||
                    target.type === 'control_tower' || target.type === 'fuel_depot' ||
                    target.type === 'barracks' || target.type === 'radar');
                const hitboxSize = isBuilding ? target.size * 0.5 : target.size;

                if (dist2D < hitboxSize && zInRange) {
                    applyAIDamageToTarget(target, projectile.damage, projectile.type, projectile.x, projectile.y, projectile.z);
                    return true;
                }
            }

            return false;
        }
        function updateEnemyProjectiles(deltaTime) {
            const dt = Math.max(0, Math.min(3, deltaTime / 16.666));
            if (dt <= 0) return;
            const now = performance.now();
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                const projectileFaction = ep.faction || FACTIONS.ENEMY;
                
                if (ep.type === 'air_cannon' || ep.type === 'air_rocket' || ep.type === 'air_missile') {
                    ep.x += ep.vx * dt;
                    ep.y += ep.vy * dt;
                    ep.z += ep.vz * dt;
                } else if (ep.type === 'infantry_bullet' || ep.type === 'tank_shell' || ep.type === 'sniper_bullet') {
                    ep.x += Math.sin(ep.angle) * ep.speed * dt;
                    ep.y += Math.cos(ep.angle) * ep.speed * dt;
                    ep.z += ep.pitch * ep.speed * dt;
                } else if (ep.type === 'sam_missile') {
                    // SAM missile has two phases: launch (vertical) and track (homing)
                    if (ep.phase === 'launch') {
                        // Vertical launch phase - go straight up
                        ep.z += ep.vz * 0.06 * dt;
                        
                        // Switch to tracking when altitude reached
                        if (ep.z >= ep.launchAltitude) {
                            ep.phase = 'track';
                            // Initialize tracking angle toward player
                            const targetPos = getProjectileTargetPosition(ep);
                            let dx = (targetPos?.x ?? ep.x) - ep.x;
                            let dy = (targetPos?.y ?? ep.y) - ep.y;
                            if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                            if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                            if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                            if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                            ep.angle = Math.atan2(dx, dy);
                        }
                    } else {
                        // Tracking phase - home in on target
                        const targetPos = getProjectileTargetPosition(ep);
                        let dx = (targetPos?.x ?? ep.x) - ep.x;
                        let dy = (targetPos?.y ?? ep.y) - ep.y;
                        if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                        if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                        if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                        if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                        
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 0) {
                            // Homing behavior with turn rate limit
                            const targetAngle = Math.atan2(dx, dy);
                            const currentAngle = ep.angle || targetAngle;
                            const turnRate = 0.06 * dt;
                            const angleDiff = normalizeAngle(targetAngle - currentAngle);
                            ep.angle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);
                            
                            // Move toward player
                            ep.x += Math.sin(ep.angle) * ep.speed * dt;
                            ep.y += Math.cos(ep.angle) * ep.speed * dt;
                            
                            // Gradually adjust altitude toward player
                            const dz = (targetPos?.z ?? ep.z) - ep.z;
                            ep.z += dz * 0.03 * dt;
                        }
                    }
                } else {
                    // Generic homing projectile (fallback)
                    const targetPos = getProjectileTargetPosition(ep);
                    let dx = (targetPos?.x ?? ep.x) - ep.x;
                    let dy = (targetPos?.y ?? ep.y) - ep.y;
                    if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                    if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                    if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                    if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                    
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        const targetAngle = Math.atan2(dx, dy);
                        const currentAngle = ep.angle || targetAngle;
                        const turnRate = 0.06 * dt;
                        const angleDiff = normalizeAngle(targetAngle - currentAngle);
                        ep.angle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate);
                        
                        ep.x += Math.sin(ep.angle) * ep.speed * dt;
                        ep.y += Math.cos(ep.angle) * ep.speed * dt;
                        
                        const dz = (targetPos?.z ?? ep.z) - ep.z;
                        ep.z += dz * 0.03 * dt;
                    }
                }
                
                if (typeof ep.life === 'number') {
                    if (now - ep.spawnTime > ep.life) {
                        if (ep.type === 'sam_missile') {
                            telemetry.missilesDodged += 1;
                        }
                        enemyProjectiles.splice(i, 1);
                        continue;
                    }
                } else {
                    ep.lifetime -= dt;
                }
                
                // Despawn projectiles that leave map boundaries (no wrapping)
                if (isOutsideBoundary(ep.x, ep.y)) {
                    if (ep.type === 'sam_missile') {
                        telemetry.missilesDodged += 1;
                    }
                    enemyProjectiles.splice(i, 1);
                    continue;
                }
                
                // Check hit targets (AI vs AI)
                if (checkAIProjectileTargetHit(ep)) {
                    enemyProjectiles.splice(i, 1);
                    continue;
                }

                // Check hit player (enemy-only)
                if (projectileFaction === FACTIONS.ENEMY) {
                    if (ep.type === 'air_cannon' || ep.type === 'air_rocket' || ep.type === 'air_missile') {
                        if (gameMode === GAME_MODES.COMANCHE) {
                            const dx = ep.x - camera.x;
                            const dy = ep.y - camera.y;
                            const dz = ep.z - camera.height;
                            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                            const hitRadius = ep.type === 'air_missile' ? 22 : 15;
                            if (dist < hitRadius) {
                                damagePlayer(ep.damage);
                                enemyProjectiles.splice(i, 1);
                                continue;
                            }
                        }
                    } else {
                        const playerDist = distance3D(ep.x, ep.y, ep.z, camera.x, camera.y, camera.height);
                        const hitRadius = ep.type === 'infantry_bullet' ? 12 : ep.type === 'tank_shell' ? 22 : 30;
                        if (playerDist < hitRadius) {
                            damagePlayer(ep.damage);
                            enemyProjectiles.splice(i, 1);
                            createExplosion(ep.x, ep.y, ep.z, ep.type === 'infantry_bullet' ? 'small' : 'medium');
                            continue;
                        }
                    }
                }
                
                // Check terrain collision
                const terrainHeight = getTerrainHeight(ep.x, ep.y);
                if (ep.z <= terrainHeight) {
                    const explosionSize = (ep.type === 'sam_missile' || ep.type === 'tank_shell' || ep.type === 'air_missile' || ep.type === 'air_rocket')
                        ? 'medium'
                        : 'small';
                    createExplosion(ep.x, ep.y, terrainHeight, explosionSize);
                    if (ep.type === 'sam_missile') {
                        telemetry.missilesDodged += 1;
                    }
                    enemyProjectiles.splice(i, 1);
                    continue;
                }
                
                // Remove if expired
                if (typeof ep.life !== 'number' && ep.lifetime <= 0) {
                    if (ep.type === 'sam_missile') {
                        telemetry.missilesDodged += 1;
                    }
                    enemyProjectiles.splice(i, 1);
                }
            }
        }
        
        function distance3D(x1, y1, z1, x2, y2, z2) {
            // Simple distance calculation (no map wrapping)
            const dx = x1 - x2;
            const dy = y1 - y2;
            const dz = z1 - z2;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        
        // ============================================
        // PLAYER DAMAGE SYSTEM
        // ============================================
        function damagePlayer(amount) {
            if (isPlayerDead || gameState !== GAME_STATES.PLAYING) return;
            if (godMode) return;  // Skip damage in god mode
            
            playerHealth -= amount;
            telemetry.damageTaken += amount;
            missionNoDamage = false;
            screenFlash('red', 200);  // Red flash when hit
            playDamageSound();  // Play damage sound
            damageVignetteTime = 320;
            damageVignetteIntensity = Math.min(0.9, 0.4 + amount / 60);
            addScreenShake(Math.min(10, 4 + amount * 0.12), 280);
            
            if (playerHealth <= 0) {
                playerHealth = 0;
                if (gameMode === GAME_MODES.COMANCHE) {
                    stopRotorSound();  // Stop rotor when destroyed
                    endMission(false, 'HELICOPTER DESTROYED');
                } else {
                    endMission(false, 'OPERATOR DOWN');
                }
            }
        }
        
        function screenFlash(color, duration) {
            screenFlashColor = color;
            screenFlashTime = duration;
        }

        function updateScreenFlash(deltaTime) {
            if (screenFlashTime > 0) {
                screenFlashTime -= deltaTime;
                if (screenFlashTime < 0) screenFlashTime = 0;
            }
        }

        function addScreenShake(intensity, duration = 150) {
            screenShake.intensity = Math.min(screenShake.intensity + intensity, 5.0);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }

        function updateScreenShake(deltaTime) {
            if (screenShake.duration > 0 && screenShake.intensity > 0.05) {
                screenShake.duration -= deltaTime;
                screenShake.intensity *= screenShake.decay;
                const angle = Math.random() * Math.PI * 2;
                const magnitude = screenShake.intensity;
                screenShake.x = Math.cos(angle) * magnitude;
                screenShake.y = Math.sin(angle) * magnitude;
            } else {
                screenShake.duration = 0;
                screenShake.intensity = 0;
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        function triggerMuzzleFlash(intensity = 1) {
            muzzleFlashTime = 80;
            muzzleFlashIntensity = Math.max(muzzleFlashIntensity, intensity);
        }

        function triggerHitMarker(intensity = 1) {
            hitMarkerTime = 140;
            hitMarkerIntensity = Math.max(hitMarkerIntensity, intensity);
        }

        function updateCombatFeedback(deltaTime) {
            if (muzzleFlashTime > 0) {
                muzzleFlashTime -= deltaTime;
                if (muzzleFlashTime <= 0) {
                    muzzleFlashTime = 0;
                    muzzleFlashIntensity = 0;
                }
            }
            if (hitMarkerTime > 0) {
                hitMarkerTime -= deltaTime;
                if (hitMarkerTime <= 0) {
                    hitMarkerTime = 0;
                    hitMarkerIntensity = 0;
                }
            }
            if (damageVignetteTime > 0) {
                damageVignetteTime -= deltaTime;
                if (damageVignetteTime <= 0) {
                    damageVignetteTime = 0;
                    damageVignetteIntensity = 0;
                }
            }
        }
        
        // ============================================
        // MISSILE WARNING SYSTEM
        // ============================================
        function showMissileWarning() {
            missileWarning = true;
            missileWarningTime = 3000; // 3 seconds of warning
            startWarningAlarm();  // Start audio warning
        }
        
        function updateMissileWarning(deltaTime) {
            if (missileWarning) {
                missileWarningTime -= deltaTime;
                if (missileWarningTime <= 0 || enemyProjectiles.length === 0) {
                    missileWarning = false;
                    stopWarningAlarm();  // Stop audio warning
                }
            }
        }
        
        // ============================================
        // COUNTERMEASURES
        // ============================================
        function deployCountermeasure(type) {
            const now = performance.now();
            const cm = countermeasures[type];
            
            if (cm.count <= 0) return;
            if (now - cm.lastUsed < cm.cooldown) return;
            
            cm.count--;
            cm.lastUsed = now;
            
            // Play countermeasure deploy sound
            playCountermeasureSound();
            
            // Create visual effect
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 3;
                explosions.push({
                    x: camera.x + Math.sin(angle) * 10,
                    y: camera.y + Math.cos(angle) * 10,
                    z: camera.height - 10,
                    size: 8,
                    maxSize: 8,
                    lifetime: 20,
                    maxLifetime: 20,
                    isCountermeasure: true,
                    cmType: type
                });
            }
            
            // Decoy nearby enemy missiles
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
                const ep = enemyProjectiles[i];
                if (type === 'flare' && ep.type === 'sam_missile') {
                    // 70% chance to decoy
                    if (Math.random() < 0.7) {
                        createExplosion(ep.x, ep.y, ep.z, 'small');
                        telemetry.missilesDodged += 1;
                        enemyProjectiles.splice(i, 1);
                    }
                } else if (type === 'chaff') {
                    // Chaff confuses missile guidance - 50% chance
                    if (Math.random() < 0.5) {
                        createExplosion(ep.x, ep.y, ep.z, 'small');
                        if (ep.type === 'sam_missile') {
                            telemetry.missilesDodged += 1;
                        }
                        enemyProjectiles.splice(i, 1);
                    }
                }
            }
        }
        
        function checkWinCondition() {
            if (gameState !== GAME_STATES.PLAYING) return;
            if (missionComplete || isPlayerDead) return;
            
            const remaining = targets.filter(t => !t.destroyed).length;
            if (remaining === 0 && targets.length > 0) {
                // In free play mode (currentMissionIndex === -1), respawn targets
                if (currentMissionIndex === -1) {
                    // Clear destroyed targets and spawn new ones
                    targets = [];
                    for (let i = 0; i < 4; i++) spawnTarget('TANK');
                    for (let i = 0; i < 2; i++) spawnTarget('BUILDING');
                    for (let i = 0; i < 2; i++) spawnTarget('SAM_SITE');
                } else {
                    endMission(true);
                }
            }
        }
        
        // ============================================
        // COMBAT INPUT HANDLING
        // ============================================
        function updateSoldierWeaponState(deltaTime) {
            if (gameMode !== GAME_MODES.DELTA) return;
            const now = performance.now();

            if (soldierWeapon.isReloading) {
                if (now - soldierWeapon.reloadStartTime >= soldierWeapon.reloadDuration) {
                    const weaponKey = soldierWeapon.current;
                    const weapon = WEAPONS_DELTA[weaponKey];
                    const state = soldierWeapon.weapons[weaponKey];
                    if (weapon && state && state.mags > 0) {
                        state.mags--;
                        state.mag = weapon.magSize;
                    }
                    soldierWeapon.isReloading = false;
                }
            }

            if (soldierWeapon.recoilOffset > 0) {
                const recovery = Math.min(soldierWeapon.recoilOffset, soldierWeapon.recoilOffset * 0.35 + 0.3);
                camera.horizon = Math.min(screenHeight * 0.75, camera.horizon + recovery);
                soldierWeapon.recoilOffset -= recovery;
            }

            if (soldierWeapon.muzzleFlashTime > 0) {
                soldierWeapon.muzzleFlashTime -= deltaTime;
                if (soldierWeapon.muzzleFlashTime < 0) soldierWeapon.muzzleFlashTime = 0;
            }

            const scopeStep = deltaTime * 0.008;
            if (soldierScope.active) {
                soldierScope.transitionTime = Math.min(1, soldierScope.transitionTime + scopeStep);
            } else {
                soldierScope.transitionTime = Math.max(0, soldierScope.transitionTime - scopeStep);
            }
        }

        function handleDeltaCombatInput(deltaTime) {
            const now = performance.now();
            updateSoldierWeaponState(deltaTime);

            const weaponKey = soldierWeapon.current;
            const weapon = WEAPONS_DELTA[weaponKey];
            if (!weapon) {
                deltaTriggerPressed = false;
                return;
            }
            if (soldierWeapon.isReloading) {
                deltaTriggerPressed = false;
                return;
            }

            const shouldFire = weapon.auto ? deltaTriggerHeld : deltaTriggerPressed;
            if (shouldFire) {
                // C4 has special handling: place or detonate
                if (weaponKey === 'c4') {
                    handleC4Action(now);
                } else if (weaponKey === 'airstrike') {
                    handleAirstrikeAction(now);
                } else {
                    fireSoldierWeapon(weaponKey, now);
                }
            }

            deltaTriggerPressed = false;
        }

        function handleCombatInput(deltaTime) {
            if (gameState !== GAME_STATES.PLAYING) return;
            if (missionComplete || isPlayerDead) return;

            if (gameMode === GAME_MODES.DELTA) {
                handleDeltaCombatInput(deltaTime);
                return;
            }

            if (comancheTriggerHeld) {
                fireWeapon(currentWeapon);
            }
            // Z/X now cycle weapons (handled in keydown), no quick-fire
        }
        
        // ============================================
        // MENU RENDERING
        // ============================================
        function drawMenuPanel(boxX, boxY, boxWidth, boxHeight, title) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            ctx.fillStyle = 'rgba(0, 40, 0, 0.9)';
            ctx.fillRect(boxX, boxY, boxWidth, 40);
            ctx.font = 'bold 18px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText(title, boxX + boxWidth / 2, boxY + 26);
        }

        function drawMenuButton(label, rect, isSelected, isHovered) {
            const active = isSelected || isHovered;
            
            // Subtle pulse effect for selected items
            const pulse = isSelected ? Math.sin(performance.now() * 0.004) * 0.15 + 0.85 : 1;
            
            // Background with gradient effect for active state
            if (active) {
                const grad = ctx.createLinearGradient(rect.x, rect.y, rect.x, rect.y + rect.height);
                grad.addColorStop(0, 'rgba(0, 100, 0, 0.8)');
                grad.addColorStop(0.5, 'rgba(0, 70, 0, 0.7)');
                grad.addColorStop(1, 'rgba(0, 50, 0, 0.8)');
                ctx.fillStyle = grad;
            } else {
                ctx.fillStyle = 'rgba(0, 30, 0, 0.6)';
            }
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            
            // Border with glow for selected
            ctx.strokeStyle = active ? '#0f0' : '#0a0';
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            
            // Selection indicator arrows
            if (isSelected) {
                ctx.fillStyle = '#0f0';
                ctx.font = '14px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText('>', rect.x + 8, rect.y + rect.height / 2 + 5);
                ctx.textAlign = 'right';
                ctx.fillText('<', rect.x + rect.width - 8, rect.y + rect.height / 2 + 5);
            }
            
            // Label with brightness based on state
            ctx.globalAlpha = pulse;
            ctx.fillStyle = active ? '#0f0' : '#0a0';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(label, rect.x + rect.width / 2, rect.y + rect.height / 2 + 6);
            ctx.globalAlpha = 1;
        }

        function drawModeToggleButton(rect, isSelected, isHovered) {
            const active = isSelected || isHovered;
            const isDelta = gameMode === GAME_MODES.DELTA;
            const modeLabel = isDelta ? 'MODE: DELTA FORCE' : 'MODE: COMANCHE';
            const baseColor = isDelta ? '#b8935e' : '#0f0';
            const activeColor = isDelta ? '#e0c190' : '#7dff7d';

            ctx.strokeStyle = active ? '#0f0' : '#0a0';
            ctx.lineWidth = 2;
            ctx.fillStyle = active ? 'rgba(0, 80, 0, 0.7)' : 'rgba(0, 30, 0, 0.6)';
            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

            ctx.fillStyle = active ? activeColor : baseColor;
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(modeLabel, rect.x + rect.width / 2, rect.y + rect.height / 2 + 6);
        }

        function renderLeaderboard(stats) {
            if (!stats || !stats.leaderboard || !stats.totals) return;

            // Position in top-right corner
            const panelW = 300;
            const panelH = 300;
            const panelX = screenWidth - panelW - 20;  // Right side with margin
            const panelY = 10;                          // Top with small margin

            ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
            ctx.fillRect(panelX, panelY, panelW, panelH);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelW, panelH);

            ctx.font = 'bold 16px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('GLOBAL LEADERBOARD', panelX + panelW / 2, panelY + 25);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText(`Total Kills: ${stats.totals.kills} | Deaths: ${stats.totals.deaths}`, panelX + panelW / 2, panelY + 45);
            ctx.fillText(`Missions Completed: ${stats.totals.missionsCompleted}`, panelX + panelW / 2, panelY + 60);

            ctx.textAlign = 'left';
            ctx.font = '11px Courier New';
            let y = panelY + 85;

            for (let i = 0; i < Math.min(10, stats.leaderboard.length); i++) {
                const entry = stats.leaderboard[i];
                const rank = i + 1;
                ctx.fillStyle = rank <= 3 ? '#ff0' : '#0f0';
                ctx.fillText(`${rank}.`, panelX + 15, y);
                ctx.fillText(entry.name.substring(0, 12), panelX + 40, y);
                ctx.textAlign = 'right';
                ctx.fillText(entry.score.toLocaleString(), panelX + panelW - 15, y);
                ctx.textAlign = 'left';
                y += 18;
            }

            if (stats.leaderboard.length === 0) {
                ctx.fillStyle = '#0a0';
                ctx.textAlign = 'center';
                ctx.fillText('No scores yet - be the first!', panelX + panelW / 2, panelY + 100);
            }
        }

        function renderTitleOverlay() {
            ctx.save();
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const scanY = (performance.now() * 0.05) % screenHeight;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.08)';
            ctx.fillRect(0, scanY, screenWidth, 2);

            ctx.font = 'bold 56px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#0f0';
            ctx.shadowBlur = 25;
            ctx.fillText('VOXELCOPTER', centerX, centerY - 80);
            ctx.shadowBlur = 0;

            ctx.font = '18px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('COMANCHE-STYLE COMBAT SIMULATION', centerX, centerY - 45);

            const blinkOn = Math.floor(performance.now() / 500) % 2 === 0;
            if (blinkOn) {
                ctx.font = 'bold 16px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText('PRESS ANY KEY TO START', centerX, centerY + 40);
            }

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('© VoxelCopter Command — Tactical Interface Online', centerX, centerY + 70);
            ctx.restore();
        }

        function renderMainMenuOverlay() {
            ctx.save();
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 420;
            
            // Calculate box height based on number of menu options + space for high score/controls
            const menuSpacing = 42;
            const menuItemsHeight = MAIN_MENU_OPTIONS.length * menuSpacing;
            const boxHeight = menuItemsHeight + 140;  // 80 top padding + 60 bottom for high score/controls
            
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'MAIN MENU');

            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('VOXELCOPTER', centerX, boxY - 20);

            let y = boxY + 70;
            for (let i = 0; i < MAIN_MENU_OPTIONS.length; i++) {
                const rect = { x: boxX + 60, y: y - 16, width: boxWidth - 120, height: 34 };
                const hovered = hitTest(rect, mouseX, mouseY);
                if (i === 0) {
                    drawModeToggleButton(rect, i === menuSelectionIndex, hovered);
                } else {
                    drawMenuButton(MAIN_MENU_OPTIONS[i], rect, i === menuSelectionIndex, hovered);
                }
                menuButtons.push({ ...rect, onClick: () => handleMainMenuSelection(i) });
                y += menuSpacing;
            }

            // High score and controls at bottom of box (inside the panel)
            const highScoreY = boxY + boxHeight - 45;
            const controlsY = boxY + boxHeight - 22;

            ctx.font = '14px Courier New';
            ctx.fillStyle = '#ff0';
            ctx.textAlign = 'center';
            ctx.fillText(`HIGH SCORE: ${profile.highScore.toString().padStart(6, '0')}`, centerX, highScoreY);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'center';
            ctx.fillText('ARROW KEYS + ENTER', centerX, controlsY);

            ctx.restore();
        }

        function renderAIMissionUI() {
            const panelX = 50;
            const panelY = screenHeight - 200;
            const panelW = 300;
            const panelH = 150;

            ctx.fillStyle = 'rgba(0, 20, 0, 0.9)';
            ctx.fillRect(panelX, panelY, panelW, panelH);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(panelX, panelY, panelW, panelH);

            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText('AI MISSION GENERATOR', panelX + 15, panelY + 25);

            ctx.font = '11px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('Press G to generate custom mission', panelX + 15, panelY + 50);
            ctx.fillText('Examples:', panelX + 15, panelY + 70);
            ctx.fillText('- "night raid on enemy base"', panelX + 15, panelY + 85);
            ctx.fillText('- "defend against air attack"', panelX + 15, panelY + 100);
            ctx.fillText('- "stealth mission, few enemies"', panelX + 15, panelY + 115);

            if (isGeneratingMission) {
                ctx.fillStyle = '#ff0';
                ctx.fillText('Generating mission...', panelX + 15, panelY + 135);
            } else if (aiMission) {
                ctx.fillStyle = '#0f0';
                ctx.fillText('Mission ready! Press ENTER to start', panelX + 15, panelY + 135);
            }
        }

        function renderMissionGeneratorOverlay() {
            ctx.save();
            // Clear menuButtons for this overlay - we'll add our own
            menuButtons = [];
            
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 500;
            const boxHeight = 320;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'AI MISSION GENERATOR');
            
            // Instructions
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('Describe your custom mission scenario', centerX, boxY + 60);
            
            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('The AI will generate enemies, objectives, and conditions', centerX, boxY + 85);
            
            // Examples
            ctx.textAlign = 'left';
            ctx.fillStyle = '#0a0';
            ctx.fillText('Examples:', boxX + 30, boxY + 115);
            ctx.font = '11px Courier New';
            ctx.fillText('• "Night raid on enemy base with heavy defenses"', boxX + 30, boxY + 135);
            ctx.fillText('• "Defend against incoming air attack"', boxX + 30, boxY + 150);
            ctx.fillText('• "Stealth mission, minimal enemies, fog"', boxX + 30, boxY + 165);
            
            // Input field
            const inputX = boxX + 30;
            const inputY = boxY + 195;
            const inputW = boxWidth - 60;
            const inputH = 30;
            
            ctx.fillStyle = 'rgba(0, 40, 0, 0.8)';
            ctx.fillRect(inputX, inputY, inputW, inputH);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(inputX, inputY, inputW, inputH);
            
            // Blinking cursor
            missionGeneratorCursorTime += 16;
            if (missionGeneratorCursorTime > 500) {
                missionGeneratorCursor = !missionGeneratorCursor;
                missionGeneratorCursorTime = 0;
            }
            
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            const displayText = missionGeneratorInput + (missionGeneratorCursor ? '_' : '');
            ctx.fillText(displayText, inputX + 8, inputY + 20);
            
            // Buttons
            ctx.textAlign = 'center';
            
            // Generate button
            const genBtnX = centerX - 120;
            const genBtnY = boxY + 245;
            const genBtnW = 100;
            const genBtnH = 32;
            
            const canGenerate = missionGeneratorInput.trim().length > 0 && !isGeneratingMission;
            const genBtnHovered = hitTest({ x: genBtnX, y: genBtnY, width: genBtnW, height: genBtnH }, mouseX, mouseY);
            ctx.fillStyle = canGenerate ? (genBtnHovered ? 'rgba(0, 100, 0, 0.8)' : 'rgba(0, 80, 0, 0.7)') : 'rgba(0, 30, 0, 0.5)';
            ctx.fillRect(genBtnX, genBtnY, genBtnW, genBtnH);
            ctx.strokeStyle = canGenerate ? '#0f0' : '#050';
            ctx.strokeRect(genBtnX, genBtnY, genBtnW, genBtnH);
            ctx.fillStyle = canGenerate ? '#0f0' : '#050';
            ctx.font = 'bold 14px Courier New';
            ctx.fillText('GENERATE', genBtnX + genBtnW / 2, genBtnY + 21);
            
            // Add generate button to menuButtons for click handling
            menuButtons.push({
                x: genBtnX, y: genBtnY, width: genBtnW, height: genBtnH,
                onClick: () => {
                    if (canGenerate) {
                        generateAIMission(missionGeneratorInput.trim(), 'normal');
                    }
                }
            });
            
            // Cancel button
            const cancelBtnX = centerX + 20;
            const cancelBtnHovered = hitTest({ x: cancelBtnX, y: genBtnY, width: genBtnW, height: genBtnH }, mouseX, mouseY);
            ctx.fillStyle = cancelBtnHovered ? 'rgba(0, 50, 0, 0.7)' : 'rgba(0, 30, 0, 0.6)';
            ctx.fillRect(cancelBtnX, genBtnY, genBtnW, genBtnH);
            ctx.strokeStyle = '#0a0';
            ctx.strokeRect(cancelBtnX, genBtnY, genBtnW, genBtnH);
            ctx.fillStyle = '#0a0';
            ctx.fillText('CANCEL', cancelBtnX + genBtnW / 2, genBtnY + 21);
            
            // Add cancel button to menuButtons for click handling
            menuButtons.push({
                x: cancelBtnX, y: genBtnY, width: genBtnW, height: genBtnH,
                onClick: () => {
                    missionGeneratorInput = '';
                    startTransition(GAME_STATES.MENU, 400);
                }
            });
            
            // Status message
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            if (isGeneratingMission) {
                ctx.fillStyle = '#ff0';
                ctx.fillText('Generating mission... please wait', centerX, boxY + boxHeight - 25);
            } else if (aiMission) {
                ctx.fillStyle = '#0f0';
                ctx.fillText('Mission ready! Return to menu and press ENTER to start', centerX, boxY + boxHeight - 25);
            } else {
                ctx.fillStyle = '#0a0';
                ctx.fillText('Press ENTER to generate, ESC to cancel', centerX, boxY + boxHeight - 25);
            }
            ctx.restore();
        }

        function renderCustomMissionOverlay() {
            menuButtons = [];

            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 500;
            const boxHeight = 350;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;

            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'MAP EDITOR MISSION');

            ctx.font = '14px Courier New';
            ctx.textAlign = 'center';

            if (customMissionConfig) {
                // Show mission details
                ctx.fillStyle = '#0f0';
                ctx.fillText('Custom mission loaded!', centerX, boxY + 60);

                ctx.font = '16px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText(customMissionConfig.name || 'Unnamed Mission', centerX, boxY + 95);

                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                const detailsX = boxX + 40;
                let detailsY = boxY + 130;

                ctx.fillStyle = '#0a0';
                ctx.fillText(`Map: Map ${customMissionConfig.mapIndex || 1}`, detailsX, detailsY);
                detailsY += 25;
                ctx.fillText(`Difficulty: ${(customMissionConfig.difficulty || 'medium').toUpperCase()}`, detailsX, detailsY);
                detailsY += 25;
                ctx.fillText(`Weather: ${(customMissionConfig.weather || 'clear').toUpperCase()}`, detailsX, detailsY);
                detailsY += 25;

                // Count objects
                const airportCount = (customMissionConfig.airports || []).length;
                const baseCount = (customMissionConfig.bases || []).length;
                const helipadCount = (customMissionConfig.helipads || []).length;
                const zoneCount = (customMissionConfig.spawnZones || []).length;

                ctx.fillText(`Airports: ${airportCount}`, detailsX, detailsY);
                ctx.fillText(`Bases: ${baseCount}`, detailsX + 150, detailsY);
                detailsY += 25;
                ctx.fillText(`Helipads: ${helipadCount}`, detailsX, detailsY);
                ctx.fillText(`Spawn Zones: ${zoneCount}`, detailsX + 150, detailsY);

                // Launch button
                const launchBtnX = centerX - 60;
                const launchBtnY = boxY + boxHeight - 90;
                const launchBtnW = 120;
                const launchBtnH = 36;

                const launchHovered = hitTest({ x: launchBtnX, y: launchBtnY, width: launchBtnW, height: launchBtnH }, mouseX, mouseY);
                ctx.fillStyle = launchHovered ? 'rgba(0, 100, 0, 0.8)' : 'rgba(0, 80, 0, 0.7)';
                ctx.fillRect(launchBtnX, launchBtnY, launchBtnW, launchBtnH);
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(launchBtnX, launchBtnY, launchBtnW, launchBtnH);

                ctx.textAlign = 'center';
                ctx.font = 'bold 16px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText('LAUNCH', launchBtnX + launchBtnW / 2, launchBtnY + 24);

                menuButtons.push({
                    x: launchBtnX, y: launchBtnY, width: launchBtnW, height: launchBtnH,
                    onClick: () => {
                        playMenuConfirmSound();
                        startTransition(GAME_STATES.PLAYING, 700, {
                            onSwitch: () => startCustomMission()
                        });
                    }
                });

                ctx.font = '12px Courier New';
                ctx.fillStyle = '#0a0';
                ctx.fillText('Press ENTER to launch, ESC to cancel', centerX, boxY + boxHeight - 30);
            } else {
                // No mission found
                ctx.fillStyle = '#f00';
                ctx.fillText('No custom mission found!', centerX, boxY + 80);

                ctx.font = '12px Courier New';
                ctx.fillStyle = '#0a0';
                ctx.fillText('Use the Map Editor to create and save a mission.', centerX, boxY + 120);
                ctx.fillText('Open: /src/web/mapeditor.html', centerX, boxY + 145);
                ctx.fillText('Click "Save to Browser" to store your mission.', centerX, boxY + 170);

                ctx.fillStyle = '#ff0';
                ctx.fillText('Press ESC to return to menu', centerX, boxY + boxHeight - 30);
            }

            // Back button
            const backBtnX = boxX + 20;
            const backBtnY = boxY + boxHeight - 50;
            const backBtnW = 80;
            const backBtnH = 30;

            const backHovered = hitTest({ x: backBtnX, y: backBtnY, width: backBtnW, height: backBtnH }, mouseX, mouseY);
            ctx.fillStyle = backHovered ? 'rgba(0, 50, 0, 0.7)' : 'rgba(0, 30, 0, 0.6)';
            ctx.fillRect(backBtnX, backBtnY, backBtnW, backBtnH);
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(backBtnX, backBtnY, backBtnW, backBtnH);

            ctx.textAlign = 'center';
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('BACK', backBtnX + backBtnW / 2, backBtnY + 20);

            menuButtons.push({
                x: backBtnX, y: backBtnY, width: backBtnW, height: backBtnH,
                onClick: () => {
                    playMenuConfirmSound();
                    customMissionConfig = null;
                    startTransition(GAME_STATES.MENU, 400);
                }
            });
        }

        function renderCampaignOverlay() {
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 480;
            const boxHeight = 400;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - 170;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'CAMPAIGN OPERATIONS');

            ctx.font = '16px Courier New';
            let y = boxY + 70;
            const availableMissions = getCampaignMissionIndices();
            for (let i = 0; i < availableMissions.length; i++) {
                const mission = MISSIONS[availableMissions[i]];
                const rect = { x: boxX + 20, y: y - 18, width: boxWidth - 40, height: 30 };
                const hovered = hitTest(rect, mouseX, mouseY);
                if (i === campaignSelectionIndex || hovered) {
                    ctx.fillStyle = 'rgba(0, 90, 0, 0.6)';
                    ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                }
                ctx.fillStyle = i === campaignSelectionIndex ? '#0f0' : '#0a0';
                ctx.textAlign = 'left';
                const difficultyStars = getDifficultyStars(mission.difficulty);
                ctx.fillText(`[${i + 1}] MISSION ${i + 1}`, rect.x + 10, y + 4);
                ctx.textAlign = 'right';
                ctx.fillStyle = i === campaignSelectionIndex ? '#ff0' : '#880';
                ctx.fillText(difficultyStars, rect.x + rect.width - 10, y + 4);
                menuButtons.push({ ...rect, onClick: async () => {
                    campaignSelectionIndex = i;
                    currentMissionIndex = availableMissions[i];
                    // Preload mission layout for accurate briefing display
                    await preloadMissionLayout(currentMissionIndex);
                    startTransition(GAME_STATES.BRIEFING, 600);
                }});
                y += 40;
            }

            const backRect = { x: boxX + 140, y: boxY + boxHeight - 55, width: boxWidth - 280, height: 32 };
            const backHover = hitTest(backRect, mouseX, mouseY);
            drawMenuButton('BACK TO MAIN MENU', backRect, false, backHover);
            menuButtons.push({ ...backRect, onClick: () => startTransition(GAME_STATES.MENU, 500) });

        }

        function renderFreePlayOverlay() {
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 440;
            const boxHeight = 260;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - 140;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'FREE PLAY');

            ctx.font = '14px Courier New';
            ctx.fillStyle = '#0c0';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT MAP USING DROPDOWN (TOP RIGHT)', centerX, boxY + 80);
            ctx.fillText('NO TIME LIMIT  •  RANDOM TARGETS', centerX, boxY + 110);

            let y = boxY + 160;
            for (let i = 0; i < FREEPLAY_OPTIONS.length; i++) {
                const rect = { x: boxX + 80, y: y - 18, width: boxWidth - 160, height: 34 };
                const hovered = hitTest(rect, mouseX, mouseY);
                drawMenuButton(FREEPLAY_OPTIONS[i], rect, i === freePlaySelectionIndex, hovered);
                menuButtons.push({ ...rect, onClick: () => {
                    if (i === 0) {
                        startTransition(GAME_STATES.PLAYING, 700, { onSwitch: () => startFreePlay() });
                    } else {
                        startTransition(GAME_STATES.MENU, 500);
                    }
                }});
                y += 50;
            }
        }

        function renderSettingsOverlay() {
            menuButtons = [];
            settingsControls = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 520;
            const boxHeight = 440;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - 220;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'SETTINGS');

            let y = boxY + 70;
            for (let i = 0; i < SETTINGS_ITEMS.length; i++) {
                const item = SETTINGS_ITEMS[i];
                const isSelected = i === settingsSelectionIndex;
                if (item.type === 'slider') {
                    ctx.font = '14px Courier New';
                    ctx.fillStyle = isSelected ? '#0f0' : '#0a0';
                    ctx.textAlign = 'left';
                    ctx.fillText(item.label, boxX + 30, y);

                    const sliderX = boxX + 220;
                    const sliderY = y - 12;
                    const sliderWidth = 220;
                    const sliderHeight = 12;
                    ctx.fillStyle = 'rgba(0, 40, 0, 0.8)';
                    ctx.fillRect(sliderX, sliderY, sliderWidth, sliderHeight);
                    ctx.strokeStyle = '#0a0';
                    ctx.strokeRect(sliderX, sliderY, sliderWidth, sliderHeight);

                    const value = settings[item.key];
                    const t = (value - item.min) / (item.max - item.min);
                    const fillWidth = Math.max(0, Math.min(sliderWidth, t * sliderWidth));
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(sliderX, sliderY, fillWidth, sliderHeight);

                    ctx.fillStyle = '#0f0';
                    ctx.textAlign = 'right';
                    let displayValue = '';
                    if (item.key.includes('Volume')) {
                        displayValue = `${Math.round(value * 100)}%`;
                    } else if (item.key === 'drawDistance') {
                        displayValue = `${Math.round(value)}`;
                    } else {
                        displayValue = value.toFixed(2);
                    }
                    ctx.fillText(displayValue, boxX + boxWidth - 30, y);

                    const controlRect = { x: sliderX, y: sliderY, width: sliderWidth, height: sliderHeight, type: 'slider', key: item.key, min: item.min, max: item.max, step: item.step };
                    settingsControls.push(controlRect);
                    y += 40;
                } else if (item.type === 'toggle') {
                    const rect = { x: boxX + 30, y: y - 18, width: boxWidth - 60, height: 30, type: 'toggle', key: item.key };
                    const hovered = hitTest(rect, mouseX, mouseY);
                    if (isSelected || hovered) {
                        ctx.fillStyle = 'rgba(0, 80, 0, 0.5)';
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                    }
                    ctx.font = '14px Courier New';
                    ctx.fillStyle = isSelected ? '#0f0' : '#0a0';
                    ctx.textAlign = 'left';
                    ctx.fillText(item.label, rect.x + 10, y + 4);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = settings[item.key] ? '#0f0' : '#060';
                    ctx.fillText(settings[item.key] ? 'ON' : 'OFF', rect.x + rect.width - 10, y + 4);
                    settingsControls.push(rect);
                    y += 40;
                } else if (item.type === 'action') {
                    const rect = { x: boxX + 140, y: y - 18, width: boxWidth - 280, height: 34, type: 'action', onClick: () => startTransition(GAME_STATES.MENU, 500) };
                    const hovered = hitTest(rect, mouseX, mouseY);
                    drawMenuButton(item.label, rect, isSelected, hovered);
                    settingsControls.push(rect);
                    y += 50;
                }
            }

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'center';
            ctx.fillText('LEFT/RIGHT TO ADJUST  •  ENTER TO TOGGLE', centerX, boxY + boxHeight - 20);
        }

        function renderAchievementsOverlay() {
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 720;
            const boxHeight = 580;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'ACHIEVEMENTS & STATS');

            const achievementIds = Object.keys(ACHIEVEMENTS);
            const columns = 2;
            const rows = Math.ceil(achievementIds.length / columns);
            const colWidth = (boxWidth - 120) / columns;
            const rowHeight = 52;
            const startY = boxY + 70;
            const startX = boxX + 40;

            ctx.font = 'bold 13px Courier New';
            for (let i = 0; i < achievementIds.length; i++) {
                const id = achievementIds[i];
                const achievement = ACHIEVEMENTS[id];
                const unlocked = hasAchievement(id);
                const col = Math.floor(i / rows);
                const row = i % rows;
                const x = startX + col * colWidth;
                const y = startY + row * rowHeight;

                ctx.fillStyle = unlocked ? 'rgba(0, 70, 0, 0.6)' : 'rgba(0, 25, 0, 0.4)';
                ctx.fillRect(x - 10, y - 18, colWidth - 20, 40);

                ctx.fillStyle = unlocked ? '#ff0' : '#444';
                ctx.textAlign = 'left';
                ctx.fillText(achievement.icon, x, y);

                ctx.fillStyle = unlocked ? '#0f0' : '#070';
                ctx.fillText(achievement.name.toUpperCase(), x + 26, y);

                ctx.font = '12px Courier New';
                ctx.fillStyle = unlocked ? '#0c0' : '#050';
                const maxDescLen = 35;
                const descText = achievement.desc.length > maxDescLen ? achievement.desc.substring(0, maxDescLen - 2) + '..' : achievement.desc;
                ctx.fillText(descText, x + 26, y + 16);
                ctx.font = 'bold 13px Courier New';
            }

            const statsY = startY + rows * rowHeight + 10;
            ctx.strokeStyle = '#0a0';
            ctx.beginPath();
            ctx.moveTo(boxX + 30, statsY);
            ctx.lineTo(boxX + boxWidth - 30, statsY);
            ctx.stroke();

            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText('LIFETIME STATS', boxX + 30, statsY + 30);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0c0';
            const statsLeftX = boxX + 30;
            let statsLineY = statsY + 50;
            ctx.fillText(`Total Kills: ${profile.stats.totalKills}`, statsLeftX, statsLineY);
            statsLineY += 18;
            ctx.fillText(`Total Deaths: ${profile.stats.totalDeaths}`, statsLeftX, statsLineY);
            statsLineY += 18;
            ctx.fillText(`Missions Completed: ${profile.stats.missionsCompleted}`, statsLeftX, statsLineY);
            statsLineY += 18;
            ctx.fillText(`Total Time Played: ${formatDuration(profile.stats.totalTimePlayed)}`, statsLeftX, statsLineY);
            statsLineY += 18;
            ctx.fillText(`High Score: ${profile.highScore}`, statsLeftX, statsLineY);

            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText('MISSION PROGRESS', boxX + boxWidth / 2 + 10, statsY + 30);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0c0';
            let missionY = statsY + 50;
            for (const mission of MISSIONS) {
                const missionId = String(mission.id);
                const completed = profile.missionsCompleted.includes(missionId);
                const stars = profile.missionStars[missionId] || 0;
                const bestScore = profile.missionScores[missionId] || 0;
                ctx.fillStyle = completed ? '#0f0' : '#060';
                ctx.fillText(`M${mission.id}: ${mission.name}`, boxX + boxWidth / 2 + 10, missionY);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#ff0';
                ctx.fillText(getStarString(stars), boxX + boxWidth - 30, missionY);
                ctx.textAlign = 'left';
                ctx.fillStyle = '#0a0';
                ctx.fillText(`Best: ${bestScore}`, boxX + boxWidth / 2 + 10, missionY + 16);
                missionY += 32;
            }

            const backRect = { x: boxX + 240, y: boxY + boxHeight - 50, width: boxWidth - 480, height: 32 };
            const backHover = hitTest(backRect, mouseX, mouseY);
            drawMenuButton('BACK TO MENU', backRect, false, backHover);
            menuButtons.push({ ...backRect, onClick: () => startTransition(GAME_STATES.MENU, 500) });
        }

        function renderLeaderboardOverlay() {
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 520;
            const boxHeight = 500;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'GLOBAL LEADERBOARD');

            const stats = cachedGlobalStats;
            ctx.textAlign = 'center';
            if (!stats || !stats.leaderboard || !stats.totals) {
                ctx.font = '14px Courier New';
                ctx.fillStyle = '#0a0';
                ctx.fillText('Fetching latest scores...', centerX, boxY + 90);
            } else {
                ctx.font = '12px Courier New';
                ctx.fillStyle = '#0a0';
                ctx.fillText(`Total Kills: ${stats.totals.kills}  •  Deaths: ${stats.totals.deaths}  •  Missions: ${stats.totals.missionsCompleted}`, centerX, boxY + 70);

                ctx.font = 'bold 14px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText('TOP PILOTS', centerX, boxY + 95);

                // Scrollable leaderboard
                const visibleCount = 9; // Reduced to fit mission/map info per entry
                const totalEntries = stats.leaderboard.length;
                const maxScroll = Math.max(0, totalEntries - visibleCount);
                leaderboardScrollOffset = Math.max(0, Math.min(maxScroll, leaderboardScrollOffset));

                ctx.font = '12px Courier New';
                ctx.textAlign = 'left';
                let y = boxY + 125;
                const listX = boxX + 40;
                const scoreX = boxX + boxWidth - 40;

                // Show scroll indicator if there are more entries
                if (totalEntries > visibleCount) {
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#0a0';
                    ctx.font = '11px Courier New';
                    ctx.fillText(`Showing ${leaderboardScrollOffset + 1}-${Math.min(leaderboardScrollOffset + visibleCount, totalEntries)} of ${totalEntries}  (↑/↓ to scroll)`, centerX, boxY + 112);
                    ctx.font = '12px Courier New';
                    ctx.textAlign = 'left';
                }

                for (let i = leaderboardScrollOffset; i < Math.min(leaderboardScrollOffset + visibleCount, totalEntries); i++) {
                    const entry = stats.leaderboard[i];
                    const rank = i + 1;
                    ctx.fillStyle = rank <= 3 ? '#ff0' : '#0f0';
                    ctx.fillText(`${rank}.`, listX, y);
                    ctx.fillStyle = '#0f0';
                    ctx.fillText(entry.name.substring(0, 18), listX + 30, y);
                    ctx.textAlign = 'right';
                    ctx.fillStyle = '#0c0';
                    ctx.fillText(entry.score.toLocaleString(), scoreX, y);
                    ctx.textAlign = 'left';
                    
                    // Show mission/map info below each entry
                    ctx.font = '10px Courier New';
                    ctx.fillStyle = '#666';
                    const missionInfo = entry.mission ? `Mission ${entry.mission}` : 'Free Play';
                    const mapInfo = entry.map ? `Map ${entry.map}` : '?';
                    const killsInfo = entry.kills !== undefined ? `${entry.kills} kills` : '';
                    const detailText = killsInfo ? `${missionInfo} • ${mapInfo} • ${killsInfo}` : `${missionInfo} • ${mapInfo}`;
                    ctx.fillText(detailText, listX + 30, y + 12);
                    ctx.font = '12px Courier New';
                    
                    y += 38; // Increased spacing to fit the extra line
                }

                if (stats.leaderboard.length === 0) {
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#0a0';
                    ctx.fillText('No scores yet - be the first!', centerX, boxY + 150);
                }
            }

            const backRect = { x: boxX + 160, y: boxY + boxHeight - 50, width: boxWidth - 320, height: 34 };
            const backHover = hitTest(backRect, mouseX, mouseY);
            drawMenuButton('BACK TO MENU', backRect, false, backHover);
            menuButtons.push({ ...backRect, onClick: () => startTransition(GAME_STATES.MENU, 500) });
        }

        function renderHowToOverlay() {
            menuButtons = [];
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            const boxWidth = 620;
            const boxHeight = 680;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            drawMenuPanel(boxX, boxY, boxWidth, boxHeight, 'HOW TO PLAY');

            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            let y = boxY + 65;

            // === COMANCHE MODE ===
            ctx.fillStyle = '#ff0';
            ctx.fillText('═══ COMANCHE MODE (Helicopter) ═══', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('MOVEMENT', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('W/S - Forward/Back   A/D - Bank   J/L - Yaw', boxX + 30, y);
            y += 16;
            ctx.fillText('R/F - Altitude   Q/E - Look Up/Down   SPACE - Boost', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('WEAPONS', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('1-4 - Select Weapon (Cannon/Rockets/Hellfire/Stinger)', boxX + 30, y);
            y += 16;
            ctx.fillText("Z/X or [ ] - Cycle Weapons   ; - Chaff   ' - Flare", boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('TARGETING', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('T - Target Crosshairs   Tab - Cycle Targets', boxX + 30, y);

            // === DELTA MODE ===
            y += 28;
            ctx.fillStyle = '#ff0';
            ctx.fillText('═══ DELTA MODE (On Foot) ═══', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('MOVEMENT', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('WASD - Move   Mouse - Look/Aim   Shift - Sprint', boxX + 30, y);
            y += 16;
            ctx.fillText('Ctrl - Crouch   V - Prone', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('WEAPONS', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('Click - Fire   R - Reload', boxX + 30, y);
            y += 16;
            ctx.fillText('Z/X - Cycle Weapons   1-5 - Direct Select', boxX + 30, y);
            y += 16;
            ctx.fillText('(M4, Sniper, Pistol, Javelin, Stinger)', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0f0';
            ctx.fillText('TARGETING', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('T - Target Crosshairs   Tab - Cycle Targets', boxX + 30, y);

            // === GENERAL ===
            y += 28;
            ctx.fillStyle = '#ff0';
            ctx.fillText('═══ GENERAL ═══', boxX + 30, y);
            y += 22;
            ctx.fillStyle = '#0c0';
            ctx.fillText('E - Exit/Enter Helicopter (when landed)', boxX + 30, y);
            y += 16;
            ctx.fillText('M - Weather   N - Night Vision   B - Sound', boxX + 30, y);
            y += 16;
            ctx.fillText('ESC - Pause   H - Toggle Controls   F1 - Tips', boxX + 30, y);
            y += 16;
            ctx.fillText('G - Generate AI Mission (in menu)', boxX + 30, y);

            // === TARGETING INFO ===
            y += 24;
            ctx.fillStyle = '#0f0';
            ctx.fillText('TARGETING SYSTEM', boxX + 30, y);
            ctx.fillStyle = '#0c0';
            y += 18;
            ctx.fillText('• Tab cycles through valid targets for current weapon', boxX + 30, y);
            y += 16;
            ctx.fillText('• Guided missiles auto-lock when target is selected', boxX + 30, y);
            y += 16;
            ctx.fillText('• Lock progress bar shows below target brackets', boxX + 30, y);
            y += 16;
            ctx.fillText('• Fire when "LOCK" appears for best accuracy', boxX + 30, y);

            const backRect = { x: boxX + 180, y: boxY + boxHeight - 55, width: boxWidth - 360, height: 34 };
            const hovered = hitTest(backRect, mouseX, mouseY);
            drawMenuButton('BACK TO MENU', backRect, false, hovered);
            menuButtons.push({ ...backRect, onClick: () => startTransition(GAME_STATES.MENU, 500) });
        }
        
        function renderBriefingOverlay() {
            ctx.save();
            const mission = getBriefingMission();
            const isDelta = gameMode === GAME_MODES.DELTA;
            const briefingText = isDelta
                ? (mission.briefingDelta || mission.briefing)
                : mission.briefing;
            const targetConfig = isDelta
                ? (mission.targetsDelta || mission.targets)
                : mission.targets;
            
            // Semi-transparent dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            const centerX = screenWidth / 2;
            const boxWidth = 550;
            const boxHeight = 450;
            const boxX = centerX - boxWidth / 2;
            const boxY = (screenHeight - boxHeight) / 2;
            
            // Border
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            
            // Header
            ctx.fillStyle = 'rgba(0, 50, 0, 0.8)';
            ctx.fillRect(boxX, boxY, boxWidth, 40);
            
            ctx.font = 'bold 20px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('MISSION BRIEFING', centerX, boxY + 27);
            
            let y = boxY + 70;
            
            // Mission name
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText(`MISSION: ${mission.name}`, boxX + 30, y);
            y += 35;
            
            // Difficulty
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#ff0';
            const stars = getDifficultyStars(mission.difficulty);
            ctx.fillText(`DIFFICULTY: ${stars} ${mission.difficulty.toUpperCase()}`, boxX + 30, y);
            y += 25;
            
            // Time limit
            if (mission.timeLimit) {
                const mins = Math.floor(mission.timeLimit / 60);
                const secs = mission.timeLimit % 60;
                ctx.fillStyle = '#f80';
                ctx.fillText(`TIME LIMIT: ${mins}:${secs.toString().padStart(2, '0')}`, boxX + 30, y);
            } else {
                ctx.fillStyle = '#0f0';
                ctx.fillText('TIME LIMIT: NONE', boxX + 30, y);
            }
            y += 40;
            
            // Briefing text
            ctx.fillStyle = '#0f0';
            ctx.font = '14px Courier New';
            ctx.fillText('BRIEFING:', boxX + 30, y);
            y += 25;
            
            ctx.fillStyle = '#0c0';
            const briefingLines = wrapText(briefingText, boxWidth - 60);
            for (const line of briefingLines) {
                ctx.fillText(line, boxX + 30, y);
                y += 20;
            }
            y += 20;
            
            // Objectives
            ctx.fillStyle = '#0f0';
            ctx.font = '14px Courier New';
            ctx.fillText('OBJECTIVES:', boxX + 30, y);
            y += 22;
            
            ctx.fillStyle = '#0c0';
            for (const obj of mission.objectives) {
                ctx.fillText(`  * ${obj.description}`, boxX + 30, y);
                y += 20;
            }
            y += 20;
            
            // Expected resistance
            ctx.fillStyle = '#f00';
            ctx.font = '14px Courier New';
            ctx.fillText('EXPECTED RESISTANCE:', boxX + 30, y);
            y += 22;
            
            ctx.fillStyle = '#c00';
            if (isDelta) {
                const soldierCount = targetConfig.soldiers || targetConfig.tanks || 0;
                ctx.fillText(`  * ${soldierCount} Enemy Combatants`, boxX + 30, y);
            } else {
                ctx.fillText(`  * ${targetConfig.tanks} Tanks  * ${targetConfig.sams} SAM Sites`, boxX + 30, y);
            }
            y += 30;
            
            // Reward
            ctx.fillStyle = '#ff0';
            ctx.fillText(`MISSION REWARD: ${mission.rewards.score} points`, boxX + 30, y);
            
            // Instructions at bottom of screen (not inside the box)
            ctx.font = '14px Courier New';
            ctx.textAlign = 'center';
            const instructionY = screenHeight - 40;
            
            const blinkOn = Math.floor(performance.now() / 500) % 2 === 0;
            if (blinkOn) {
                ctx.fillStyle = '#0f0';
                ctx.fillText('[ENTER] Launch Mission', centerX - 100, instructionY);
            }
            ctx.fillStyle = '#888';
            const backLabel = pendingAIMission ? '[ESC] Back to Menu' : '[ESC] Back to Campaign';
            ctx.fillText(backLabel, centerX + 100, instructionY);
            ctx.restore();
        }
        
        function renderPauseOverlay() {
            pauseButtons = [];
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);

            const panelW = 300;
            const panelH = 350;
            const panelX = (screenWidth - panelW) / 2;
            const panelY = (screenHeight - panelH) / 2;

            ctx.fillStyle = 'rgba(0, 30, 0, 0.95)';
            ctx.fillRect(panelX, panelY, panelW, panelH);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            ctx.strokeRect(panelX, panelY, panelW, panelH);

            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', screenWidth / 2, panelY + 40);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'left';
            let y = panelY + 70;

            ctx.fillText(`Kills: ${sessionStats.kills}`, panelX + 20, y); y += 20;
            ctx.fillText(`Score: ${sessionStats.score}`, panelX + 20, y); y += 20;
            ctx.fillText(`Accuracy: ${calculateAccuracy()}%`, panelX + 20, y); y += 20;
            const timeLabel = gameMode === GAME_MODES.COMANCHE ? 'Flight Time' : 'Ground Time';
            const timeValue = gameMode === GAME_MODES.COMANCHE ? telemetry.flightTime : telemetry.groundTime;
            ctx.fillText(`${timeLabel}: ${Math.floor(timeValue)}s`, panelX + 20, y); y += 20;
            ctx.fillText(`Distance: ${Math.floor(telemetry.distanceTraveled)}m`, panelX + 20, y); y += 30;

            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';

            y = panelY + 220;
            for (let i = 0; i < PAUSE_OPTIONS.length; i++) {
                const rect = { x: panelX + 20, y: y - 14, width: panelW - 40, height: 26 };
                const hovered = hitTest(rect, mouseX, mouseY);
                const isActive = hovered || i === pauseSelectionIndex;
                ctx.fillStyle = isActive ? '#ff0' : '#0f0';
                ctx.fillText(PAUSE_OPTIONS[i], screenWidth / 2, y);
                pauseButtons.push({ ...rect, onClick: () => {
                    if (i === 0) {
                        startTransition(GAME_STATES.PLAYING, 250, { onSwitch: () => resumeFromPause() });
                    } else if (i === 1) {
                        startTransition(GAME_STATES.PLAYING, 900, { hold: true, onSwitch: () => restartCurrentMode() });
                    } else {
                        startTransition(GAME_STATES.MENU, 700, { onSwitch: () => returnToMenu() });
                    }
                }});
                y += 35;
            }

            ctx.font = '11px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'center';
            ctx.fillText('Use UP/DOWN to select, ENTER to confirm', screenWidth / 2, panelY + panelH - 20);
        }
        
        function renderVictoryOverlay() {
            const mission = getActiveMission();
            if (!mission) return;
            ctx.save();
            
            // Semi-transparent dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            
            const boxWidth = 400;
            const boxHeight = 350;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            
            // Border with glow effect
            ctx.shadowColor = '#0f0';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = 'rgba(0, 30, 0, 0.9)';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            
            // Title
            ctx.font = 'bold 36px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#0f0';
            ctx.shadowBlur = 15;
            ctx.fillText('MISSION COMPLETE', centerX, boxY + 50);
            ctx.shadowBlur = 0;
            
            // Score breakdown
            let y = boxY + 100;
            ctx.font = '16px Courier New';
            ctx.textAlign = 'left';

            const scoreInfo = calculateMissionScore(mission);
            
            const targetsDestroyed = targets.filter(t => t.destroyed).length;
            ctx.fillStyle = '#0c0';
            ctx.fillText(`Targets Destroyed:`, boxX + 40, y);
            ctx.textAlign = 'right';
            ctx.fillText(`${targetsDestroyed}`, boxX + boxWidth - 40, y);
            y += 30;
            
            ctx.textAlign = 'left';
            ctx.fillText(`Combat Score:`, boxX + 40, y);
            ctx.textAlign = 'right';
            ctx.fillText(`${score}`, boxX + boxWidth - 40, y);
            y += 30;
            
            // Time bonus
            let timeBonus = 0;
            if (mission.timeLimit && scoreInfo.timeBonus > 0) {
                timeBonus = scoreInfo.timeBonus;
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ff0';
                ctx.fillText(`Time Bonus:`, boxX + 40, y);
                ctx.textAlign = 'right';
                ctx.fillText(`+${timeBonus}`, boxX + boxWidth - 40, y);
                y += 30;
            }
            
            // Health bonus
            const healthBonus = scoreInfo.healthBonus;
            ctx.textAlign = 'left';
            ctx.fillStyle = '#0ff';
            ctx.fillText(`Health Bonus:`, boxX + 40, y);
            ctx.textAlign = 'right';
            ctx.fillText(`+${healthBonus}`, boxX + boxWidth - 40, y);
            y += 30;
            
            // Mission reward
            ctx.textAlign = 'left';
            ctx.fillStyle = '#f80';
            ctx.fillText(`Mission Reward:`, boxX + 40, y);
            ctx.textAlign = 'right';
            ctx.fillText(`+${scoreInfo.reward}`, boxX + boxWidth - 40, y);
            y += 40;
            
            // Total
            const totalScore = scoreInfo.totalScore;
            ctx.font = 'bold 20px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText(`TOTAL SCORE:`, boxX + 40, y);
            ctx.textAlign = 'right';
            ctx.fillText(`${totalScore}`, boxX + boxWidth - 40, y);
            
            // Instructions
            ctx.font = '14px Courier New';
            ctx.textAlign = 'center';
            
            const blinkOn = Math.floor(performance.now() / 500) % 2 === 0;
            if (activeAIMission) {
                if (blinkOn) {
                    ctx.fillStyle = '#0f0';
                    ctx.fillText('[ENTER] Return to Menu', centerX, boxY + boxHeight - 35);
                }
            } else if (getCampaignMissionIndices().indexOf(currentMissionIndex) < getCampaignMissionIndices().length - 1) {
                if (blinkOn) {
                    ctx.fillStyle = '#0f0';
                    ctx.fillText('[ENTER] Next Mission', centerX, boxY + boxHeight - 40);
                }
            } else {
                if (blinkOn) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillText('ALL MISSIONS COMPLETE!', centerX, boxY + boxHeight - 55);
                    ctx.fillStyle = '#0f0';
                    ctx.fillText('[ENTER] Return to Menu', centerX, boxY + boxHeight - 35);
                }
            }
            ctx.fillStyle = '#888';
            ctx.fillText('[ESC] Return to Menu', centerX, boxY + boxHeight - 15);

            ctx.restore();
        }

        function renderDefeatOverlay() {
            ctx.save();
            // Semi-transparent red background
            ctx.fillStyle = 'rgba(50, 0, 0, 0.85)';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            
            const boxWidth = 350;
            const boxHeight = 220;
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            
            // Border
            ctx.shadowColor = '#f00';
            ctx.shadowBlur = 20;
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = 'rgba(30, 0, 0, 0.9)';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            
            // Title
            ctx.font = 'bold 36px Courier New';
            ctx.fillStyle = '#f00';
            ctx.textAlign = 'center';
            ctx.shadowColor = '#f00';
            ctx.shadowBlur = 15;
            ctx.fillText('MISSION FAILED', centerX, boxY + 50);
            ctx.shadowBlur = 0;
            
            // Reason
            ctx.font = '18px Courier New';
            ctx.fillStyle = '#f88';
            ctx.fillText(defeatReason, centerX, boxY + 90);
            
            // Score
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#c00';
            ctx.fillText(`Final Score: ${score}`, centerX, boxY + 130);
            
            // Instructions
            ctx.font = '14px Courier New';
            const blinkOn = Math.floor(performance.now() / 500) % 2 === 0;
            if (blinkOn) {
                ctx.fillStyle = '#f00';
                ctx.fillText('[ENTER] Retry Mission', centerX, boxY + boxHeight - 45);
            }
            ctx.fillStyle = '#888';
            ctx.fillText('[ESC] Return to Menu', centerX, boxY + boxHeight - 20);

            ctx.restore();
        }
        
        function getDifficultyStars(difficulty) {
            const stars = {
                'easy': '★☆☆☆☆',
                'medium': '★★☆☆☆',
                'hard': '★★★☆☆',
                'extreme': '★★★★★'
            };
            return stars[difficulty] || '★☆☆☆☆';
        }

        function getStarString(stars) {
            const filled = Math.max(0, Math.min(3, stars));
            return `${'★'.repeat(filled)}${'☆'.repeat(3 - filled)}`;
        }
        
        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            ctx.font = '14px Courier New';
            
            for (const word of words) {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            return lines;
        }
        
        // ============================================
        // VOXELSPACE RENDERING
        // ============================================
        function render() {
            if (!currentMap.altitude || !currentMap.color) return;
            
            // Create render camera
            let renderCam = {
                x: camera.x,
                y: camera.y,
                height: camera.height,
                angle: camera.angle,
                horizon: camera.horizon,
                distance: camera.distance,
                bank: camera.bank || 0
            };
            


            // Apply screen shake to camera (subtle jitter)
            if (screenShake.intensity > 0) {
                const shakeScale = 0.05; // world units per pixel of shake
                renderCam.x += (Math.cos(renderCam.angle) * -screenShake.y + Math.sin(renderCam.angle) * screenShake.x) * shakeScale;
                renderCam.y += (Math.sin(renderCam.angle) * -screenShake.y - Math.cos(renderCam.angle) * screenShake.x) * shakeScale;
                renderCam.horizon += screenShake.y;
            }
            
            // Clear to sky color based on weather
            const weather = WEATHER_SETTINGS[weatherCondition];
            buf32.fill(weather.skyColor);
            
            // Y-buffer for occlusion culling (stores lowest drawn Y for each column)
            if (!hiddenYBuffer || hiddenYBuffer.length !== screenWidth) {
                hiddenYBuffer = new Int32Array(screenWidth);
            }
            const hiddenY = hiddenYBuffer;
            hiddenY.fill(screenHeight);
            
            const sinAngle = Math.sin(renderCam.angle);
            const cosAngle = Math.cos(renderCam.angle);
            
            let dz = 1.0;
            
            // Draw from front to back (NO zoom applied to terrain - we use canvas zoom instead)
            for (let z = 1; z < renderCam.distance; z += dz) {
                // Calculate left and right points of the viewing frustum at distance z
                // Standard 90-degree FOV frustum
                const plx = (-cosAngle * z - sinAngle * z);
                const ply = ( sinAngle * z - cosAngle * z);
                const prx = ( cosAngle * z - sinAngle * z);
                const pry = (-sinAngle * z - cosAngle * z);
                
                // Step size across the screen
                const dx = (prx - plx) / screenWidth;
                const dy = (pry - ply) / screenWidth;
                
                // Starting point (add camera position)
                let px = plx + renderCam.x;
                let py = ply + renderCam.y;
                
                // Perspective scale factor (closer = taller) - NO zoom here
                const invz = 1.0 / z * 240.0;
                
                // Fog factor for distance fade - uses weather settings
                const fogStart = weather.fogStart;
                const fogEnd = Math.min(renderCam.distance, fogStart + (renderCam.distance - fogStart) / weather.fogDensity);
                const fogFactor = fogEnabled ? Math.min(1, Math.max(0, (z - fogStart) / (fogEnd - fogStart))) : 0;
                
                // Calculate bank tilt factor for this distance
                // Bank causes horizon to tilt - farther columns are affected more
                const bankTiltFactor = Math.sin(renderCam.bank) * 0.3;
                
                // Process each screen column
                for (let i = 0; i < screenWidth; i++) {
                    // Sample map with wrapping (& 1023 for 1024-size map)
                    const mapX = Math.floor(px) & (CONFIG.MAP_SIZE - 1);
                    const mapY = Math.floor(py) & (CONFIG.MAP_SIZE - 1);
                    const mapOffset = (mapY << CONFIG.MAP_SHIFT) + mapX;
                    
                    // Get height and color from map
                    const terrainHeight = currentMap.altitude[mapOffset];
                    let terrainColor = currentMap.color[mapOffset];
                    
                    // Apply ambient lighting for weather conditions
                    if (weather.ambient < 1.0) {
                        terrainColor = applyAmbient(terrainColor, weather.ambient);
                    }
                    
                    // Calculate bank offset for this column (tilt horizon based on bank angle)
                    // Left side goes down when banking right, right side goes up
                    const columnOffset = (i - screenWidth / 2);
                    const bankOffset = columnOffset * bankTiltFactor;
                    
                    // Project height to screen Y coordinate (with bank tilt)
                    const heightOnScreen = Math.floor((renderCam.height - terrainHeight) * invz + renderCam.horizon + bankOffset);
                    
                    // Only draw if this column is visible (not occluded)
                    if (heightOnScreen < hiddenY[i]) {
                        // Apply fog to color (blends toward sky color)
                        if (fogFactor > 0) {
                            terrainColor = blendWithWeatherFog(terrainColor, fogFactor, weather.skyColor);
                        }
                        
                        // Draw vertical line from heightOnScreen to hiddenY[i]
                        drawVerticalLine(i, heightOnScreen, hiddenY[i], terrainColor);
                        
                        // Update occlusion buffer
                        hiddenY[i] = heightOnScreen;
                    }
                    
                    // Move to next sample point
                    px += dx;
                    py += dy;
                }
                
                // Increase step size for LOD (level of detail)
                dz += 0.005;
            }
            
            // Draw to canvas
            ctx.putImageData(imageData, 0, 0);
            
            // Only render game elements during gameplay
            if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.PAUSED) {
                // Render targets (using canvas 2D API on top)
                renderTargets(renderCam);
                renderAirstrikePlanes(renderCam);
                renderParkedHelicopter(renderCam);
                
                // Render placed C4 charges
                renderC4Charges(renderCam);
                
                // Render projectiles
                renderProjectiles(renderCam);
                
                // Render enemy projectiles
                renderEnemyProjectiles(renderCam);
                
                // Render explosions
                renderExplosions(renderCam);

                // Render particles
                renderParticles(renderCam);
                
                // Apply night vision effect AFTER all game elements but BEFORE HUD
                // This ensures targets, projectiles, and explosions all get the NV treatment
                if (nightVisionMode) {
                    applyNightVisionEffect();
                }
                
                // Render screen flash effect
                renderScreenFlash();

                // Render muzzle flash
                renderMuzzleFlash();

                // Render damage vignette pulse
                renderDamageVignette();
                
                // Apply scope zoom by scaling the center portion of the canvas
                const zoomFactor = getDeltaZoomFactor();
                if (zoomFactor > 1.01) {
                    // Calculate source rectangle (center portion to zoom)
                    const srcWidth = screenWidth / zoomFactor;
                    const srcHeight = screenHeight / zoomFactor;
                    const srcX = (screenWidth - srcWidth) / 2;
                    const srcY = (screenHeight - srcHeight) / 2;
                    
                    // Copy and scale - use imageSmoothingEnabled for crisp pixels
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(canvas, 
                        srcX, srcY, srcWidth, srcHeight,  // source (center portion)
                        0, 0, screenWidth, screenHeight   // dest (full screen)
                    );
                    ctx.imageSmoothingEnabled = true;
                }

                // Render HUD
                renderHUD();
                
                // Render objectives panel and mission timer
                renderObjectivesPanel();
                renderMissionTimer();
                renderMissionMessage();
            }
            
            // Render rain effect for all screens (weather is global)
            renderRainEffect();
            
            // Render overlays based on game state
            if (gameState === GAME_STATES.TITLE) {
                renderTitleOverlay();
            } else if (gameState === GAME_STATES.MENU) {
                renderMainMenuOverlay();
            } else if (gameState === GAME_STATES.CAMPAIGN) {
                renderCampaignOverlay();
            } else if (gameState === GAME_STATES.FREEPLAY) {
                renderFreePlayOverlay();
            } else if (gameState === GAME_STATES.SETTINGS) {
                renderSettingsOverlay();
            } else if (gameState === GAME_STATES.ACHIEVEMENTS) {
                renderAchievementsOverlay();
            } else if (gameState === GAME_STATES.LEADERBOARD) {
                refreshGlobalStatsIfNeeded();
                renderLeaderboardOverlay();
            } else if (gameState === GAME_STATES.HOWTO) {
                renderHowToOverlay();
            } else if (gameState === GAME_STATES.MISSION_GENERATOR) {
                renderMissionGeneratorOverlay();
            } else if (gameState === GAME_STATES.CUSTOM_MISSION) {
                renderCustomMissionOverlay();
            } else if (gameState === GAME_STATES.BRIEFING) {
                renderBriefingOverlay();
            } else if (gameState === GAME_STATES.PAUSED) {
                renderPauseOverlay();
            } else if (gameState === GAME_STATES.VICTORY) {
                // Render game scene in background
                renderTargets(camera);
                renderExplosions(camera);
                renderHUD();
                // Victory overlay first (has dark background)
                renderVictoryOverlay();
                // Leaderboard on top of overlay (top-right corner)
                refreshGlobalStatsIfNeeded();
                if (cachedGlobalStats) {
                    renderLeaderboard(cachedGlobalStats);
                }
            } else if (gameState === GAME_STATES.DEFEAT) {
                // Render game scene in background
                renderTargets(camera);
                renderExplosions(camera);
                renderHUD();
                renderDefeatOverlay();
            }

            if (transition.active && transition.alpha > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${transition.alpha})`;
                ctx.fillRect(0, 0, screenWidth, screenHeight);
            }

            renderAchievementToasts();
        }
        
        // ============================================
        // ENEMY PROJECTILE RENDERING
        // ============================================
        function renderEnemyProjectiles(cam) {
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            
            for (const ep of enemyProjectiles) {
                // Calculate relative position
                let dx = ep.x - cam.x;
                let dy = ep.y - cam.y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Check if in front of camera
                if (ry > 5 && ry < cam.distance) {
                    // Check terrain occlusion for enemy projectiles
                    if (isProjectileOccluded(ep, cam, dx, dy, ry)) {
                        continue;
                    }
                    
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;
                    
                    // Apply bank tilt
                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
                    const screenY = (cam.height - ep.z) * scaleY + cam.horizon + bankOffset;
                    
                    // ALL ENEMY PROJECTILES - BALL-BASED (no tracer lines)
                    const scale = Math.min(scaleY, 1);
                    
                    if (ep.type === 'air_cannon') {
                        // Aircraft cannon - small ball
                        const bulletSize = Math.max(2.5, 2.5 * scale);
                        ctx.fillStyle = '#ffcc66';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, bulletSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (ep.type === 'air_rocket') {
                        // Aircraft rocket - medium ball with smoke trail circles
                        const rocketSize = Math.max(3.5, 4 * scale);
                        ctx.fillStyle = '#ff8844';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, rocketSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Smoke trail as fading circles
                        const trailAngle = Math.atan2(ep.vx || 0, ep.vy || 0);
                        for (let t = 1; t <= 2; t++) {
                            const trailDist = t * 7 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY - Math.cos(trailAngle) * trailDist;
                            const trailSize = (3 - t * 0.6) * scale;
                            ctx.fillStyle = `rgba(180, 180, 180, ${0.5 - t * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, Math.max(trailSize, 1), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (ep.type === 'air_missile') {
                        // Aircraft missile - larger ball with smoke trail circles
                        const missileSize = Math.max(4, 5 * scale);
                        ctx.fillStyle = '#ff4455';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, missileSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Smoke trail as fading circles
                        const trailAngle = Math.atan2(ep.vx || 0, ep.vy || 0);
                        for (let t = 1; t <= 3; t++) {
                            const trailDist = t * 8 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY - Math.cos(trailAngle) * trailDist;
                            const trailSize = (3.5 - t * 0.7) * scale;
                            ctx.fillStyle = `rgba(220, 220, 220, ${0.6 - t * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, Math.max(trailSize, 1), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } else if (ep.type === 'infantry_bullet') {
                        // Infantry bullet - tiny ball
                        const bulletSize = Math.max(1.5, 1.5 * scale);
                        ctx.fillStyle = '#ffe066';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, bulletSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (ep.type === 'tank_shell') {
                        // Tank shell - medium ball
                        const shellSize = Math.max(3, 4 * scale);
                        ctx.fillStyle = '#d0c8a0';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, shellSize, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (ep.type === 'sam_missile') {
                        // SAM missile - medium-large ball with smoke trail
                        const missileSize = Math.max(4, 5 * scale);
                        ctx.fillStyle = '#ff3300';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, missileSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Smoke trail as fading circles (different for launch vs track phase)
                        const trailAngle = ep.phase === 'launch' ? Math.PI : (ep.angle || 0);
                        for (let t = 1; t <= 3; t++) {
                            const trailDist = t * 8 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY - Math.cos(trailAngle) * trailDist;
                            const trailSize = (4 - t * 0.8) * scale;
                            ctx.fillStyle = `rgba(200, 200, 200, ${0.5 - t * 0.12})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, Math.max(trailSize, 1), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Flame at exhaust
                        const flameX = screenX + Math.sin(trailAngle) * 10 * scale;
                        const flameY = screenY - Math.cos(trailAngle) * 10 * scale;
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(flameX, flameY, Math.max(2.5 * scale, 1.5), 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Generic enemy projectile - ball with smoke trail
                        const missileSize = Math.max(4, 5 * scale);
                        ctx.fillStyle = '#ff3300';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, missileSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Smoke trail as fading circles
                        const trailAngle = ep.angle || 0;
                        for (let t = 1; t <= 3; t++) {
                            const trailDist = t * 7 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY - Math.cos(trailAngle) * trailDist;
                            const trailSize = (3.5 - t * 0.7) * scale;
                            ctx.fillStyle = `rgba(200, 200, 200, ${0.5 - t * 0.12})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, Math.max(trailSize, 1), 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
        }
        
        // ============================================
        // SCREEN FLASH EFFECT
        // ============================================
        function renderScreenFlash() {
            if (screenFlashTime > 0) {
                const alpha = Math.min(0.5, screenFlashTime / 200);
                const colorMap = {
                    red: '255, 0, 0',
                    white: '255, 255, 255',
                    yellow: '255, 240, 200'
                };
                const rgb = colorMap[screenFlashColor] || '255, 0, 0';
                ctx.fillStyle = `rgba(${rgb}, ${alpha})`;
                ctx.fillRect(0, 0, screenWidth, screenHeight);
            }
        }

        function renderMuzzleFlash() {
            if (muzzleFlashTime <= 0) return;

            const cx = screenWidth / 2;
            const cy = screenHeight / 2;
            const life = Math.max(0, muzzleFlashTime / 80);
            const intensity = Math.min(1, muzzleFlashIntensity);
            const radius = 60 + 50 * intensity;

            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
            gradient.addColorStop(0, `rgba(255, 255, 220, ${0.6 * life * intensity})`);
            gradient.addColorStop(0.4, `rgba(255, 240, 180, ${0.35 * life * intensity})`);
            gradient.addColorStop(1, 'rgba(255, 240, 180, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(cx - radius, cy - radius, radius * 2, radius * 2);
        }

        function renderDamageVignette() {
            if (damageVignetteTime <= 0) return;

            const life = Math.max(0, damageVignetteTime / 320);
            const intensity = damageVignetteIntensity * life;
            const gradient = ctx.createRadialGradient(
                screenWidth / 2, screenHeight / 2, screenHeight * 0.2,
                screenWidth / 2, screenHeight / 2, screenHeight * 0.8
            );
            gradient.addColorStop(0, 'rgba(255, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(120, 0, 0, ${0.55 * intensity})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, screenWidth, screenHeight);
        }
        
        // ============================================
        // NIGHT VISION EFFECT (GPU-accelerated)
        // Uses canvas compositing instead of per-pixel manipulation
        // ============================================
        function applyNightVisionEffect() {
            const weather = WEATHER_SETTINGS[weatherCondition];
            const ambient = weather.ambient;
            
            // Brightness boost based on darkness (darker = MUCH more boost)
            // Night vision should make dark scenes very visible
            const boostFactor = Math.min(4.0, Math.max(1.5, 1.5 / ambient));
            
            ctx.save();
            
            // Step 1: Brighten the image significantly (simulate light amplification)
            // Apply multiple passes for stronger effect
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = (boostFactor - 1) * 0.5;  // Strong brightness boost
            ctx.drawImage(canvas, 0, 0);
            
            // Second brightness pass for very dark scenes
            if (ambient < 0.4) {
                ctx.globalAlpha = 0.3;
                ctx.drawImage(canvas, 0, 0);
            }
            
            // Step 2: Apply green tint overlay
            // Use 'multiply' to tint colors toward green (lighter green for better visibility)
            ctx.globalCompositeOperation = 'multiply';
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = '#60ff60';  // Lighter green tint for better visibility
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            // Step 3: Boost contrast with overlay
            ctx.globalCompositeOperation = 'overlay';
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            // Step 4: Add screen blend for extra brightness on dark areas
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#003300';
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            ctx.restore();
            
            // Step 5: Add scanlines (every 4th line - less dense for cleaner look)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            for (let y = 0; y < screenHeight; y += 4) {
                ctx.fillRect(0, y, screenWidth, 1);
            }
            
            // Step 6: Add subtle noise/grain (fewer particles)
            ctx.fillStyle = 'rgba(0, 255, 0, 0.02)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * screenWidth;
                const y = Math.random() * screenHeight;
                ctx.fillRect(x, y, 2, 2);
            }
            
            // Step 7: Lighter vignette effect (less dark at edges)
            const gradient = ctx.createRadialGradient(
                screenWidth / 2, screenHeight / 2, screenHeight * 0.4,
                screenWidth / 2, screenHeight / 2, screenHeight * 0.9
            );
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.35)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, screenWidth, screenHeight);
            
            // Step 8: Green phosphor glow around edges
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.12)';
            ctx.lineWidth = 3;
            ctx.strokeRect(2, 2, screenWidth - 4, screenHeight - 4);
        }
        
        // ============================================
        // TERRAIN OCCLUSION CHECK
        // ============================================
        function isTargetOccluded(target, cam, dx, dy, ry) {
            // Check if target is below terrain at its position
            const targetTerrainHeight = getTerrainHeight(target.x, target.y);
            if (target.z < targetTerrainHeight) {
                return true;  // Target is underground
            }
            
            // Check line-of-sight occlusion with denser sampling
            const numSamples = Math.min(40, Math.max(10, Math.floor(ry / 10)));
            const targetHeight = (typeof target.hitHeight === 'number') ? target.hitHeight : target.size * 0.5;
            
            // Check occlusion for the BASE of the target (most important)
            const targetBaseZ = target.z;
            // Use very tight clearance - terrain must clearly be below line of sight
            const clearance = 2;
            
            for (let s = 1; s < numSamples; s++) {
                // Non-linear sampling: more samples near the target where occlusion matters most
                const linearT = s / numSamples;
                const t = linearT;  // Can use linearT * linearT for even more near-target density
                
                // Interpolate position along ray
                let sampleX = cam.x + dx * t;
                let sampleY = cam.y + dy * t;
                
                // Wrap coordinates
                sampleX = ((sampleX % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                sampleY = ((sampleY % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                
                const terrainAtSample = getTerrainHeight(sampleX, sampleY);
                
                // Check if terrain blocks line of sight to target BASE
                const expectedHeightToBase = cam.height + (targetBaseZ - cam.height) * t;
                
                if (terrainAtSample > expectedHeightToBase + clearance) {
                    return true;  // Terrain blocks view of target base
                }
            }
            
            // Additional check: sample terrain in a small area around the target
            // to catch cases where local terrain should occlude
            const checkRadius = 5;
            for (let ox = -checkRadius; ox <= checkRadius; ox += checkRadius) {
                for (let oy = -checkRadius; oy <= checkRadius; oy += checkRadius) {
                    let checkX = target.x + ox;
                    let checkY = target.y + oy;
                    checkX = ((checkX % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                    checkY = ((checkY % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                    
                    const nearbyTerrain = getTerrainHeight(checkX, checkY);
                    if (nearbyTerrain > target.z + targetHeight * 0.3) {
                        // Nearby terrain is significantly higher than target - likely occluded
                        // But only if that terrain is between camera and target
                        const tdx = checkX - cam.x;
                        const tdy = checkY - cam.y;
                        const dotProduct = tdx * dx + tdy * dy;
                        if (dotProduct > 0 && dotProduct < dx * dx + dy * dy) {
                            return true;
                        }
                    }
                }
            }
            
            return false;  // Target is visible
        }

        // Check if a projectile/explosion is occluded by terrain
        function isProjectileOccluded(obj, cam, dx, dy, ry) {
            // Quick check: is the object below terrain at its position?
            const terrainHeight = getTerrainHeight(obj.x, obj.y);
            if (obj.z < terrainHeight) {
                return true;
            }
            
            // Sample terrain along line of sight
            const numSamples = Math.min(15, Math.max(5, Math.floor(ry / 30)));
            const clearance = 2;
            
            for (let s = 1; s < numSamples; s++) {
                const t = s / numSamples;
                
                let sampleX = cam.x + dx * t;
                let sampleY = cam.y + dy * t;
                
                sampleX = ((sampleX % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                sampleY = ((sampleY % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                
                const terrainAtSample = getTerrainHeight(sampleX, sampleY);
                const expectedHeight = cam.height + (obj.z - cam.height) * t;
                
                if (terrainAtSample > expectedHeight + clearance) {
                    return true;
                }
            }
            
            return false;
        }

        // Check if a shadow on the ground is occluded by terrain between camera and shadow
        function isShadowOccluded(shadowX, shadowY, shadowZ, cam, dx, dy, ry) {
            // Sample terrain along the line from camera to shadow position
            const numSamples = Math.min(20, Math.max(5, Math.floor(ry / 20)));
            const clearance = 3;
            
            for (let s = 1; s < numSamples; s++) {
                const t = s / numSamples;
                
                // Interpolate position along ray
                let sampleX = cam.x + dx * t;
                let sampleY = cam.y + dy * t;
                
                // Wrap coordinates
                sampleX = ((sampleX % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                sampleY = ((sampleY % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                
                const terrainAtSample = getTerrainHeight(sampleX, sampleY);
                
                // Check if terrain blocks line of sight to shadow on ground
                const expectedHeight = cam.height + (shadowZ - cam.height) * t;
                
                if (terrainAtSample > expectedHeight + clearance) {
                    return true;  // Terrain blocks view of shadow
                }
            }
            
            return false;
        }

        const SHADOW_SUN_ANGLE = Math.PI * 0.35;

        function drawAircraftShadow(screenX, groundScreenY, size, alpha, camAngle = 0) {
            if (alpha <= 0 || size <= 0) return;
            const sunAngle = SHADOW_SUN_ANGLE - camAngle;
            const offsetX = Math.cos(sunAngle) * size * 0.6;
            const offsetY = Math.sin(sunAngle) * size * 0.35;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(screenX + offsetX, groundScreenY + offsetY, size * 0.9, size * 0.35, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function projectWorldToScreen(cam, worldX, worldY, worldZ, allowWrap = true) {
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            let dx = worldX - cam.x;
            let dy = worldY - cam.y;

            if (allowWrap) {
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
            }

            const rx = dx * cosAngle - dy * sinAngle;
            const ry = -dx * sinAngle - dy * cosAngle;
            if (ry <= 5 || ry >= cam.distance) return null;

            const scaleX = (screenWidth / 2) / ry;
            const scaleY = 240.0 / ry;
            const screenX = screenWidth / 2 + rx * scaleX;

            const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
            const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
            const screenY = (cam.height - worldZ) * scaleY + cam.horizon + bankOffset;

            return { screenX, screenY, scaleX, scaleY, ry, bankOffset };
        }

        // ============================================
        // TARGET RENDERING
        // ============================================
        function renderTargets(cam) {
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            const weather = WEATHER_SETTINGS[weatherCondition];
            const fogStart = weather.fogStart;
            const fogEnd = Math.min(cam.distance, fogStart + (cam.distance - fogStart) / (weather.fogDensity || 2));
            
            for (const target of targets) {
                if (target.destroyed) continue;
                
                // Calculate relative position to camera
                let dx = target.x - cam.x;
                let dy = target.y - cam.y;
                
                // Handle map wrapping for distance calculation
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Check if in front of camera
                if (ry > 10 && ry < cam.distance) {
                    const fogFactor = fogEnabled ? Math.min(1, Math.max(0, (ry - fogStart) / (fogEnd - fogStart))) : 0;
                    // Check terrain occlusion before rendering
                    if (isTargetOccluded(target, cam, dx, dy, ry)) {
                        continue;
                    }
                    // Project to screen - scale must match terrain FOV (NO zoom - canvas handles that)
                    // Terrain frustum spans -ry to +ry in rx at distance ry
                    // This maps to 0 to screenWidth, so scale = screenWidth/2/ry
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;
                    
                    // Apply bank tilt to target Y position (same as terrain)
                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const columnOffset = screenX - screenWidth / 2;
                    const bankOffset = columnOffset * bankTiltFactor;
                    // Base screen Y from projection
                    let screenY = (cam.height - target.z) * scaleY + cam.horizon + bankOffset;
                    
                    // Shift visual down so its CENTER aligns with aim point (target.z)
                    // Targets are drawn extending upward from y, so adding offset shifts drawing down
                    if (target.type === 'building') {
                        screenY += target.size * 0.9 * scaleY;  // Buildings are tall (1.8x size, so half = 0.9)
                    } else if (target.type === 'tank') {
                        screenY += target.size * 0.3 * scaleY;  // Tanks low profile
                    } else if (target.type === 'sam') {
                        screenY += target.size * 0.35 * scaleY; // SAM medium height
                    } else if (target.type === 'hangar') {
                        screenY += target.size * 0.6 * scaleY;
                    } else if (target.type === 'control_tower') {
                        screenY += target.size * 1.0 * scaleY;
                    } else if (target.type === 'barracks') {
                        screenY += target.size * 0.5 * scaleY;
                    } else if (target.type === 'fuel_depot') {
                        screenY += target.size * 0.4 * scaleY;
                    } else if (target.type === 'helipad') {
                        screenY += target.size * 0.1 * scaleY;
                    } else if (target.type === 'soldier') {
                        screenY += target.size * 0.25 * scaleY; // Soldier center mass
                    }
                    
                    const size = target.size * scaleY;
                    const isAircraft = target.domain === DOMAINS.AIR;
                    let groundScreenY = 0;
                    let altitude = 0;
                    if (isAircraft) {
                        const terrainHeight = getTerrainHeight(target.x, target.y);
                        altitude = target.z - terrainHeight;
                        groundScreenY = (cam.height - terrainHeight) * scaleY + cam.horizon + bankOffset;
                    }
                    
                    // Check if on screen
                    if (screenX > -size && screenX < screenWidth + size &&
                        screenY > -size && screenY < screenHeight + size) {
                        
                        // Draw target based on type (no shadow - causes floating look)
                        // Calculate health percent for damage visualization on buildings
                        const healthPercent = target.health / target.maxHealth;
                        const isStructure = target.domain === DOMAINS.STRUCTURE;
                        
                        if (target.type === 'tank') {
                            drawTank(screenX, screenY, size, target.color, target.ai?.heading || 0, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'building') {
                            const buildingColor = getDamagedBuildingColor(target.color, healthPercent);
                            drawBuilding(screenX, screenY, size, buildingColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'sam') {
                            drawSAMSite(screenX, screenY, size, target.color, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'hangar') {
                            const hangarColor = getDamagedBuildingColor(target.color, healthPercent);
                            drawHangar(screenX, screenY, size, hangarColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'control_tower') {
                            const towerColor = getDamagedBuildingColor(target.color, healthPercent);
                            drawControlTower(screenX, screenY, size, towerColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'barracks') {
                            const barracksColor = getDamagedBuildingColor(target.color, healthPercent);
                            drawBarracks(screenX, screenY, size, barracksColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'fuel_depot') {
                            const depotColor = getDamagedBuildingColor(target.color, healthPercent);
                            drawFuelDepot(screenX, screenY, size, depotColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'helipad') {
                            const helipadColor = getDamagedBuildingColor(target.color, healthPercent);
                            // Draw glow effect for friendly helipads (resupply points)
                            if (target.faction === FACTIONS.FRIENDLY || target.faction === 'friendly') {
                                drawResupplyGlow(screenX, screenY, size, fogFactor);
                            }
                            drawHelipad(screenX, screenY, size, helipadColor, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'soldier') {
                            drawSoldier(screenX, screenY, size, target.color, target.ai?.pose, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'sniper') {
                            // Snipers use soldier model but with different color and prone pose preference
                            const sniperPose = target.ai?.pose === 'shoot' ? 'shoot' : 'crouch';  // Snipers prefer crouched/prone
                            drawSoldier(screenX, screenY, size, target.color, sniperPose, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'air_fighter') {
                            drawFighterJet(screenX, screenY, size, target.color, target.ai?.heading || 0, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'air_transport') {
                            drawTransportPlane(screenX, screenY, size, target.color, target.ai?.heading || 0, fogFactor, weather.ambient, weather.skyColor);
                        } else if (target.type === 'air_attack_heli') {
                            drawAttackHelicopter(screenX, screenY, size, target.color, target.ai?.heading || 0, fogFactor, weather.ambient, weather.skyColor);
                        }

                        if (isAircraft) {
                            const altitudeFactor = Math.min(1, Math.max(0, altitude / 250));
                            const shadowAlpha = Math.max(0, 0.22 * (1 - fogFactor) * (1 - altitudeFactor * 0.7));
                            const shadowSize = Math.max(2, size * (0.85 - altitudeFactor * 0.3));
                            // Check if shadow position is occluded by terrain
                            const terrainHeight = getTerrainHeight(target.x, target.y);
                            const shadowOccluded = isShadowOccluded(target.x, target.y, terrainHeight, cam, dx, dy, ry);
                            if (!shadowOccluded && groundScreenY > -size && groundScreenY < screenHeight + size) {
                                drawAircraftShadow(screenX, groundScreenY, shadowSize, shadowAlpha, cam.angle);
                            }
                        }
                        
                        // Health bar
                        if (target.health < target.maxHealth) {
                            const healthPercent = target.health / target.maxHealth;
                            ctx.fillStyle = getSpriteColor('#333333', ry, cam);
                            ctx.fillRect(screenX - size/2, screenY - size - 10, size, 5);
                            const healthColor = healthPercent > 0.5 ? '#4aa04a' : healthPercent > 0.25 ? '#c9a83a' : '#a04a4a';
                            ctx.fillStyle = getSpriteColor(healthColor, ry, cam);
                            ctx.fillRect(screenX - size/2, screenY - size - 10, size * healthPercent, 5);
                        }
                    }
                }
            }
        }

        function renderAirstrikePlanes(cam) {
            if (airstrikeState.planesInbound.length === 0) return;
            const weather = WEATHER_SETTINGS[weatherCondition];
            const fogStart = weather.fogStart;
            const fogEnd = Math.min(cam.distance, fogStart + (cam.distance - fogStart) / (weather.fogDensity || 2));

            for (const plane of airstrikeState.planesInbound) {
                if (plane.destroyed) continue;
                const allowWrap = plane.x >= 0 && plane.x <= CONFIG.MAP_SIZE && plane.y >= 0 && plane.y <= CONFIG.MAP_SIZE;
                const projection = projectWorldToScreen(cam, plane.x, plane.y, plane.z, allowWrap);
                if (!projection) continue;

                const { screenX, screenY, scaleY, ry, bankOffset } = projection;
                const fogFactor = fogEnabled ? Math.min(1, Math.max(0, (ry - fogStart) / (fogEnd - fogStart))) : 0;
                const size = Math.max(8, 18 * scaleY);

                if (screenX > -size && screenX < screenWidth + size && screenY > -size && screenY < screenHeight + size) {
                    drawFriendlyAircraft(screenX, screenY, size, '#66ccff', plane.heading, fogFactor, weather.ambient, weather.skyColor);

                    const sampleX = ((plane.x % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                    const sampleY = ((plane.y % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                    const terrainHeight = getTerrainHeight(sampleX, sampleY);
                    const groundScreenY = (cam.height - terrainHeight) * scaleY + cam.horizon + bankOffset;
                    const altitude = plane.z - terrainHeight;
                    const altitudeFactor = Math.min(1, Math.max(0, altitude / 250));
                    const shadowAlpha = Math.max(0, 0.22 * (1 - fogFactor) * (1 - altitudeFactor * 0.7));
                    const shadowSize = Math.max(2, size * (0.85 - altitudeFactor * 0.3));

                    if (groundScreenY > -size && groundScreenY < screenHeight + size) {
                        drawAircraftShadow(screenX, groundScreenY, shadowSize, shadowAlpha, cam.angle);
                    }
                }
            }
        }

        function renderParkedHelicopter(cam) {
            if (gameMode !== GAME_MODES.DELTA || !playerState.heli.visible || playerState.heli.destroyed) return;

            const heli = playerState.heli;

            // Calculate relative position
            let dx = heli.x - cam.x;
            let dy = heli.y - cam.y;

            // Handle map wrapping
            if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
            if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
            if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
            if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

            // Rotate to camera space
            const cosAngle = Math.cos(cam.angle);
            const sinAngle = Math.sin(cam.angle);
            const rx = dx * cosAngle - dy * sinAngle;
            const ry = -dx * sinAngle - dy * cosAngle;

            if (ry > 5 && ry < cam.distance) {
                // Check terrain occlusion for parked helicopter
                if (isProjectileOccluded(heli, cam, dx, dy, ry)) {
                    return;
                }
                const scaleX = (screenWidth / 2) / ry;
                const scaleY = 240.0 / ry;
                const screenX = screenWidth / 2 + rx * scaleX;
                const screenY = (cam.height - heli.z) * scaleY + cam.horizon;

                const size = Math.max(12, 35 * scaleY);
                const fogFactor = Math.min(1, ry / cam.distance);
                const weather = WEATHER_SETTINGS[weatherCondition];

                drawHelicopter(screenX, screenY, size, '#6a7a7a', heli.angle, fogFactor, weather.ambient, weather.skyColor);  // Light gray for sleek Comanche/EVE style
            }
        }
        
        // ============================================
        // VEHICLE DRAWING FUNCTIONS
        // VoxelSpace/Comanche style: Detailed billboarded sprites
        // Bold silhouettes with pixel-art aesthetic
        // ============================================

        function normalizeHexColor(color) {
            if (!color) return '000000';
            let hex = color.replace('#', '').trim();
            if (hex.length === 3) {
                hex = hex.split('').map((c) => c + c).join('');
            }
            return hex.padEnd(6, '0').slice(0, 6);
        }

        function hexToRgb(color) {
            const hex = normalizeHexColor(color);
            return {
                r: parseInt(hex.substr(0, 2), 16),
                g: parseInt(hex.substr(2, 2), 16),
                b: parseInt(hex.substr(4, 2), 16)
            };
        }

        function rgbToHex(color) {
            const toHex = (value) => value.toString(16).padStart(2, '0');
            return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`;
        }

        // Blend two hex colors by factor (0 = color1, 1 = color2)
        function blendColors(color1, color2, factor) {
            const r1 = parseInt(color1.slice(1,3), 16);
            const g1 = parseInt(color1.slice(3,5), 16);
            const b1 = parseInt(color1.slice(5,7), 16);
            const r2 = parseInt(color2.slice(1,3), 16);
            const g2 = parseInt(color2.slice(3,5), 16);
            const b2 = parseInt(color2.slice(5,7), 16);
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
        }

        // Get damage-adjusted color for buildings (darken based on damage)
        function getDamagedBuildingColor(baseColor, healthPercent) {
            if (healthPercent >= 1.0) return baseColor;
            const damageFactor = 1 - healthPercent;  // 0 = full health, 1 = almost dead
            // Blend toward dark gray, max 60% darkening
            return blendColors(baseColor, '#2a2a2a', damageFactor * 0.6);
        }

        function rgbToCss(color) {
            return `rgb(${color.r}, ${color.g}, ${color.b})`;
        }

        function applyAmbientToHex(color, ambient) {
            const base = hexToRgb(color);
            return {
                r: Math.floor(base.r * ambient),
                g: Math.floor(base.g * ambient),
                b: Math.floor(base.b * ambient)
            };
        }

        function blendColorWithFog(color, factor, skyColor) {
            const skyR = skyColor & 0xFF;
            const skyG = (skyColor >> 8) & 0xFF;
            const skyB = (skyColor >> 16) & 0xFF;
            return {
                r: Math.floor(color.r + (skyR - color.r) * factor),
                g: Math.floor(color.g + (skyG - color.g) * factor),
                b: Math.floor(color.b + (skyB - color.b) * factor)
            };
        }

        function getSpriteColor(baseColor, distance, cam) {
            const weather = WEATHER_SETTINGS[weatherCondition];

            let color = applyAmbientToHex(baseColor, weather.ambient);

            const fogStart = weather.fogStart;
            const fogEnd = Math.min(cam.distance, fogStart + (cam.distance - fogStart) / (weather.fogDensity || 2));
            const fogFactor = fogEnabled ? Math.min(1, Math.max(0, (distance - fogStart) / (fogEnd - fogStart))) : 0;

            if (fogFactor > 0) {
                color = blendColorWithFog(color, fogFactor, weather.skyColor);
            }

            return rgbToCss(color);
        }

        function getSpriteColorWithFog(baseColor, fogFactor, ambient, skyColor) {
            let color = applyAmbientToHex(baseColor, ambient);
            if (fogFactor > 0) {
                color = blendColorWithFog(color, fogFactor, skyColor);
            }
            return rgbToCss(color);
        }

        function drawSoldier(x, y, size, color, pose = 'stand', fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 8);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            // Proportions - military figure with gear detail
            const headW = Math.max(2, Math.floor(s * 0.18));
            const headH = Math.max(2, Math.floor(s * 0.16));
            const helmetH = Math.max(1, Math.floor(s * 0.06));
            const torsoW = Math.max(3, Math.floor(s * 0.26));
            const torsoH = Math.max(4, Math.floor(s * 0.32));
            const legW = Math.max(2, Math.floor(s * 0.1));
            const legH = Math.max(3, Math.floor(s * 0.28));
            const armW = Math.max(1, Math.floor(s * 0.08));
            const armH = Math.max(2, Math.floor(s * 0.22));
            const bootH = Math.max(1, Math.floor(s * 0.06));
            const packW = Math.max(2, Math.floor(s * 0.14));
            const packH = Math.max(2, Math.floor(s * 0.18));
            const helmetRadius = Math.max(2, Math.floor(headW * 0.65));
            const vestH = Math.max(2, Math.floor(torsoH * 0.45));
            const kneeH = Math.max(1, Math.floor(legH * 0.18));
            const bootToeH = Math.max(1, Math.floor(bootH * 0.5));

            // Colors with proper shading
            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 20), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 35), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 10), fogFactor, ambient, skyColor);
            const skin = getSpriteColorWithFog('#8a6a5a', fogFactor, ambient, skyColor);
            const gear = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const gearDark = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
            const boot = getSpriteColorWithFog('#3a3020', fogFactor, ambient, skyColor);

            // Adjust positions based on pose
            const isCrouch = pose === 'crouch';
            const isShoot = pose === 'shoot';
            const crouchOffset = isCrouch ? Math.floor(s * 0.12) : 0;
            const legSpread = isCrouch ? Math.floor(s * 0.04) : Math.floor(s * 0.02);

            // Y positions (bottom-up construction)
            const bootY = iy - bootH + crouchOffset;
            const legY = bootY - legH + (isCrouch ? Math.floor(legH * 0.3) : 0);
            const torsoY = legY - torsoH + Math.floor(s * 0.04);
            const headY = torsoY - headH - helmetH + Math.floor(s * 0.02);
            const armY = torsoY + Math.floor(s * 0.02);
            const kneeY = legY + Math.floor(legH * 0.55);
            const vestY = torsoY + Math.floor(torsoH * 0.2);

            // Boots
            ctx.fillStyle = boot;
            ctx.fillRect(ix - legW - legSpread, bootY, legW + 1, bootH);
            ctx.fillRect(ix + legSpread - 1, bootY, legW + 1, bootH);
            ctx.fillStyle = gearDark;
            ctx.fillRect(ix - legW - legSpread, bootY + bootH - bootToeH, legW + 1, bootToeH);
            ctx.fillRect(ix + legSpread - 1, bootY + bootH - bootToeH, legW + 1, bootToeH);

            // Legs
            ctx.fillStyle = dark;
            ctx.fillRect(ix - legW - legSpread, legY, legW, legH);
            ctx.fillRect(ix + legSpread, legY, legW, legH);
            // Leg highlight
            ctx.fillStyle = base;
            ctx.fillRect(ix - legW - legSpread, legY, Math.max(1, Math.floor(legW * 0.4)), legH);

            // Knee pads
            ctx.fillStyle = gearDark;
            ctx.fillRect(ix - legW - legSpread, kneeY, legW, kneeH);
            ctx.fillRect(ix + legSpread, kneeY, legW, kneeH);

            // Torso
            ctx.fillStyle = base;
            ctx.fillRect(ix - Math.floor(torsoW / 2), torsoY, torsoW, torsoH);
            // Torso shadow (left side)
            ctx.fillStyle = dark;
            ctx.fillRect(ix - Math.floor(torsoW / 2), torsoY, Math.max(1, Math.floor(torsoW * 0.25)), torsoH);
            // Torso highlight (right side)
            ctx.fillStyle = highlight;
            ctx.fillRect(ix + Math.floor(torsoW / 2) - 1, torsoY, 1, torsoH);

            // Tactical vest/plate carrier
            ctx.fillStyle = gear;
            ctx.fillRect(ix - Math.floor(torsoW / 2) + 1, vestY, torsoW - 2, vestH);
            ctx.fillStyle = gearDark;
            ctx.fillRect(ix - Math.floor(torsoW / 2) + 1, vestY + Math.floor(vestH * 0.5), torsoW - 2, Math.max(1, Math.floor(vestH * 0.2)));
            ctx.fillRect(ix - 1, vestY, 2, vestH);

            // Backpack/gear
            ctx.fillStyle = darker;
            ctx.fillRect(ix - Math.floor(torsoW / 2) - packW + 1, torsoY + Math.floor(s * 0.04), packW, packH);
            ctx.fillStyle = gearDark;
            ctx.fillRect(ix - Math.floor(torsoW / 2) - packW + 1, torsoY + Math.floor(s * 0.04), Math.max(1, Math.floor(packW * 0.3)), packH);

            // Arms
            const armOffsetY = isShoot ? -Math.floor(s * 0.06) : 0;
            ctx.fillStyle = dark;
            ctx.fillRect(ix - Math.floor(torsoW / 2) - armW, armY + armOffsetY, armW, armH);
            ctx.fillRect(ix + Math.floor(torsoW / 2), armY + armOffsetY, armW, armH);

            // Helmet dome
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.arc(ix, headY + helmetH, helmetRadius, Math.PI, 0);
            ctx.lineTo(ix + helmetRadius, headY + helmetH + Math.floor(helmetH * 0.8));
            ctx.lineTo(ix - helmetRadius, headY + helmetH + Math.floor(helmetH * 0.8));
            ctx.closePath();
            ctx.fill();
            // Helmet rim
            ctx.fillStyle = gearDark;
            ctx.fillRect(ix - Math.floor(headW / 2) - 1, headY + helmetH, headW + 2, Math.max(1, Math.floor(helmetH * 0.6)));

            // Head/face
            ctx.fillStyle = skin;
            ctx.fillRect(ix - Math.floor(headW / 2), headY + helmetH, headW, headH);

            // Weapon (rifle shape)
            const weaponLen = Math.max(3, Math.floor(s * 0.4));
            const weaponH = Math.max(1, Math.floor(s * 0.05));
            const stockLen = Math.max(2, Math.floor(s * 0.12));
            const magH = Math.max(1, Math.floor(s * 0.08));

            if (isShoot) {
                // Weapon raised, pointing forward
                const weaponX = ix + Math.floor(torsoW / 2) + armW - 1;
                const weaponY = armY + armOffsetY + Math.floor(armH * 0.3);
                ctx.fillStyle = gear;
                ctx.fillRect(weaponX, weaponY, weaponLen, weaponH);
                // Stock
                ctx.fillStyle = gearDark;
                ctx.fillRect(weaponX - stockLen, weaponY - 1, stockLen, weaponH + 2);
                // Magazine
                ctx.fillRect(weaponX + Math.floor(weaponLen * 0.3), weaponY + weaponH, Math.max(1, Math.floor(s * 0.04)), magH);
                // Muzzle
                ctx.fillRect(weaponX + weaponLen, weaponY - 1, Math.max(1, Math.floor(s * 0.03)), weaponH + 2);
            } else {
                // Weapon at rest, angled down
                const weaponX = ix + Math.floor(torsoW / 2);
                const weaponY = armY + Math.floor(armH * 0.5);
                ctx.fillStyle = gear;
                ctx.fillRect(weaponX, weaponY, Math.floor(weaponLen * 0.7), weaponH);
                ctx.fillRect(weaponX + Math.floor(weaponLen * 0.2), weaponY + weaponH, weaponH, Math.floor(weaponLen * 0.4));
                // Stock
                ctx.fillStyle = gearDark;
                ctx.fillRect(weaponX - Math.floor(stockLen * 0.5), weaponY - 1, Math.floor(stockLen * 0.6), weaponH + 2);
                // Magazine
                ctx.fillRect(weaponX + Math.floor(weaponLen * 0.3), weaponY + weaponH, Math.max(1, Math.floor(s * 0.04)), magH);
                // Muzzle
                ctx.fillRect(weaponX + Math.floor(weaponLen * 0.7), weaponY - 1, Math.max(1, Math.floor(s * 0.03)), weaponH + 2);
            }
        }

        function drawHelicopter(x, y, size, color, heading, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 12);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            // Colors - military stealth helicopter palette
            const body = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 25), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 40), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 12), fogFactor, ambient, skyColor);
            const belly = getSpriteColorWithFog(darkenColor(color, 55), fogFactor, ambient, skyColor);
            const glass = getSpriteColorWithFog('#1a4a5a', fogFactor, ambient, skyColor);
            const glassHighlight = getSpriteColorWithFog('#3a7a9a', fogFactor, ambient, skyColor);
            const rotor = getSpriteColorWithFog('#3a3a3a', fogFactor, ambient, skyColor);
            const exhaust = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const weapon = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const weaponDark = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            // Determine view type
            const showFront = sinRel > 0.7;   // ~45° to ~135° - nose toward camera
            const showBack = sinRel < -0.7;   // ~225° to ~315° - tail toward camera
            const showSide = !showFront && !showBack;  // Side profile
            const facingRight = cosRel >= 0;  // For side view mirroring
            const dir = facingRight ? 1 : -1;

            // EVE support unit render pass (override)
            {
                if (showFront) {
                    ctx.save();
                    ctx.translate(ix, iy);

                    const fuseW = s * 0.3;
                    const fuseH = s * 0.6;
                    const shoulderW = s * 0.42;
                    const wingSpan = s * 0.85;
                    const rotorRadX = s * 0.8;
                    const rotorRadY = s * 0.2;

                    const rotorTime = performance.now() / 42;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.22;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 0.95, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.65;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.05));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 0.95 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;

                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.035, -fuseH * 0.78, s * 0.07, s * 0.2);
                    ctx.fillStyle = getSpriteColorWithFog('#2a3a3a', fogFactor, ambient, skyColor);
                    ctx.beginPath();
                    ctx.arc(0, -fuseH * 1.03, s * 0.1, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(-shoulderW * 0.7, -fuseH * 0.55);
                    ctx.lineTo(shoulderW * 0.7, -fuseH * 0.55);
                    ctx.lineTo(fuseW * 1.1, -fuseH * 0.05);
                    ctx.lineTo(fuseW * 0.9, fuseH * 0.52);
                    ctx.lineTo(-fuseW * 0.9, fuseH * 0.52);
                    ctx.lineTo(-fuseW * 1.1, -fuseH * 0.05);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = belly;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.7, fuseH * 0.05);
                    ctx.lineTo(fuseW * 0.7, fuseH * 0.05);
                    ctx.lineTo(fuseW * 0.55, fuseH * 0.55);
                    ctx.lineTo(-fuseW * 0.55, fuseH * 0.55);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = glass;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.4, -fuseH * 0.35);
                    ctx.lineTo(fuseW * 0.4, -fuseH * 0.35);
                    ctx.lineTo(fuseW * 0.32, fuseH * 0.05);
                    ctx.lineTo(-fuseW * 0.32, fuseH * 0.05);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = glassHighlight;
                    ctx.fillRect(-fuseW * 0.28, -fuseH * 0.28, fuseW * 0.2, s * 0.08);
                    ctx.fillRect(fuseW * 0.08, -fuseH * 0.28, fuseW * 0.2, s * 0.08);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-wingSpan * 0.45, -fuseH * 0.02, wingSpan * 0.3, s * 0.08);
                    ctx.fillRect(fuseW + s * 0.02, -fuseH * 0.02, wingSpan * 0.3, s * 0.08);

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.52, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = exhaust;
                    ctx.fillRect(-s * 0.02, fuseH * 0.52, s * 0.04, s * 0.12);

                    const wheelR = Math.max(1, Math.floor(s * 0.06));
                    ctx.fillStyle = darker;
                    ctx.fillRect(-fuseW - s * 0.05, fuseH * 0.3, s * 0.05, s * 0.18);
                    ctx.fillRect(fuseW, fuseH * 0.3, s * 0.05, s * 0.18);
                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.arc(-fuseW - s * 0.06, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                    ctx.arc(fuseW + s * 0.03, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                    return;
                }

                if (showBack) {
                    ctx.save();
                    ctx.translate(ix, iy);

                    const fuseW = s * 0.3;
                    const fuseH = s * 0.6;
                    const wingSpan = s * 0.85;
                    const rotorRadX = s * 0.8;
                    const rotorRadY = s * 0.2;

                    const rotorTime = performance.now() / 42;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.22;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 0.95, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.65;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.05));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 0.95 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;

                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.035, -fuseH * 0.78, s * 0.07, s * 0.2);

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.95, -fuseH * 0.55);
                    ctx.lineTo(fuseW * 0.95, -fuseH * 0.55);
                    ctx.lineTo(fuseW * 0.85, fuseH * 0.52);
                    ctx.lineTo(-fuseW * 0.85, fuseH * 0.52);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = belly;
                    ctx.fillRect(-fuseW * 0.65, fuseH * 0.05, fuseW * 1.3, fuseH * 0.45);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-wingSpan * 0.45, -fuseH * 0.02, wingSpan * 0.3, s * 0.08);
                    ctx.fillRect(fuseW + s * 0.02, -fuseH * 0.02, wingSpan * 0.3, s * 0.08);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-s * 0.05, fuseH * 0.35, s * 0.1, s * 0.35);
                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(0, fuseH * 0.5);
                    ctx.lineTo(-s * 0.14, fuseH * 0.88);
                    ctx.lineTo(s * 0.14, fuseH * 0.88);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = dark;
                    ctx.fillRect(-s * 0.32, fuseH * 0.7, s * 0.64, s * 0.06);

                    const fenRadBack = s * 0.15;
                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.74, fenRadBack * 1.18, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.74, fenRadBack * 0.82, 0, Math.PI * 2);
                    ctx.fill();
                    const fenTimeBack = performance.now() / 18;
                    ctx.strokeStyle = rotor;
                    ctx.lineWidth = Math.max(1, s * 0.015);
                    for (let i = 0; i < 8; i++) {
                        const fAngle = fenTimeBack + i * (Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, fuseH * 0.74);
                        ctx.lineTo(
                            Math.cos(fAngle) * fenRadBack * 0.7,
                            fuseH * 0.74 + Math.sin(fAngle) * fenRadBack * 0.7
                        );
                        ctx.stroke();
                    }
                    ctx.lineWidth = 1;
                    ctx.fillStyle = exhaust;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.74, fenRadBack * 0.18, 0, Math.PI * 2);
                    ctx.fill();

                    const wheelR = Math.max(1, Math.floor(s * 0.06));
                    ctx.fillStyle = darker;
                    ctx.fillRect(-fuseW - s * 0.08, fuseH * 0.12, s * 0.06, s * 0.35);
                    ctx.fillRect(fuseW + s * 0.02, fuseH * 0.12, s * 0.06, s * 0.35);
                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.arc(-fuseW - s * 0.06, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                    ctx.arc(fuseW + s * 0.05, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                    return;
                }

                if (showSide) {
                    ctx.save();
                    ctx.translate(ix, iy);
                    ctx.scale(dir, 1);

                    const fuseLen = s * 1.7;
                    const fuseH = s * 0.24;
                    const tailLen = s * 1.05;
                    const tailH = s * 0.08;
                    const tailRise = s * 0.1;
                    const finH = s * 0.3;
                    const skidStrut = Math.max(1, Math.floor(s * 0.03));

                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.35, -tailH * 0.4 - tailRise);
                    ctx.lineTo(-fuseLen * 0.35 - tailLen, -tailH * 0.2 - tailRise);
                    ctx.lineTo(-fuseLen * 0.35 - tailLen, tailH * 0.3 - tailRise);
                    ctx.lineTo(-fuseLen * 0.35, tailH * 0.5 - tailRise);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.35 - tailLen + s * 0.1, -tailH * 0.2 - tailRise);
                    ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.02, -finH - tailRise);
                    ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.12, -finH - tailRise);
                    ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.04, -tailH * 0.2 - tailRise);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = dark;
                    ctx.fillRect(-fuseLen * 0.35 - tailLen - s * 0.04, -tailRise, s * 0.26, s * 0.05);

                    const fenestronRadius = s * 0.16;
                    const fenestronX = -fuseLen * 0.35 - tailLen - s * 0.02;
                    const fenestronY = -finH + s * 0.12 - tailRise;
                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.arc(fenestronX, fenestronY, fenestronRadius * 1.22, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.arc(fenestronX, fenestronY, fenestronRadius * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    const fenTime = performance.now() / 18;
                    ctx.strokeStyle = rotor;
                    ctx.lineWidth = Math.max(1, s * 0.02);
                    for (let i = 0; i < 8; i++) {
                        const fAngle = fenTime + i * (Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(fenestronX, fenestronY);
                        ctx.lineTo(
                            fenestronX + Math.cos(fAngle) * fenestronRadius * 0.75,
                            fenestronY + Math.sin(fAngle) * fenestronRadius * 0.75
                        );
                        ctx.stroke();
                    }
                    ctx.lineWidth = 1;
                    ctx.fillStyle = exhaust;
                    ctx.beginPath();
                    ctx.arc(fenestronX, fenestronY, fenestronRadius * 0.22, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.45, -fuseH * 0.2);
                    ctx.lineTo(fuseLen * 0.55, 0);
                    ctx.lineTo(fuseLen * 0.45, fuseH * 0.35);
                    ctx.lineTo(-fuseLen * 0.35, fuseH * 0.5);
                    ctx.lineTo(-fuseLen * 0.35, -fuseH * 0.4);
                    ctx.lineTo(fuseLen * 0.2, -fuseH * 0.55);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = belly;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.35, fuseH * 0.15);
                    ctx.lineTo(-fuseLen * 0.35, fuseH * 0.5);
                    ctx.lineTo(-fuseLen * 0.35, fuseH * 0.28);
                    ctx.lineTo(fuseLen * 0.3, fuseH * 0.1);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = highlight;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.35, -fuseH * 0.25);
                    ctx.lineTo(fuseLen * 0.15, -fuseH * 0.55);
                    ctx.lineTo(-fuseLen * 0.2, -fuseH * 0.42);
                    ctx.lineTo(-fuseLen * 0.05, -fuseH * 0.22);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = glass;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.38, -fuseH * 0.18);
                    ctx.lineTo(fuseLen * 0.48, fuseH * 0.02);
                    ctx.lineTo(fuseLen * 0.34, fuseH * 0.24);
                    ctx.lineTo(fuseLen * 0.1, fuseH * 0.2);
                    ctx.lineTo(fuseLen * 0.08, -fuseH * 0.22);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = glassHighlight;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.36, -fuseH * 0.12);
                    ctx.lineTo(fuseLen * 0.42, fuseH * 0.02);
                    ctx.lineTo(fuseLen * 0.28, fuseH * 0.06);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = getSpriteColorWithFog('#2a3a3a', fogFactor, ambient, skyColor);
                    ctx.beginPath();
                    ctx.arc(0, -fuseH * 0.95, s * 0.07, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.05, -fuseH * 0.05);
                    ctx.lineTo(fuseLen * 0.05 - s * 0.45, -fuseH * 0.18);
                    ctx.lineTo(fuseLen * 0.05 - s * 0.45, fuseH * 0.02);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = darker;
                    ctx.fillRect(fuseLen * 0.05 - s * 0.4, fuseH * 0.04, s * 0.18, s * 0.08);

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.arc(fuseLen * 0.35, fuseH * 0.35, s * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = exhaust;
                    ctx.fillRect(fuseLen * 0.35, fuseH * 0.32, s * 0.16, s * 0.04);

                    const wheelR = Math.max(1, Math.floor(s * 0.06));
                    ctx.fillStyle = darker;
                    ctx.fillRect(fuseLen * 0.15, fuseH * 0.42, skidStrut, s * 0.16);
                    ctx.fillRect(-fuseLen * 0.12, fuseH * 0.42, skidStrut, s * 0.16);
                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.arc(fuseLen * 0.2, fuseH * 0.6, wheelR, 0, Math.PI * 2);
                    ctx.arc(-fuseLen * 0.08, fuseH * 0.6, wheelR, 0, Math.PI * 2);
                    ctx.fill();

                    const rotorTime = performance.now() / 42;
                    const rotorRadX = fuseLen * 0.75;
                    const rotorRadY = fuseLen * 0.22;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.25;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 0.72, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.06));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 0.72 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.04, -fuseH * 0.84, s * 0.08, s * 0.14);
                    ctx.fillStyle = exhaust;
                    ctx.beginPath();
                    ctx.arc(0, -fuseH * 0.86, s * 0.05, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                    return;
                }
            }

            // RHINO Tank Unit render pass (override)
            {
                if (showFront) {
                    ctx.save();
                    ctx.translate(ix, iy);

                    const fuseW = s * 0.5;
                    const fuseH = s * 0.45;
                    const rotorRadX = s * 0.9;
                    const rotorRadY = s * 0.3;

                    const rotorTime = performance.now() / 36;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.25;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 1.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.08));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 1.9 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;

                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.06, -fuseH * 1.7, s * 0.12, s * 0.35);

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 1.1, -fuseH * 0.2);
                    ctx.lineTo(-fuseW * 0.8, -fuseH * 1.05);
                    ctx.lineTo(fuseW * 0.8, -fuseH * 1.05);
                    ctx.lineTo(fuseW * 1.1, -fuseH * 0.2);
                    ctx.lineTo(fuseW * 0.9, fuseH * 0.55);
                    ctx.lineTo(-fuseW * 0.9, fuseH * 0.55);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.25, -fuseH * 0.1);
                    ctx.lineTo(0, fuseH * 0.1);
                    ctx.lineTo(fuseW * 0.25, -fuseH * 0.1);
                    ctx.lineTo(0, -fuseH * 0.3);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = glass;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.22, -fuseH * 0.55);
                    ctx.lineTo(fuseW * 0.22, -fuseH * 0.55);
                    ctx.lineTo(fuseW * 0.18, -fuseH * 0.25);
                    ctx.lineTo(-fuseW * 0.18, -fuseH * 0.25);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = glassHighlight;
                    ctx.fillRect(-fuseW * 0.14, -fuseH * 0.5, fuseW * 0.12, s * 0.08);

                    ctx.fillStyle = weapon;
                    ctx.fillRect(-fuseW - s * 0.08, -fuseH * 0.8, s * 0.12, s * 0.3);
                    ctx.fillRect(fuseW - s * 0.04, -fuseH * 0.8, s * 0.12, s * 0.3);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-fuseW - s * 0.45, -fuseH * 0.18, s * 0.45, s * 0.12);
                    ctx.fillRect(fuseW, -fuseH * 0.18, s * 0.45, s * 0.12);

                    ctx.fillStyle = weaponDark;
                    ctx.fillRect(-fuseW - s * 0.4, -fuseH * 0.38, s * 0.18, s * 0.28);
                    ctx.fillRect(fuseW + s * 0.22, -fuseH * 0.38, s * 0.18, s * 0.28);

                    ctx.fillStyle = weapon;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.58, s * 0.16, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = weaponDark;
                    ctx.fillRect(-s * 0.05, fuseH * 0.7, s * 0.04, s * 0.12);
                    ctx.fillRect(s * 0.01, fuseH * 0.7, s * 0.04, s * 0.12);

                    ctx.fillStyle = darker;
                    ctx.fillRect(-fuseW - s * 0.12, fuseH * 0.25, s * 0.1, s * 0.5);
                    ctx.fillRect(-fuseW - s * 0.18, fuseH * 0.7, s * 0.24, s * 0.06);
                    ctx.fillRect(fuseW + s * 0.02, fuseH * 0.25, s * 0.1, s * 0.5);
                    ctx.fillRect(fuseW - s * 0.06, fuseH * 0.7, s * 0.24, s * 0.06);

                    ctx.restore();
                    return;
                }

                if (showBack) {
                    ctx.save();
                    ctx.translate(ix, iy);

                    const fuseW = s * 0.5;
                    const fuseH = s * 0.45;
                    const rotorRadX = s * 0.9;
                    const rotorRadY = s * 0.3;

                    const rotorTime = performance.now() / 36;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.25;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 1.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.08));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 1.9 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;

                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.06, -fuseH * 1.7, s * 0.12, s * 0.35);

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(-fuseW * 0.95, -fuseH * 0.3);
                    ctx.lineTo(-fuseW * 0.7, -fuseH);
                    ctx.lineTo(fuseW * 0.7, -fuseH);
                    ctx.lineTo(fuseW * 0.95, -fuseH * 0.3);
                    ctx.lineTo(fuseW * 0.85, fuseH * 0.45);
                    ctx.lineTo(-fuseW * 0.85, fuseH * 0.45);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = weaponDark;
                    ctx.fillRect(-fuseW * 0.55, -fuseH * 0.55, s * 0.18, s * 0.12);
                    ctx.fillRect(fuseW * 0.37, -fuseH * 0.55, s * 0.18, s * 0.12);
                    ctx.fillStyle = getSpriteColorWithFog('#4a3a2f', fogFactor, ambient, skyColor);
                    ctx.fillRect(-fuseW * 0.5, -fuseH * 0.52, s * 0.08, s * 0.06);
                    ctx.fillRect(fuseW * 0.42, -fuseH * 0.52, s * 0.08, s * 0.06);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-fuseW - s * 0.4, -fuseH * 0.15, s * 0.4, s * 0.1);
                    ctx.fillRect(fuseW, -fuseH * 0.15, s * 0.4, s * 0.1);

                    ctx.fillStyle = dark;
                    ctx.fillRect(-s * 0.08, fuseH * 0.2, s * 0.16, s * 0.6);
                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(0, fuseH * 0.5);
                    ctx.lineTo(-s * 0.17, fuseH * 0.95);
                    ctx.lineTo(s * 0.17, fuseH * 0.95);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = dark;
                    ctx.fillRect(-s * 0.38, fuseH * 0.7, s * 0.76, s * 0.08);

                    const fenRadBack = s * 0.16;
                    ctx.fillStyle = weapon;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.73, fenRadBack * 1.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.73, fenRadBack * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    const fenTimeBack = performance.now() / 14;
                    ctx.strokeStyle = rotor;
                    ctx.lineWidth = Math.max(1, s * 0.02);
                    for (let i = 0; i < 8; i++) {
                        const fAngle = fenTimeBack + i * (Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(0, fuseH * 0.73);
                        ctx.lineTo(
                            Math.cos(fAngle) * fenRadBack * 0.72,
                            fuseH * 0.73 + Math.sin(fAngle) * fenRadBack * 0.72
                        );
                        ctx.stroke();
                    }
                    ctx.lineWidth = 1;
                    ctx.fillStyle = weaponDark;
                    ctx.beginPath();
                    ctx.arc(0, fuseH * 0.73, fenRadBack * 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = darker;
                    ctx.fillRect(-fuseW - s * 0.12, fuseH * 0.12, s * 0.1, s * 0.45);
                    ctx.fillRect(-fuseW - s * 0.2, fuseH * 0.52, s * 0.26, s * 0.07);
                    ctx.fillRect(fuseW + s * 0.02, fuseH * 0.12, s * 0.1, s * 0.45);
                    ctx.fillRect(fuseW - s * 0.06, fuseH * 0.52, s * 0.26, s * 0.07);

                    ctx.restore();
                    return;
                }

                if (showSide) {
                    ctx.save();
                    ctx.translate(ix, iy);
                    ctx.scale(dir, 1);

                    const fuseLen = s * 1.6;
                    const fuseH = s * 0.35;
                    const tailLen = s * 1.05;
                    const tailH = s * 0.12;
                    const finH = s * 0.32;
                    const wingSpan = s * 0.6;
                    const skidH = Math.max(1, Math.floor(s * 0.05));

                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.32, -tailH * 0.7);
                    ctx.lineTo(-fuseLen * 0.32 - tailLen, -tailH * 0.35);
                    ctx.lineTo(-fuseLen * 0.32 - tailLen, tailH * 0.35);
                    ctx.lineTo(-fuseLen * 0.32, tailH * 0.7);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.32 - tailLen + s * 0.12, -tailH * 0.35);
                    ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.02, -finH);
                    ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.16, -finH);
                    ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.06, -tailH * 0.35);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = dark;
                    ctx.fillRect(-fuseLen * 0.32 - tailLen - s * 0.08, -s * 0.04, s * 0.3, s * 0.08);

                    const enemyFenRadius = s * 0.16;
                    const enemyFenX = -fuseLen * 0.32 - tailLen - s * 0.02;
                    const enemyFenY = -finH + s * 0.12;
                    ctx.fillStyle = weaponDark;
                    ctx.beginPath();
                    ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 1.25, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 0.85, 0, Math.PI * 2);
                    ctx.fill();
                    const enemyFenTime = performance.now() / 14;
                    ctx.strokeStyle = rotor;
                    ctx.lineWidth = Math.max(1, s * 0.025);
                    for (let i = 0; i < 8; i++) {
                        const fAngle = enemyFenTime + i * (Math.PI / 4);
                        ctx.beginPath();
                        ctx.moveTo(enemyFenX, enemyFenY);
                        ctx.lineTo(
                            enemyFenX + Math.cos(fAngle) * enemyFenRadius * 0.75,
                            enemyFenY + Math.sin(fAngle) * enemyFenRadius * 0.75
                        );
                        ctx.stroke();
                    }
                    ctx.lineWidth = 1;
                    ctx.fillStyle = weaponDark;
                    ctx.beginPath();
                    ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 0.22, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.48, -fuseH * 0.08);
                    ctx.lineTo(fuseLen * 0.58, fuseH * 0.22);
                    ctx.lineTo(fuseLen * 0.46, fuseH * 0.55);
                    ctx.lineTo(-fuseLen * 0.32, fuseH * 0.6);
                    ctx.lineTo(-fuseLen * 0.35, -fuseH * 0.42);
                    ctx.lineTo(fuseLen * 0.08, -fuseH * 0.6);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = highlight;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.1, -fuseH * 0.25);
                    ctx.lineTo(fuseLen * 0.32, -fuseH * 0.25);
                    ctx.lineTo(fuseLen * 0.26, -fuseH * 0.45);
                    ctx.lineTo(fuseLen * 0.06, -fuseH * 0.45);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = dark;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.4, fuseH * 0.4);
                    ctx.lineTo(-fuseLen * 0.32, fuseH * 0.6);
                    ctx.lineTo(-fuseLen * 0.32, fuseH * 0.35);
                    ctx.lineTo(fuseLen * 0.34, fuseH * 0.25);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = darker;
                    ctx.fillRect(-fuseLen * 0.22, -fuseH * 0.7, s * 0.32, s * 0.14);
                    ctx.fillRect(-fuseLen * 0.3, -fuseH * 0.18, s * 0.14, s * 0.1);
                    ctx.fillRect(-fuseLen * 0.3, fuseH * 0.05, s * 0.14, s * 0.1);

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.05, -fuseH * 0.18);
                    ctx.lineTo(-fuseLen * 0.05 - wingSpan, -fuseH * 0.28);
                    ctx.lineTo(-fuseLen * 0.05 - wingSpan, -fuseH * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(-fuseLen * 0.05, fuseH * 0.22);
                    ctx.lineTo(-fuseLen * 0.05 - wingSpan, fuseH * 0.32);
                    ctx.lineTo(-fuseLen * 0.05 - wingSpan, fuseH * 0.14);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = weapon;
                    ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.7, -fuseH * 0.35, s * 0.24, s * 0.14);
                    ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.7, fuseH * 0.28, s * 0.26, s * 0.1);
                    ctx.fillStyle = weaponDark;
                    ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.62, fuseH * 0.36, s * 0.14, s * 0.04);

                    ctx.fillStyle = glass;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.38, -fuseH * 0.1);
                    ctx.lineTo(fuseLen * 0.46, fuseH * 0.12);
                    ctx.lineTo(fuseLen * 0.32, fuseH * 0.32);
                    ctx.lineTo(fuseLen * 0.18, fuseH * 0.26);
                    ctx.lineTo(fuseLen * 0.16, -fuseH * 0.12);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = glassHighlight;
                    ctx.beginPath();
                    ctx.moveTo(fuseLen * 0.36, 0);
                    ctx.lineTo(fuseLen * 0.4, fuseH * 0.12);
                    ctx.lineTo(fuseLen * 0.3, fuseH * 0.16);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = weapon;
                    ctx.beginPath();
                    ctx.arc(fuseLen * 0.38, fuseH * 0.48, s * 0.12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = weaponDark;
                    ctx.fillRect(fuseLen * 0.38, fuseH * 0.44, s * 0.24, s * 0.06);
                    ctx.fillRect(fuseLen * 0.6, fuseH * 0.42, s * 0.04, s * 0.1);

                    ctx.fillStyle = darker;
                    ctx.fillRect(fuseLen * 0.12, fuseH * 0.48, Math.max(1, s * 0.03), s * 0.2);
                    ctx.fillRect(-fuseLen * 0.18, fuseH * 0.48, Math.max(1, s * 0.03), s * 0.2);
                    ctx.fillRect(-fuseLen * 0.26, fuseH * 0.66, fuseLen * 0.5, skidH);

                    const rotorTime = performance.now() / 36;
                    const rotorRadX = fuseLen * 0.75;
                    const rotorRadY = fuseLen * 0.24;
                    ctx.fillStyle = rotor;
                    ctx.globalAlpha = 0.25;
                    ctx.beginPath();
                    ctx.ellipse(0, -fuseH * 0.78, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 0.7;
                    for (let i = 0; i < 4; i++) {
                        const angle = rotorTime + i * (Math.PI / 2);
                        const bx = Math.cos(angle) * rotorRadX;
                        const by = Math.sin(angle) * rotorRadY;
                        const bladeW = Math.max(2, Math.floor(s * 0.07));
                        ctx.fillRect(bx - bladeW / 2, -fuseH * 0.78 + by - 1, bladeW, 2);
                    }
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = darker;
                    ctx.fillRect(-s * 0.05, -fuseH * 0.9, s * 0.1, s * 0.16);
                    ctx.fillStyle = weapon;
                    ctx.beginPath();
                    ctx.arc(0, -fuseH * 0.92, s * 0.06, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                    return;
                }
            }

            // Strike plane render pass (override)
            {
                if (showFront) {
                    const wingSpan = s * 1.15;
                    const fuseH = s * 0.75;

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(ix, iy - fuseH * 0.55);
                    ctx.lineTo(ix - wingSpan, iy + fuseH * 0.1);
                    ctx.lineTo(ix - wingSpan * 0.2, iy + fuseH * 0.5);
                    ctx.lineTo(ix + wingSpan * 0.2, iy + fuseH * 0.5);
                    ctx.lineTo(ix + wingSpan, iy + fuseH * 0.1);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = highlight;
                    ctx.fillRect(ix - s * 0.1, iy - fuseH * 0.35, s * 0.2, fuseH * 0.7);

                    ctx.fillStyle = dark;
                    ctx.fillRect(ix - wingSpan * 0.55, iy + fuseH * 0.05, s * 0.22, s * 0.1);
                    ctx.fillRect(ix + wingSpan * 0.33, iy + fuseH * 0.05, s * 0.22, s * 0.1);

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(ix - s * 0.2, iy + fuseH * 0.1);
                    ctx.lineTo(ix - s * 0.3, iy + fuseH * 0.45);
                    ctx.lineTo(ix - s * 0.08, iy + fuseH * 0.45);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(ix + s * 0.2, iy + fuseH * 0.1);
                    ctx.lineTo(ix + s * 0.3, iy + fuseH * 0.45);
                    ctx.lineTo(ix + s * 0.08, iy + fuseH * 0.45);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = glass;
                    ctx.fillRect(ix - s * 0.08, iy - fuseH * 0.3, s * 0.16, s * 0.18);
                    ctx.fillStyle = glassHighlight;
                    ctx.fillRect(ix - s * 0.06, iy - fuseH * 0.26, s * 0.06, s * 0.08);
                    return;
                }

                if (showBack) {
                    const wingSpan = s * 1.15;
                    const fuseH = s * 0.75;

                    ctx.fillStyle = body;
                    ctx.beginPath();
                    ctx.moveTo(ix, iy - fuseH * 0.55);
                    ctx.lineTo(ix - wingSpan, iy + fuseH * 0.1);
                    ctx.lineTo(ix - wingSpan * 0.2, iy + fuseH * 0.5);
                    ctx.lineTo(ix + wingSpan * 0.2, iy + fuseH * 0.5);
                    ctx.lineTo(ix + wingSpan, iy + fuseH * 0.1);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = dark;
                    ctx.fillRect(ix - s * 0.1, iy - fuseH * 0.35, s * 0.2, fuseH * 0.7);

                    ctx.fillStyle = darker;
                    ctx.beginPath();
                    ctx.moveTo(ix, iy + fuseH * 0.15);
                    ctx.lineTo(ix - s * 0.12, iy + fuseH * 0.5);
                    ctx.lineTo(ix + s * 0.12, iy + fuseH * 0.5);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = exhaust;
                    ctx.beginPath();
                    ctx.arc(ix - s * 0.1, iy + fuseH * 0.38, s * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ix + s * 0.1, iy + fuseH * 0.38, s * 0.07, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = exhaustGlow;
                    ctx.beginPath();
                    ctx.arc(ix - s * 0.1, iy + fuseH * 0.4, s * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ix + s * 0.1, iy + fuseH * 0.4, s * 0.04, 0, Math.PI * 2);
                    ctx.fill();
                    return;
                }

                ctx.save();
                ctx.translate(ix, iy);
                ctx.scale(dir, 1);

                const fuseLen = s * 1.85;
                const fuseH = s * 0.22;

                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.55, 0);
                ctx.lineTo(fuseLen * 0.35, -fuseH * 0.9);
                ctx.lineTo(-fuseLen * 0.35, -fuseH * 0.7);
                ctx.lineTo(-fuseLen * 0.52, 0);
                ctx.lineTo(-fuseLen * 0.35, fuseH * 0.7);
                ctx.lineTo(fuseLen * 0.35, fuseH * 0.9);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = dark;
                ctx.fillRect(-fuseLen * 0.1, -s * 0.55, s * 0.6, s * 0.12);
                ctx.fillRect(-fuseLen * 0.1, s * 0.43, s * 0.6, s * 0.12);

                ctx.fillStyle = darker;
                ctx.fillRect(-fuseLen * 0.4, -s * 0.35, s * 0.18, s * 0.16);
                ctx.fillRect(-fuseLen * 0.4, s * 0.19, s * 0.18, s * 0.16);

                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(-fuseLen * 0.35, 0);
                ctx.lineTo(-fuseLen * 0.52, -s * 0.42);
                ctx.lineTo(-fuseLen * 0.52, 0);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = glass;
                ctx.beginPath();
                ctx.ellipse(fuseLen * 0.28, 0, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = glassHighlight;
                ctx.beginPath();
                ctx.ellipse(fuseLen * 0.3, -s * 0.02, s * 0.05, s * 0.03, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = darker;
                ctx.fillRect(-fuseLen * 0.18, -s * 0.45, s * 0.18, s * 0.06);
                ctx.fillRect(-fuseLen * 0.18, s * 0.39, s * 0.18, s * 0.06);

                ctx.fillStyle = exhaustGlow;
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.ellipse(-fuseLen * 0.54, 0, s * 0.08, s * 0.05, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                ctx.restore();
                return;
            }

            if (showFront) {
                // FRONT VIEW - Apache-style attack helicopter facing camera
                // Narrow fuselage, tandem cockpit, stub wings with weapons
                ctx.save();
                ctx.translate(ix, iy);

                const fuseW = s * 0.28;  // Narrow fuselage (attack helicopters are slim)
                const fuseH = s * 0.55;  // Taller than wide from front
                const wingSpan = s * 0.9;  // Stub wings extend wide
                const rotorRadX = s * 0.75;
                const rotorRadY = s * 0.2;

                // Rotor disc (top-down perspective ellipse above)
                const rotorTime = performance.now() / 40;
                ctx.fillStyle = rotor;
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.ellipse(0, -fuseH * 0.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Rotor blades
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 4; i++) {
                    const angle = rotorTime + (i * Math.PI / 2);
                    const bx = Math.cos(angle) * rotorRadX;
                    const by = Math.sin(angle) * rotorRadY;
                    const bladeW = Math.max(2, Math.floor(s * 0.05));
                    ctx.fillRect(bx - bladeW / 2, -fuseH * 0.9 + by - 1, bladeW, 2);
                }
                ctx.globalAlpha = 1.0;

                // Rotor mast
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.03, -fuseH * 0.75, s * 0.06, s * 0.18);
                
                // Mast-mounted sensor dome (Comanche/EVE style)
                ctx.fillStyle = getSpriteColorWithFog('#2a3a3a', fogFactor, ambient, skyColor);
                ctx.beginPath();
                ctx.arc(0, -fuseH * 1.0, s * 0.09, 0, Math.PI * 2);
                ctx.fill();
                // Sensor lens
                ctx.fillStyle = getSpriteColorWithFog('#1a2a2a', fogFactor, ambient, skyColor);
                ctx.beginPath();
                ctx.arc(0, -fuseH * 0.98, s * 0.045, Math.PI * 0.8, Math.PI * 2.2);
                ctx.fill();

                // Engine housings (on top sides of fuselage - sleeker for Comanche style)
                ctx.fillStyle = dark;
                ctx.fillRect(-fuseW - s * 0.12, -fuseH * 0.45, s * 0.14, s * 0.22);
                ctx.fillRect(fuseW - s * 0.02, -fuseH * 0.45, s * 0.14, s * 0.22);

                // Main fuselage body (narrow, angular)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(-fuseW, -fuseH * 0.5);  // Top left
                ctx.lineTo(fuseW, -fuseH * 0.5);   // Top right
                ctx.lineTo(fuseW * 1.1, fuseH * 0.1);  // Right side taper
                ctx.lineTo(fuseW * 0.7, fuseH * 0.5);  // Bottom right
                ctx.lineTo(-fuseW * 0.7, fuseH * 0.5); // Bottom left
                ctx.lineTo(-fuseW * 1.1, fuseH * 0.1); // Left side taper
                ctx.closePath();
                ctx.fill();

                // Fuselage panel lines
                ctx.strokeStyle = darker;
                ctx.lineWidth = Math.max(1, Math.floor(s * 0.02));
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.7, -fuseH * 0.2);
                ctx.lineTo(fuseW * 0.7, -fuseH * 0.25);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.6, fuseH * 0.2);
                ctx.lineTo(fuseW * 0.6, fuseH * 0.18);
                ctx.stroke();
                ctx.lineWidth = 1;

                // Fuselage center line (angular detail)
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(0, -fuseH * 0.5);
                ctx.lineTo(s * 0.03, fuseH * 0.3);
                ctx.lineTo(-s * 0.03, fuseH * 0.3);
                ctx.closePath();
                ctx.fill();

                // Cockpit canopy (single elongated window - tandem seating)
                ctx.fillStyle = glass;
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.5, -fuseH * 0.35);
                ctx.lineTo(fuseW * 0.5, -fuseH * 0.35);
                ctx.lineTo(fuseW * 0.4, fuseH * 0.15);
                ctx.lineTo(-fuseW * 0.4, fuseH * 0.15);
                ctx.closePath();
                ctx.fill();

                // Canopy frame (horizontal divider for tandem seats)
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW * 0.45, -fuseH * 0.12, fuseW * 0.9, s * 0.02);

                // Glass highlight
                ctx.fillStyle = glassHighlight;
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.35, -fuseH * 0.3);
                ctx.lineTo(0, -fuseH * 0.3);
                ctx.lineTo(-fuseW * 0.1, -fuseH * 0.15);
                ctx.lineTo(-fuseW * 0.35, -fuseH * 0.15);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(fuseW * 0.1, -fuseH * 0.28);
                ctx.lineTo(fuseW * 0.35, -fuseH * 0.2);
                ctx.lineTo(fuseW * 0.2, -fuseH * 0.1);
                ctx.closePath();
                ctx.fill();

                // Stub wings with weapon pylons
                ctx.fillStyle = dark;
                // Left wing
                ctx.fillRect(-wingSpan * 0.5, -fuseH * 0.05, wingSpan * 0.35, s * 0.08);
                // Right wing
                ctx.fillRect(fuseW + s * 0.02, -fuseH * 0.05, wingSpan * 0.35, s * 0.08);

                // Weapons on pylons (Hellfire missiles / rocket pods)
                ctx.fillStyle = darker;
                // Left pylon weapons
                ctx.fillRect(-wingSpan * 0.45, s * 0.02, s * 0.06, s * 0.15);
                ctx.fillRect(-wingSpan * 0.32, s * 0.02, s * 0.06, s * 0.15);
                // Right pylon weapons
                ctx.fillRect(wingSpan * 0.26, s * 0.02, s * 0.06, s * 0.15);
                ctx.fillRect(wingSpan * 0.39, s * 0.02, s * 0.06, s * 0.15);

                // Chin turret (TADS/PNVS sensor + gun)
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(-s * 0.08, fuseH * 0.35);
                ctx.lineTo(s * 0.08, fuseH * 0.35);
                ctx.lineTo(s * 0.05, fuseH * 0.55);
                ctx.lineTo(-s * 0.05, fuseH * 0.55);
                ctx.closePath();
                ctx.fill();

                // Gun barrel (30mm chain gun)
                ctx.fillStyle = exhaust;
                ctx.fillRect(-s * 0.02, fuseH * 0.5, s * 0.04, s * 0.12);

                // Landing gear (wheels)
                const wheelR = Math.max(1, Math.floor(s * 0.06));
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW - s * 0.04, fuseH * 0.3, s * 0.04, s * 0.16);
                ctx.fillRect(fuseW, fuseH * 0.3, s * 0.04, s * 0.16);
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.arc(-fuseW - s * 0.05, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                ctx.arc(fuseW + s * 0.02, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
                return;
            }

            if (showBack) {
                // BACK VIEW - Apache-style, tail/exhausts facing camera
                ctx.save();
                ctx.translate(ix, iy);

                const fuseW = s * 0.28;  // Match front view proportions
                const fuseH = s * 0.55;
                const wingSpan = s * 0.9;
                const rotorRadX = s * 0.75;
                const rotorRadY = s * 0.2;

                // Rotor disc
                const rotorTime = performance.now() / 40;
                ctx.fillStyle = rotor;
                ctx.globalAlpha = 0.2;
                ctx.beginPath();
                ctx.ellipse(0, -fuseH * 0.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Rotor blades
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < 4; i++) {
                    const angle = rotorTime + (i * Math.PI / 2);
                    const bx = Math.cos(angle) * rotorRadX;
                    const by = Math.sin(angle) * rotorRadY;
                    const bladeW = Math.max(2, Math.floor(s * 0.05));
                    ctx.fillRect(bx - bladeW / 2, -fuseH * 0.9 + by - 1, bladeW, 2);
                }
                ctx.globalAlpha = 1.0;

                // Rotor mast
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.03, -fuseH * 0.75, s * 0.06, s * 0.18);

                // Engine housings with exhausts
                ctx.fillStyle = dark;
                ctx.fillRect(-fuseW - s * 0.12, -fuseH * 0.45, s * 0.14, s * 0.22);
                ctx.fillRect(fuseW - s * 0.02, -fuseH * 0.45, s * 0.14, s * 0.22);
                
                // Engine exhausts (rectangular, glowing)
                ctx.fillStyle = exhaust;
                ctx.fillRect(-fuseW - s * 0.1, -fuseH * 0.35, s * 0.1, s * 0.12);
                ctx.fillRect(fuseW, -fuseH * 0.35, s * 0.1, s * 0.12);
                // Exhaust glow
                ctx.fillStyle = getSpriteColorWithFog('#5a4a3a', fogFactor, ambient, skyColor);
                ctx.fillRect(-fuseW - s * 0.08, -fuseH * 0.32, s * 0.06, s * 0.06);
                ctx.fillRect(fuseW + s * 0.02, -fuseH * 0.32, s * 0.06, s * 0.06);

                // Main fuselage body (narrow, angular - rear view)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(-fuseW, -fuseH * 0.5);
                ctx.lineTo(fuseW, -fuseH * 0.5);
                ctx.lineTo(fuseW * 1.1, fuseH * 0.1);
                ctx.lineTo(fuseW * 0.7, fuseH * 0.5);
                ctx.lineTo(-fuseW * 0.7, fuseH * 0.5);
                ctx.lineTo(-fuseW * 1.1, fuseH * 0.1);
                ctx.closePath();
                ctx.fill();

                // Fuselage rear panel detail
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW * 0.6, -fuseH * 0.4, fuseW * 1.2, s * 0.04);
                ctx.fillRect(-fuseW * 0.5, fuseH * 0.1, fuseW * 1.0, s * 0.03);

                // Stub wings (from behind)
                ctx.fillStyle = dark;
                ctx.fillRect(-wingSpan * 0.5, -fuseH * 0.05, wingSpan * 0.35, s * 0.08);
                ctx.fillRect(fuseW + s * 0.02, -fuseH * 0.05, wingSpan * 0.35, s * 0.08);

                // Weapons on pylons (rear view)
                ctx.fillStyle = darker;
                ctx.fillRect(-wingSpan * 0.45, s * 0.02, s * 0.06, s * 0.15);
                ctx.fillRect(-wingSpan * 0.32, s * 0.02, s * 0.06, s * 0.15);
                ctx.fillRect(wingSpan * 0.26, s * 0.02, s * 0.06, s * 0.15);
                ctx.fillRect(wingSpan * 0.39, s * 0.02, s * 0.06, s * 0.15);

                // Tail boom (foreshortened, going toward viewer)
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.05, fuseH * 0.35, s * 0.1, s * 0.35);

                // Tail fin (vertical stabilizer with fenestron)
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(0, fuseH * 0.5);
                ctx.lineTo(-s * 0.12, fuseH * 0.85);
                ctx.lineTo(s * 0.12, fuseH * 0.85);
                ctx.closePath();
                ctx.fill();
                
                // Horizontal stabilizer
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.28, fuseH * 0.68, s * 0.56, s * 0.05);

                // Fenestron (enclosed tail rotor) - seen from behind
                const fenRadBack = s * 0.12;
                // Shroud
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.72, fenRadBack * 1.15, 0, Math.PI * 2);
                ctx.fill();
                // Inner disc
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.72, fenRadBack * 0.8, 0, Math.PI * 2);
                ctx.fill();
                // Animated fan blades
                const fenTimeBack = performance.now() / 20;
                ctx.strokeStyle = rotor;
                ctx.lineWidth = Math.max(1, s * 0.015);
                for (let i = 0; i < 8; i++) {
                    const fAngle = fenTimeBack + (i * Math.PI / 4);
                    ctx.beginPath();
                    ctx.moveTo(0, fuseH * 0.72);
                    ctx.lineTo(
                        Math.cos(fAngle) * fenRadBack * 0.7,
                        fuseH * 0.72 + Math.sin(fAngle) * fenRadBack * 0.7
                    );
                    ctx.stroke();
                }
                ctx.lineWidth = 1;
                // Center hub
                ctx.fillStyle = exhaust;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.72, fenRadBack * 0.18, 0, Math.PI * 2);
                ctx.fill();

                // Landing gear (wheels)
                const wheelR = Math.max(1, Math.floor(s * 0.06));
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW - s * 0.08, fuseH * 0.12, s * 0.06, s * 0.35);
                ctx.fillRect(fuseW + s * 0.02, fuseH * 0.12, s * 0.06, s * 0.35);
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.arc(-fuseW - s * 0.06, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                ctx.arc(fuseW + s * 0.05, fuseH * 0.52, wheelR, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
                return;
            }

            // SIDE VIEW (existing code)
            ctx.save();
            ctx.translate(ix, iy);
            ctx.scale(dir, 1);

            // Proportions - sleek Comanche/Apache-like profile
            const fuseLen = s * 1.5;
            const fuseH = s * 0.28;
            const noseLen = s * 0.35;
            const tailLen = s * 0.9;
            const tailH = s * 0.1;
            const finH = s * 0.22;
            const skidH = Math.max(1, Math.floor(s * 0.04));
            const skidStrut = Math.max(1, Math.floor(s * 0.03));

            // Tail boom (tapered)
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.35, -tailH * 0.6);
            ctx.lineTo(-fuseLen * 0.35 - tailLen, -tailH * 0.3);
            ctx.lineTo(-fuseLen * 0.35 - tailLen, tailH * 0.3);
            ctx.lineTo(-fuseLen * 0.35, tailH * 0.6);
            ctx.closePath();
            ctx.fill();

            // Tail fin (vertical stabilizer)
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.35 - tailLen + s * 0.08, -tailH * 0.3);
            ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.04, -finH);
            ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.12, -finH);
            ctx.lineTo(-fuseLen * 0.35 - tailLen - s * 0.06, -tailH * 0.3);
            ctx.closePath();
            ctx.fill();

            // Horizontal stabilizer
            ctx.fillStyle = dark;
            ctx.fillRect(-fuseLen * 0.35 - tailLen - s * 0.02, -s * 0.02, s * 0.18, s * 0.04);

            // Fenestron (enclosed tail rotor) - Comanche/EVE style
            const fenestronRadius = s * 0.12;
            const fenestronX = -fuseLen * 0.35 - tailLen - s * 0.03;
            const fenestronY = -finH + s * 0.08;
            
            // Fenestron shroud (circular enclosure)
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.arc(fenestronX, fenestronY, fenestronRadius * 1.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner spinning fan
            ctx.fillStyle = body;
            ctx.beginPath();
            ctx.arc(fenestronX, fenestronY, fenestronRadius * 0.85, 0, Math.PI * 2);
            ctx.fill();
            
            // Fan blade hints (animated)
            const fenTime = performance.now() / 20;
            ctx.strokeStyle = rotor;
            ctx.lineWidth = Math.max(1, s * 0.02);
            for (let i = 0; i < 8; i++) {
                const fAngle = fenTime + (i * Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(fenestronX, fenestronY);
                ctx.lineTo(
                    fenestronX + Math.cos(fAngle) * fenestronRadius * 0.75,
                    fenestronY + Math.sin(fAngle) * fenestronRadius * 0.75
                );
                ctx.stroke();
            }
            ctx.lineWidth = 1;
            
            // Fenestron center hub
            ctx.fillStyle = exhaust;
            ctx.beginPath();
            ctx.arc(fenestronX, fenestronY, fenestronRadius * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Main fuselage (angular stealth shape)
            ctx.fillStyle = body;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.4, -fuseH * 0.2);  // Nose top
            ctx.lineTo(fuseLen * 0.5, fuseH * 0.1);   // Nose tip
            ctx.lineTo(fuseLen * 0.4, fuseH * 0.4);   // Nose bottom
            ctx.lineTo(-fuseLen * 0.35, fuseH * 0.5); // Rear bottom
            ctx.lineTo(-fuseLen * 0.35, -fuseH * 0.4);// Rear top
            ctx.lineTo(fuseLen * 0.15, -fuseH * 0.5); // Top spine
            ctx.closePath();
            ctx.fill();

            // Fuselage panel lines
            ctx.strokeStyle = darker;
            ctx.lineWidth = Math.max(1, Math.floor(s * 0.02));
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.25, -fuseH * 0.25);
            ctx.lineTo(-fuseLen * 0.05, -fuseH * 0.38);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.1, fuseH * 0.15);
            ctx.lineTo(-fuseLen * 0.2, fuseH * 0.25);
            ctx.stroke();
            ctx.lineWidth = 1;

            // Fuselage top highlight
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.35, -fuseH * 0.25);
            ctx.lineTo(fuseLen * 0.15, -fuseH * 0.5);
            ctx.lineTo(-fuseLen * 0.25, -fuseH * 0.4);
            ctx.lineTo(-fuseLen * 0.1, -fuseH * 0.25);
            ctx.closePath();
            ctx.fill();

            // Fuselage bottom shadow
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.4, fuseH * 0.35);
            ctx.lineTo(-fuseLen * 0.35, fuseH * 0.5);
            ctx.lineTo(-fuseLen * 0.35, fuseH * 0.3);
            ctx.lineTo(fuseLen * 0.35, fuseH * 0.2);
            ctx.closePath();
            ctx.fill();

            // Engine intake (top)
            ctx.fillStyle = darker;
            ctx.fillRect(-fuseLen * 0.15, -fuseH * 0.55, s * 0.2, s * 0.08);

            // Engine exhaust (rear sides)
            ctx.fillStyle = exhaust;
            ctx.fillRect(-fuseLen * 0.38, -fuseH * 0.2, s * 0.08, s * 0.12);
            ctx.fillRect(-fuseLen * 0.38, fuseH * 0.1, s * 0.08, s * 0.12);

            // Cockpit glass (angular, multi-pane)
            ctx.fillStyle = glass;
            // Main canopy
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.38, -fuseH * 0.15);
            ctx.lineTo(fuseLen * 0.48, fuseH * 0.05);
            ctx.lineTo(fuseLen * 0.35, fuseH * 0.25);
            ctx.lineTo(fuseLen * 0.1, fuseH * 0.2);
            ctx.lineTo(fuseLen * 0.08, -fuseH * 0.2);
            ctx.closePath();
            ctx.fill();
            // Glass highlight
            ctx.fillStyle = glassHighlight;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.36, -fuseH * 0.1);
            ctx.lineTo(fuseLen * 0.42, fuseH * 0.0);
            ctx.lineTo(fuseLen * 0.3, fuseH * 0.05);
            ctx.lineTo(fuseLen * 0.28, -fuseH * 0.1);
            ctx.closePath();
            ctx.fill();

            // Mast-mounted sensor hint (side silhouette)
            ctx.fillStyle = getSpriteColorWithFog('#2a3a3a', fogFactor, ambient, skyColor);
            ctx.beginPath();
            ctx.arc(0, -fuseH * 0.92, s * 0.06, 0, Math.PI * 2);
            ctx.fill();

            // Chin sensor/gun turret
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.arc(fuseLen * 0.35, fuseH * 0.35, s * 0.08, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = exhaust;
            ctx.fillRect(fuseLen * 0.35, fuseH * 0.32, s * 0.15, s * 0.04);

            // Landing gear (wheels)
            const wheelR = Math.max(1, Math.floor(s * 0.06));
            ctx.fillStyle = darker;
            // Struts
            ctx.fillRect(fuseLen * 0.16, fuseH * 0.4, skidStrut, s * 0.16);
            ctx.fillRect(-fuseLen * 0.14, fuseH * 0.4, skidStrut, s * 0.16);
            // Wheels
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.arc(fuseLen * 0.2, fuseH * 0.58, wheelR, 0, Math.PI * 2);
            ctx.arc(-fuseLen * 0.1, fuseH * 0.58, wheelR, 0, Math.PI * 2);
            ctx.fill();

            // Main rotor disc (perspective ellipse)
            const rotorTime = performance.now() / 40;
            const rotorRadX = fuseLen * 0.7;
            const rotorRadY = fuseLen * 0.2;
            
            // Rotor blur disc
            ctx.fillStyle = rotor;
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.ellipse(0, -fuseH * 0.7, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Rotor blades (4 blades)
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < 4; i++) {
                const angle = rotorTime + (i * Math.PI / 2);
                const bx = Math.cos(angle) * rotorRadX;
                const by = Math.sin(angle) * rotorRadY;
                const bladeW = Math.max(2, Math.floor(s * 0.06));
                ctx.fillRect(bx - bladeW / 2, -fuseH * 0.7 + by - 1, bladeW, 2);
            }
            ctx.globalAlpha = 1.0;

            // Rotor hub/mast
            ctx.fillStyle = darker;
            ctx.fillRect(-s * 0.04, -fuseH * 0.8, s * 0.08, s * 0.12);
            ctx.fillStyle = exhaust;
            ctx.beginPath();
            ctx.arc(0, -fuseH * 0.82, s * 0.05, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        function drawFighterJet(x, y, size, color, heading, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 12);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            // Colors - sleek fighter jet palette
            const body = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 25), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 40), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 15), fogFactor, ambient, skyColor);
            const glass = getSpriteColorWithFog('#2a4a6a', fogFactor, ambient, skyColor);
            const glassHighlight = getSpriteColorWithFog('#4a7a9a', fogFactor, ambient, skyColor);
            const exhaust = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
            const exhaustGlow = getSpriteColorWithFog('#4a3a2a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            // Determine view type
            const showFront = sinRel > 0.7;
            const showBack = sinRel < -0.7;
            const showSide = !showFront && !showBack;
            const facingRight = cosRel >= 0;
            const dir = facingRight ? 1 : -1;

            if (showFront) {
                // FRONT VIEW - delta wing silhouette, nose toward camera
                const wingSpan = s * 1.1;
                const fuseH = s * 0.8;

                // Main delta wing shape
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.5);           // Nose
                ctx.lineTo(ix - wingSpan, iy + fuseH * 0.15); // Left wing tip
                ctx.lineTo(ix - wingSpan * 0.3, iy + fuseH * 0.4); // Left wing root
                ctx.lineTo(ix, iy + fuseH * 0.5);           // Tail
                ctx.lineTo(ix + wingSpan * 0.3, iy + fuseH * 0.4); // Right wing root
                ctx.lineTo(ix + wingSpan, iy + fuseH * 0.15); // Right wing tip
                ctx.closePath();
                ctx.fill();

                // Wing top highlight
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.4);
                ctx.lineTo(ix - wingSpan * 0.7, iy + fuseH * 0.05);
                ctx.lineTo(ix - wingSpan * 0.3, iy + fuseH * 0.1);
                ctx.lineTo(ix, iy - fuseH * 0.2);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.4);
                ctx.lineTo(ix + wingSpan * 0.7, iy + fuseH * 0.05);
                ctx.lineTo(ix + wingSpan * 0.3, iy + fuseH * 0.1);
                ctx.lineTo(ix, iy - fuseH * 0.2);
                ctx.closePath();
                ctx.fill();

                // Fuselage spine
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 0.1, iy - fuseH * 0.35, s * 0.2, fuseH * 0.7);

                // Vertical tail fins (twin tails like F-22)
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(ix - s * 0.15, iy + fuseH * 0.2);
                ctx.lineTo(ix - s * 0.25, iy + fuseH * 0.5);
                ctx.lineTo(ix - s * 0.08, iy + fuseH * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(ix + s * 0.15, iy + fuseH * 0.2);
                ctx.lineTo(ix + s * 0.25, iy + fuseH * 0.5);
                ctx.lineTo(ix + s * 0.08, iy + fuseH * 0.45);
                ctx.closePath();
                ctx.fill();

                // Cockpit canopy (front view)
                ctx.fillStyle = glass;
                ctx.fillRect(ix - s * 0.08, iy - fuseH * 0.3, s * 0.16, s * 0.18);
                ctx.fillStyle = glassHighlight;
                ctx.fillRect(ix - s * 0.06, iy - fuseH * 0.28, s * 0.06, s * 0.08);

                // Air intakes (visible from front)
                ctx.fillStyle = darker;
                ctx.fillRect(ix - s * 0.2, iy - fuseH * 0.05, s * 0.08, s * 0.12);
                ctx.fillRect(ix + s * 0.12, iy - fuseH * 0.05, s * 0.08, s * 0.12);

                // Nose highlight
                ctx.fillStyle = highlight;
                ctx.fillRect(ix - s * 0.03, iy - fuseH * 0.5, s * 0.06, s * 0.1);

                return;
            }

            if (showBack) {
                // BACK VIEW - exhaust nozzles visible
                const wingSpan = s * 1.1;
                const fuseH = s * 0.8;

                // Main delta wing shape
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.5);           // Nose (away from camera)
                ctx.lineTo(ix - wingSpan, iy + fuseH * 0.15);
                ctx.lineTo(ix - wingSpan * 0.3, iy + fuseH * 0.4);
                ctx.lineTo(ix, iy + fuseH * 0.5);           // Tail (toward camera)
                ctx.lineTo(ix + wingSpan * 0.3, iy + fuseH * 0.4);
                ctx.lineTo(ix + wingSpan, iy + fuseH * 0.15);
                ctx.closePath();
                ctx.fill();

                // Wing shading (darker from back)
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.3);
                ctx.lineTo(ix - wingSpan * 0.8, iy + fuseH * 0.1);
                ctx.lineTo(ix - wingSpan * 0.4, iy + fuseH * 0.2);
                ctx.lineTo(ix, iy);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.3);
                ctx.lineTo(ix + wingSpan * 0.8, iy + fuseH * 0.1);
                ctx.lineTo(ix + wingSpan * 0.4, iy + fuseH * 0.2);
                ctx.lineTo(ix, iy);
                ctx.closePath();
                ctx.fill();

                // Fuselage spine
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 0.1, iy - fuseH * 0.35, s * 0.2, fuseH * 0.7);

                // Vertical tail fins
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(ix - s * 0.15, iy + fuseH * 0.2);
                ctx.lineTo(ix - s * 0.25, iy + fuseH * 0.5);
                ctx.lineTo(ix - s * 0.08, iy + fuseH * 0.45);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(ix + s * 0.15, iy + fuseH * 0.2);
                ctx.lineTo(ix + s * 0.25, iy + fuseH * 0.5);
                ctx.lineTo(ix + s * 0.08, iy + fuseH * 0.45);
                ctx.closePath();
                ctx.fill();

                // Engine exhausts (prominent from back - 2 circles with glow)
                ctx.fillStyle = exhaust;
                ctx.beginPath();
                ctx.arc(ix - s * 0.08, iy + fuseH * 0.42, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix + s * 0.08, iy + fuseH * 0.42, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                // Exhaust glow (inner)
                ctx.fillStyle = exhaustGlow;
                ctx.beginPath();
                ctx.arc(ix - s * 0.08, iy + fuseH * 0.44, s * 0.045, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix + s * 0.08, iy + fuseH * 0.44, s * 0.045, 0, Math.PI * 2);
                ctx.fill();
                // Hot core
                ctx.fillStyle = getSpriteColorWithFog('#6a5a4a', fogFactor, ambient, skyColor);
                ctx.beginPath();
                ctx.arc(ix - s * 0.08, iy + fuseH * 0.45, s * 0.025, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix + s * 0.08, iy + fuseH * 0.45, s * 0.025, 0, Math.PI * 2);
                ctx.fill();

                return;
            }

            if (showSide) {
                // Side view - F-16/F-22 like profile
                ctx.save();
                ctx.translate(ix, iy);
                ctx.scale(dir, 1);

                const fuseLen = s * 1.5;
                const fuseH = s * 0.22;
                const noseLen = s * 0.4;
                const wingChord = s * 0.35;

                // Main fuselage (sleek tapered shape)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.5, 0);           // Nose tip
                ctx.lineTo(fuseLen * 0.35, -fuseH * 0.6); // Nose top
                ctx.lineTo(-fuseLen * 0.1, -fuseH * 0.8); // Canopy peak
                ctx.lineTo(-fuseLen * 0.5, -fuseH * 0.5); // Rear top
                ctx.lineTo(-fuseLen * 0.55, 0);          // Exhaust
                ctx.lineTo(-fuseLen * 0.5, fuseH * 0.5);  // Rear bottom
                ctx.lineTo(fuseLen * 0.3, fuseH * 0.5);   // Belly
                ctx.lineTo(fuseLen * 0.45, fuseH * 0.2);  // Nose bottom
                ctx.closePath();
                ctx.fill();

                // Fuselage top highlight
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.4, -fuseH * 0.4);
                ctx.lineTo(-fuseLen * 0.1, -fuseH * 0.75);
                ctx.lineTo(-fuseLen * 0.4, -fuseH * 0.5);
                ctx.lineTo(-fuseLen * 0.2, -fuseH * 0.4);
                ctx.closePath();
                ctx.fill();

                // Fuselage bottom shadow
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.35, fuseH * 0.4);
                ctx.lineTo(-fuseLen * 0.45, fuseH * 0.5);
                ctx.lineTo(-fuseLen * 0.45, fuseH * 0.2);
                ctx.lineTo(fuseLen * 0.3, fuseH * 0.25);
                ctx.closePath();
                ctx.fill();

                // Wing (delta shape from side)
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.moveTo(-fuseLen * 0.05, fuseH * 0.3);
                ctx.lineTo(-fuseLen * 0.35, fuseH * 0.9);
                ctx.lineTo(-fuseLen * 0.4, fuseH * 0.9);
                ctx.lineTo(-fuseLen * 0.35, fuseH * 0.3);
                ctx.closePath();
                ctx.fill();

                // Horizontal stabilizer
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(-fuseLen * 0.4, fuseH * 0.2);
                ctx.lineTo(-fuseLen * 0.55, fuseH * 0.5);
                ctx.lineTo(-fuseLen * 0.55, fuseH * 0.35);
                ctx.lineTo(-fuseLen * 0.45, fuseH * 0.2);
                ctx.closePath();
                ctx.fill();

                // Vertical tail fin
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(-fuseLen * 0.35, -fuseH * 0.5);
                ctx.lineTo(-fuseLen * 0.5, -fuseH * 1.3);
                ctx.lineTo(-fuseLen * 0.55, -fuseH * 1.3);
                ctx.lineTo(-fuseLen * 0.55, -fuseH * 0.5);
                ctx.closePath();
                ctx.fill();

                // Cockpit canopy
                ctx.fillStyle = glass;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.3, -fuseH * 0.5);
                ctx.lineTo(-fuseLen * 0.1, -fuseH * 0.75);
                ctx.lineTo(-fuseLen * 0.15, -fuseH * 0.5);
                ctx.lineTo(fuseLen * 0.2, -fuseH * 0.35);
                ctx.closePath();
                ctx.fill();
                // Canopy frame
                ctx.fillStyle = darker;
                ctx.fillRect(fuseLen * 0.05, -fuseH * 0.65, s * 0.02, fuseH * 0.25);
                // Canopy highlight
                ctx.fillStyle = glassHighlight;
                ctx.beginPath();
                ctx.moveTo(fuseLen * 0.25, -fuseH * 0.45);
                ctx.lineTo(fuseLen * 0.1, -fuseH * 0.6);
                ctx.lineTo(fuseLen * 0.15, -fuseH * 0.45);
                ctx.closePath();
                ctx.fill();

                // Engine exhaust nozzle
                ctx.fillStyle = exhaust;
                ctx.fillRect(-fuseLen * 0.55, -fuseH * 0.3, s * 0.1, fuseH * 0.6);
                // Exhaust glow
                ctx.fillStyle = exhaustGlow;
                ctx.fillRect(-fuseLen * 0.58, -fuseH * 0.15, s * 0.05, fuseH * 0.3);

                // Air intake (under fuselage)
                ctx.fillStyle = darker;
                ctx.fillRect(fuseLen * 0.0, fuseH * 0.35, s * 0.2, s * 0.08);

                ctx.restore();
            }
        }

        function drawFriendlyAircraft(x, y, size, color, heading, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 12);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const body = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 25), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 40), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 12), fogFactor, ambient, skyColor);
            const glass = getSpriteColorWithFog('#2a4a6a', fogFactor, ambient, skyColor);
            const glassHighlight = getSpriteColorWithFog('#4a7a9a', fogFactor, ambient, skyColor);
            const exhaust = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
            const exhaustGlow = getSpriteColorWithFog('#ff7a2a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            const showFront = sinRel > 0.7;
            const showBack = sinRel < -0.7;
            const facingRight = cosRel >= 0;
            const dir = facingRight ? 1 : -1;

            if (showFront) {
                const wingSpan = s * 1.0;
                const fuseH = s * 0.7;

                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.5);
                ctx.lineTo(ix - wingSpan, iy + fuseH * 0.15);
                ctx.lineTo(ix, iy + fuseH * 0.5);
                ctx.lineTo(ix + wingSpan, iy + fuseH * 0.15);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = highlight;
                ctx.fillRect(ix - s * 0.08, iy - fuseH * 0.35, s * 0.16, fuseH * 0.7);

                ctx.fillStyle = dark;
                ctx.fillRect(ix - wingSpan * 0.55, iy + fuseH * 0.05, s * 0.18, s * 0.05);
                ctx.fillRect(ix + wingSpan * 0.37, iy + fuseH * 0.05, s * 0.18, s * 0.05);

                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(ix, iy + fuseH * 0.1);
                ctx.lineTo(ix - s * 0.08, iy + fuseH * 0.5);
                ctx.lineTo(ix + s * 0.08, iy + fuseH * 0.5);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = glass;
                ctx.fillRect(ix - s * 0.07, iy - fuseH * 0.25, s * 0.14, s * 0.16);
                ctx.fillStyle = glassHighlight;
                ctx.fillRect(ix - s * 0.05, iy - fuseH * 0.22, s * 0.05, s * 0.08);
                return;
            }

            if (showBack) {
                const wingSpan = s * 1.0;
                const fuseH = s * 0.7;

                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(ix, iy - fuseH * 0.5);
                ctx.lineTo(ix - wingSpan, iy + fuseH * 0.15);
                ctx.lineTo(ix, iy + fuseH * 0.5);
                ctx.lineTo(ix + wingSpan, iy + fuseH * 0.15);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 0.08, iy - fuseH * 0.35, s * 0.16, fuseH * 0.7);

                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(ix, iy + fuseH * 0.15);
                ctx.lineTo(ix - s * 0.1, iy + fuseH * 0.5);
                ctx.lineTo(ix + s * 0.1, iy + fuseH * 0.5);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = exhaust;
                ctx.beginPath();
                ctx.arc(ix, iy + fuseH * 0.38, s * 0.08, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = exhaustGlow;
                ctx.beginPath();
                ctx.arc(ix, iy + fuseH * 0.4, s * 0.05, 0, Math.PI * 2);
                ctx.fill();
                return;
            }

            // Side view
            ctx.save();
            ctx.translate(ix, iy);
            ctx.scale(dir, 1);

            const fuseLen = s * 1.8;
            const fuseH = s * 0.2;

            ctx.fillStyle = body;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.5, 0);
            ctx.lineTo(fuseLen * 0.3, -fuseH);
            ctx.lineTo(-fuseLen * 0.4, -fuseH * 0.8);
            ctx.lineTo(-fuseLen * 0.5, 0);
            ctx.lineTo(-fuseLen * 0.4, fuseH * 0.8);
            ctx.lineTo(fuseLen * 0.3, fuseH);
            ctx.closePath();
            ctx.fill();

            // Swept wings
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.05, -fuseH * 0.1);
            ctx.lineTo(-fuseLen * 0.25, -s * 0.6);
            ctx.lineTo(-fuseLen * 0.4, -fuseH * 0.4);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.05, fuseH * 0.1);
            ctx.lineTo(-fuseLen * 0.25, s * 0.6);
            ctx.lineTo(-fuseLen * 0.4, fuseH * 0.4);
            ctx.closePath();
            ctx.fill();

            // Tail fin
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.35, 0);
            ctx.lineTo(-fuseLen * 0.5, -s * 0.4);
            ctx.lineTo(-fuseLen * 0.5, 0);
            ctx.closePath();
            ctx.fill();

            // Cockpit
            ctx.fillStyle = glass;
            ctx.beginPath();
            ctx.ellipse(fuseLen * 0.25, 0, s * 0.12, s * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = glassHighlight;
            ctx.beginPath();
            ctx.ellipse(fuseLen * 0.28, -s * 0.02, s * 0.05, s * 0.03, 0, 0, Math.PI * 2);
            ctx.fill();

            // Under-wing pylons
            ctx.fillStyle = darker;
            ctx.fillRect(-fuseLen * 0.22, -s * 0.45, s * 0.16, s * 0.05);
            ctx.fillRect(-fuseLen * 0.22, s * 0.4, s * 0.16, s * 0.05);

            // Afterburner glow
            ctx.fillStyle = exhaustGlow;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.ellipse(-fuseLen * 0.52, 0, s * 0.08, s * 0.05, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            ctx.restore();
        }

        function drawTransportPlane(x, y, size, color, heading, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 18);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const body = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 20), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 35), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 10), fogFactor, ambient, skyColor);
            const windowColor = getSpriteColorWithFog('#4a6a8a', fogFactor, ambient, skyColor);
            const exhaust = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            // Determine view type
            const showFront = sinRel > 0.7;
            const showBack = sinRel < -0.7;
            const showSide = !showFront && !showBack;
            const facingRight = cosRel >= 0;
            const dir = facingRight ? 1 : -1;

            if (showFront) {
                // FRONT VIEW - wide fuselage, high wings
                // Wide fuselage (oval)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.ellipse(ix, iy, s * 0.3, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Fuselage highlight
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.ellipse(ix - s * 0.08, iy - s * 0.15, s * 0.12, s * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();

                // High wings spanning across
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 1.0, iy - s * 0.35, s * 2.0, s * 0.16);

                // Wing highlight
                ctx.fillStyle = highlight;
                ctx.fillRect(ix - s * 0.9, iy - s * 0.35, s * 1.8, s * 0.04);

                // Cockpit windows at top
                ctx.fillStyle = windowColor;
                ctx.fillRect(ix - s * 0.12, iy - s * 0.4, s * 0.24, s * 0.1);
                // Window frame
                ctx.fillStyle = darker;
                ctx.fillRect(ix - s * 0.01, iy - s * 0.4, s * 0.02, s * 0.1);

                // Engines on wings (4 engines)
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 0.7, iy - s * 0.3, s * 0.16, s * 0.22);
                ctx.fillRect(ix - s * 0.35, iy - s * 0.3, s * 0.16, s * 0.22);
                ctx.fillRect(ix + s * 0.19, iy - s * 0.3, s * 0.16, s * 0.22);
                ctx.fillRect(ix + s * 0.54, iy - s * 0.3, s * 0.16, s * 0.22);

                // Propeller discs (if prop plane) or intakes
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.ellipse(ix - s * 0.62, iy - s * 0.19, s * 0.08, s * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(ix - s * 0.27, iy - s * 0.19, s * 0.08, s * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(ix + s * 0.27, iy - s * 0.19, s * 0.08, s * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(ix + s * 0.62, iy - s * 0.19, s * 0.08, s * 0.08, 0, 0, Math.PI * 2);
                ctx.fill();

                // Landing gear (nose gear visible)
                ctx.fillStyle = darker;
                ctx.fillRect(ix - s * 0.04, iy + s * 0.4, s * 0.08, s * 0.15);
                ctx.beginPath();
                ctx.arc(ix, iy + s * 0.55, s * 0.06, 0, Math.PI * 2);
                ctx.fill();

                return;
            }

            if (showBack) {
                // BACK VIEW - rear cargo door, tail fin
                // Wide fuselage
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.ellipse(ix, iy, s * 0.3, s * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // High wings
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 1.0, iy - s * 0.35, s * 2.0, s * 0.16);

                // Tail fin (T-tail style)
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(ix, iy - s * 0.45);
                ctx.lineTo(ix - s * 0.08, iy - s * 0.9);
                ctx.lineTo(ix + s * 0.08, iy - s * 0.9);
                ctx.closePath();
                ctx.fill();

                // Horizontal stabilizer on top of tail
                ctx.fillStyle = dark;
                ctx.fillRect(ix - s * 0.4, iy - s * 0.92, s * 0.8, s * 0.08);

                // Rear cargo door area (darker rectangle)
                ctx.fillStyle = darker;
                ctx.fillRect(ix - s * 0.2, iy + s * 0.1, s * 0.4, s * 0.35);

                // Cargo door frame
                ctx.fillStyle = getSpriteColorWithFog('#3a3a3a', fogFactor, ambient, skyColor);
                ctx.fillRect(ix - s * 0.18, iy + s * 0.12, s * 0.36, s * 0.04);

                // Engines on wings (from back - show exhausts)
                ctx.fillStyle = exhaust;
                ctx.beginPath();
                ctx.arc(ix - s * 0.62, iy - s * 0.19, s * 0.07, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix - s * 0.27, iy - s * 0.19, s * 0.07, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix + s * 0.27, iy - s * 0.19, s * 0.07, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(ix + s * 0.62, iy - s * 0.19, s * 0.07, 0, Math.PI * 2);
                ctx.fill();

                return;
            }

            if (showSide) {
                ctx.save();
                ctx.translate(ix, iy);
                ctx.scale(dir, 1);

                // Large fuselage
                ctx.fillStyle = body;
                ctx.fillRect(-s * 0.95, -s * 0.22, s * 1.9, s * 0.44);

                // Nose
                ctx.beginPath();
                ctx.moveTo(s * 0.95, -s * 0.18);
                ctx.lineTo(s * 1.1, 0);
                ctx.lineTo(s * 0.95, s * 0.18);
                ctx.closePath();
                ctx.fill();

                // High wing
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.2, -s * 0.38, s * 0.8, s * 0.12);

                // Tail + fin
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 1.05, -s * 0.5, s * 0.2, s * 0.35);
                ctx.fillRect(-s * 1.05, -s * 0.35, s * 0.45, s * 0.12);

                // Windows
                ctx.fillStyle = windowColor;
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(-s * 0.5 + i * s * 0.22, -s * 0.12, s * 0.1, s * 0.08);
                }

                // Engines
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.05, -s * 0.1, s * 0.16, s * 0.12);
                ctx.fillRect(s * 0.18, -s * 0.1, s * 0.16, s * 0.12);
                ctx.fillRect(s * 0.41, -s * 0.1, s * 0.16, s * 0.12);

                ctx.restore();
            }
        }

        function drawAttackHelicopter(x, y, size, color, heading, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 14);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            // Colors - aggressive attack helicopter palette (slightly different from player)
            const body = getSpriteColorWithFog(darkenColor(color, 35), fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 50), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 65), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 4), fogFactor, ambient, skyColor);
            const glass = getSpriteColorWithFog('#122a2a', fogFactor, ambient, skyColor);
            const glassHighlight = getSpriteColorWithFog('#2f5a5a', fogFactor, ambient, skyColor);
            const rotor = getSpriteColorWithFog('#3a3a3a', fogFactor, ambient, skyColor);
            const weapon = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const weaponDark = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            // Determine view type
            const showFront = sinRel > 0.7;
            const showBack = sinRel < -0.7;
            const showSide = !showFront && !showBack;
            const facingRight = cosRel >= 0;
            const dir = facingRight ? 1 : -1;

            if (showFront) {
                // FRONT VIEW - nose/cockpit facing camera (Apache-style)
                ctx.save();
                ctx.translate(ix, iy);

                const fuseW = s * 0.45;
                const fuseH = s * 0.4;
                const rotorRadX = s * 0.85;
                const rotorRadY = s * 0.28;

                // Rotor disc
                const rotorTime = performance.now() / 38;
                ctx.fillStyle = rotor;
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.ellipse(0, -fuseH * 1.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 0.7;
                for (let i = 0; i < 4; i++) {
                    const angle = rotorTime + (i * Math.PI / 2);
                    const bx = Math.cos(angle) * rotorRadX;
                    const by = Math.sin(angle) * rotorRadY;
                    const bladeW = Math.max(2, Math.floor(s * 0.07));
                    ctx.fillRect(bx - bladeW / 2, -fuseH * 1.9 + by - 1, bladeW, 2);
                }
                ctx.globalAlpha = 1.0;

                // Rotor mast
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.05, -fuseH * 1.7, s * 0.1, s * 0.35);

                // Engine housings (LARGER bulges for RHINO aggressive look)
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.28, -fuseH * 1.35, s * 0.56, s * 0.2);
                // Side engine intakes (more prominent)
                ctx.fillStyle = weapon;
                ctx.fillRect(-fuseW - s * 0.08, -fuseH * 0.9, s * 0.12, s * 0.25);
                ctx.fillRect(fuseW - s * 0.04, -fuseH * 0.9, s * 0.12, s * 0.25);

                // Main fuselage (WIDER, more angular for RHINO)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(-fuseW * 1.1, -fuseH * 0.25);  // Wider top
                ctx.lineTo(-fuseW * 0.8, -fuseH * 1.05);
                ctx.lineTo(fuseW * 0.8, -fuseH * 1.05);
                ctx.lineTo(fuseW * 1.1, -fuseH * 0.25);   // Wider top
                ctx.lineTo(fuseW * 0.9, fuseH * 0.55);
                ctx.lineTo(-fuseW * 0.9, fuseH * 0.55);
                ctx.closePath();
                ctx.fill();

                // Fuselage highlight (subtle for dark RHINO look)
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.4, -fuseH * 0.95);
                ctx.lineTo(fuseW * 0.4, -fuseH * 0.95);
                ctx.lineTo(fuseW * 0.25, -fuseH * 0.55);
                ctx.lineTo(-fuseW * 0.25, -fuseH * 0.55);
                ctx.closePath();
                ctx.fill();

                // Armored nose plate
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(-fuseW * 0.18, -fuseH * 0.15);
                ctx.lineTo(0, fuseH * 0.05);
                ctx.lineTo(fuseW * 0.18, -fuseH * 0.15);
                ctx.lineTo(0, -fuseH * 0.25);
                ctx.closePath();
                ctx.fill();

                // Stub wings with weapons (LARGER for RHINO)
                ctx.fillStyle = body;
                // Left wing
                ctx.fillRect(-fuseW - s * 0.42, -fuseH * 0.18, s * 0.42, s * 0.12);
                // Right wing
                ctx.fillRect(fuseW, -fuseH * 0.18, s * 0.42, s * 0.12);

                // Weapon pylons (LARGER and MORE VISIBLE for RHINO - intimidating)
                ctx.fillStyle = weapon;
                // Left pylon with multiple weapons
                ctx.fillRect(-fuseW - s * 0.38, -fuseH * 0.4, s * 0.14, s * 0.25);
                ctx.fillRect(-fuseW - s * 0.22, -fuseH * 0.35, s * 0.1, s * 0.2);
                // Right pylon with multiple weapons
                ctx.fillRect(fuseW + s * 0.24, -fuseH * 0.4, s * 0.14, s * 0.25);
                ctx.fillRect(fuseW + s * 0.12, -fuseH * 0.35, s * 0.1, s * 0.2);
                // Additional missile rails (visible from front)
                ctx.fillStyle = weaponDark;
                ctx.fillRect(-fuseW - s * 0.36, fuseH * 0.0, s * 0.08, s * 0.18);
                ctx.fillRect(fuseW + s * 0.28, fuseH * 0.0, s * 0.08, s * 0.18);

                // Cockpit glass (SMALLER/more armored for RHINO - less exposed)
                ctx.fillStyle = glass;
                ctx.beginPath();
                ctx.ellipse(0, -fuseH * 0.15, fuseW * 0.35, fuseH * 0.35, 0, 0, Math.PI * 2);
                ctx.fill();
                // Armored cockpit frame
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW * 0.4, -fuseH * 0.3, fuseW * 0.8, s * 0.03);
                ctx.fillStyle = glassHighlight;
                ctx.beginPath();
                ctx.ellipse(-fuseW * 0.08, -fuseH * 0.35, fuseW * 0.1, fuseH * 0.1, 0, 0, Math.PI * 2);
                ctx.fill();

                // Chin gun turret (LARGER for RHINO)
                ctx.fillStyle = weapon;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.55, s * 0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = weaponDark;
                // Dual gun barrels
                ctx.fillRect(-s * 0.04, fuseH * 0.65, s * 0.03, s * 0.12);
                ctx.fillRect(s * 0.01, fuseH * 0.65, s * 0.03, s * 0.12);

                // Landing skids (HEAVIER for RHINO)
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW - s * 0.12, fuseH * 0.25, s * 0.1, s * 0.5);
                ctx.fillRect(-fuseW - s * 0.18, fuseH * 0.7, s * 0.22, s * 0.06);
                ctx.fillRect(fuseW + s * 0.02, fuseH * 0.25, s * 0.1, s * 0.5);
                ctx.fillRect(fuseW - s * 0.04, fuseH * 0.7, s * 0.22, s * 0.06);

                ctx.restore();
                return;
            }

            if (showBack) {
                // BACK VIEW - tail/exhausts facing camera
                ctx.save();
                ctx.translate(ix, iy);

                const fuseW = s * 0.45;
                const fuseH = s * 0.4;
                const rotorRadX = s * 0.85;
                const rotorRadY = s * 0.28;

                // Rotor disc
                const rotorTime = performance.now() / 38;
                ctx.fillStyle = rotor;
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.ellipse(0, -fuseH * 1.9, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 0.7;
                for (let i = 0; i < 4; i++) {
                    const angle = rotorTime + (i * Math.PI / 2);
                    const bx = Math.cos(angle) * rotorRadX;
                    const by = Math.sin(angle) * rotorRadY;
                    const bladeW = Math.max(2, Math.floor(s * 0.07));
                    ctx.fillRect(bx - bladeW / 2, -fuseH * 1.9 + by - 1, bladeW, 2);
                }
                ctx.globalAlpha = 1.0;

                // Rotor mast
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.05, -fuseH * 1.7, s * 0.1, s * 0.35);

                // Engine housing
                ctx.fillStyle = darker;
                ctx.fillRect(-s * 0.22, -fuseH * 1.3, s * 0.44, s * 0.18);

                // Main fuselage (back view)
                ctx.fillStyle = body;
                ctx.beginPath();
                ctx.moveTo(-fuseW, -fuseH * 0.3);
                ctx.lineTo(-fuseW * 0.7, -fuseH);
                ctx.lineTo(fuseW * 0.7, -fuseH);
                ctx.lineTo(fuseW, -fuseH * 0.3);
                ctx.lineTo(fuseW * 0.8, fuseH * 0.4);
                ctx.lineTo(-fuseW * 0.8, fuseH * 0.4);
                ctx.closePath();
                ctx.fill();

                // Engine exhausts (prominent from back)
                ctx.fillStyle = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
                ctx.beginPath();
                ctx.arc(-fuseW * 0.4, -fuseH * 0.5, s * 0.1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(fuseW * 0.4, -fuseH * 0.5, s * 0.1, 0, Math.PI * 2);
                ctx.fill();
                // Exhaust glow
                ctx.fillStyle = getSpriteColorWithFog('#5a4a3a', fogFactor, ambient, skyColor);
                ctx.beginPath();
                ctx.arc(-fuseW * 0.4, -fuseH * 0.5, s * 0.05, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(fuseW * 0.4, -fuseH * 0.5, s * 0.05, 0, Math.PI * 2);
                ctx.fill();

                // Stub wings (from back)
                ctx.fillStyle = body;
                ctx.fillRect(-fuseW - s * 0.35, -fuseH * 0.15, s * 0.35, s * 0.1);
                ctx.fillRect(fuseW, -fuseH * 0.15, s * 0.35, s * 0.1);

                // Weapon pylons
                ctx.fillStyle = weapon;
                ctx.fillRect(-fuseW - s * 0.28, -fuseH * 0.3, s * 0.1, s * 0.18);
                ctx.fillRect(fuseW + s * 0.18, -fuseH * 0.3, s * 0.1, s * 0.18);

                // Tail boom
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.07, fuseH * 0.2, s * 0.14, s * 0.55);

                // Tail fin
                ctx.fillStyle = darker;
                ctx.beginPath();
                ctx.moveTo(0, fuseH * 0.5);
                ctx.lineTo(-s * 0.15, fuseH * 0.9);
                ctx.lineTo(s * 0.15, fuseH * 0.9);
                ctx.closePath();
                ctx.fill();

                // Horizontal stabilizer (heavier for RHINO)
                ctx.fillStyle = dark;
                ctx.fillRect(-s * 0.35, fuseH * 0.62, s * 0.7, s * 0.08);

                // Fenestron (enclosed tail rotor) - RHINO style back view
                const fenRadEnemyBack = s * 0.14;
                // Heavy shroud
                ctx.fillStyle = weapon;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.7, fenRadEnemyBack * 1.2, 0, Math.PI * 2);
                ctx.fill();
                // Inner disc
                ctx.fillStyle = dark;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.7, fenRadEnemyBack * 0.82, 0, Math.PI * 2);
                ctx.fill();
                // Animated fan blades (fast spin)
                const fenTimeEnemyBack = performance.now() / 15;
                ctx.strokeStyle = rotor;
                ctx.lineWidth = Math.max(1, s * 0.02);
                for (let i = 0; i < 8; i++) {
                    const fAngle = fenTimeEnemyBack + (i * Math.PI / 4);
                    ctx.beginPath();
                    ctx.moveTo(0, fuseH * 0.7);
                    ctx.lineTo(
                        Math.cos(fAngle) * fenRadEnemyBack * 0.72,
                        fuseH * 0.7 + Math.sin(fAngle) * fenRadEnemyBack * 0.72
                    );
                    ctx.stroke();
                }
                ctx.lineWidth = 1;
                // Center hub
                ctx.fillStyle = weaponDark;
                ctx.beginPath();
                ctx.arc(0, fuseH * 0.7, fenRadEnemyBack * 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Landing skids (heavier for RHINO)
                ctx.fillStyle = darker;
                ctx.fillRect(-fuseW - s * 0.12, fuseH * 0.12, s * 0.1, s * 0.45);
                ctx.fillRect(-fuseW - s * 0.18, fuseH * 0.52, s * 0.22, s * 0.06);
                ctx.fillRect(fuseW + s * 0.02, fuseH * 0.12, s * 0.1, s * 0.45);
                ctx.fillRect(fuseW - s * 0.04, fuseH * 0.52, s * 0.22, s * 0.06);

                ctx.restore();
                return;
            }

            // SIDE VIEW (existing code)
            ctx.save();
            ctx.translate(ix, iy);
            ctx.scale(dir, 1);

            // Proportions - Apache/Hind-like aggressive profile
            const fuseLen = s * 1.5;
            const fuseH = s * 0.32;
            const tailLen = s * 0.95;
            const tailH = s * 0.12;
            const finH = s * 0.28;
            const wingSpan = s * 0.55;
            const skidH = Math.max(1, Math.floor(s * 0.04));

            // Tail boom (tapered, slightly thicker than player heli)
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.32, -tailH * 0.7);
            ctx.lineTo(-fuseLen * 0.32 - tailLen, -tailH * 0.35);
            ctx.lineTo(-fuseLen * 0.32 - tailLen, tailH * 0.35);
            ctx.lineTo(-fuseLen * 0.32, tailH * 0.7);
            ctx.closePath();
            ctx.fill();

            // Tail fin (larger, more aggressive)
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.32 - tailLen + s * 0.1, -tailH * 0.35);
            ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.02, -finH);
            ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.14, -finH);
            ctx.lineTo(-fuseLen * 0.32 - tailLen - s * 0.08, -tailH * 0.35);
            ctx.closePath();
            ctx.fill();

            // Horizontal stabilizer (larger, more aggressive)
            ctx.fillStyle = dark;
            ctx.fillRect(-fuseLen * 0.32 - tailLen - s * 0.06, -s * 0.04, s * 0.26, s * 0.08);

            // Fenestron (enclosed tail rotor) - RHINO style, darker and more angular
            const enemyFenRadius = s * 0.14;
            const enemyFenX = -fuseLen * 0.32 - tailLen - s * 0.02;
            const enemyFenY = -finH + s * 0.1;
            
            // Fenestron shroud (heavier/darker for RHINO look)
            ctx.fillStyle = weaponDark;
            ctx.beginPath();
            ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 1.25, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner fan area
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 0.85, 0, Math.PI * 2);
            ctx.fill();
            
            // Animated fan blades (faster spin for enemy)
            const enemyFenTime = performance.now() / 15;
            ctx.strokeStyle = rotor;
            ctx.lineWidth = Math.max(1, s * 0.025);
            for (let i = 0; i < 8; i++) {
                const fAngle = enemyFenTime + (i * Math.PI / 4);
                ctx.beginPath();
                ctx.moveTo(enemyFenX, enemyFenY);
                ctx.lineTo(
                    enemyFenX + Math.cos(fAngle) * enemyFenRadius * 0.75,
                    enemyFenY + Math.sin(fAngle) * enemyFenRadius * 0.75
                );
                ctx.stroke();
            }
            ctx.lineWidth = 1;
            
            // Center hub
            ctx.fillStyle = weaponDark;
            ctx.beginPath();
            ctx.arc(enemyFenX, enemyFenY, enemyFenRadius * 0.22, 0, Math.PI * 2);
            ctx.fill();

            // Main fuselage (bulkier, more armored RHINO look)
            ctx.fillStyle = body;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.45, -fuseH * 0.05);  // Flat nose top
            ctx.lineTo(fuseLen * 0.55, fuseH * 0.18);   // Angular nose tip
            ctx.lineTo(fuseLen * 0.45, fuseH * 0.48);   // Flat nose bottom
            ctx.lineTo(-fuseLen * 0.32, fuseH * 0.55);  // Rear bottom
            ctx.lineTo(-fuseLen * 0.34, -fuseH * 0.42); // Rear top
            ctx.lineTo(fuseLen * 0.05, -fuseH * 0.55);  // Top spine
            ctx.closePath();
            ctx.fill();

            // Armored side plate
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.1, -fuseH * 0.2);
            ctx.lineTo(fuseLen * 0.3, -fuseH * 0.2);
            ctx.lineTo(fuseLen * 0.28, -fuseH * 0.35);
            ctx.lineTo(fuseLen * 0.08, -fuseH * 0.35);
            ctx.closePath();
            ctx.fill();

            // Fuselage top highlight
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.35, -fuseH * 0.15);
            ctx.lineTo(fuseLen * 0.1, -fuseH * 0.52);
            ctx.lineTo(-fuseLen * 0.2, -fuseH * 0.42);
            ctx.lineTo(-fuseLen * 0.05, -fuseH * 0.2);
            ctx.closePath();
            ctx.fill();

            // Fuselage bottom shadow
            ctx.fillStyle = dark;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.4, fuseH * 0.4);
            ctx.lineTo(-fuseLen * 0.32, fuseH * 0.55);
            ctx.lineTo(-fuseLen * 0.32, fuseH * 0.35);
            ctx.lineTo(fuseLen * 0.35, fuseH * 0.25);
            ctx.closePath();
            ctx.fill();

            // Engine housing (bulge on top)
            ctx.fillStyle = darker;
            ctx.fillRect(-fuseLen * 0.2, -fuseH * 0.65, s * 0.28, s * 0.12);

            // Thruster bay details
            ctx.fillStyle = darker;
            ctx.fillRect(-fuseLen * 0.28, -fuseH * 0.15, s * 0.12, s * 0.08);
            ctx.fillRect(-fuseLen * 0.28, fuseH * 0.05, s * 0.12, s * 0.08);
            ctx.fillStyle = highlight;
            ctx.fillRect(-fuseLen * 0.26, -fuseH * 0.12, s * 0.06, s * 0.02);

            // Stub wings with weapon pylons
            ctx.fillStyle = body;
            // Upper wing
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.05, -fuseH * 0.15);
            ctx.lineTo(-fuseLen * 0.05 - wingSpan, -fuseH * 0.25);
            ctx.lineTo(-fuseLen * 0.05 - wingSpan, -fuseH * 0.1);
            ctx.lineTo(-fuseLen * 0.15, -fuseH * 0.05);
            ctx.closePath();
            ctx.fill();
            // Lower wing
            ctx.beginPath();
            ctx.moveTo(-fuseLen * 0.05, fuseH * 0.2);
            ctx.lineTo(-fuseLen * 0.05 - wingSpan, fuseH * 0.3);
            ctx.lineTo(-fuseLen * 0.05 - wingSpan, fuseH * 0.15);
            ctx.lineTo(-fuseLen * 0.15, fuseH * 0.1);
            ctx.closePath();
            ctx.fill();

            // Weapon pylons
            ctx.fillStyle = weapon;
            // Rocket pods (upper wing)
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.7, -fuseH * 0.35, s * 0.22, s * 0.14);
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.4, -fuseH * 0.32, s * 0.16, s * 0.12);
            // Missile rails (lower wing)
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.7, fuseH * 0.28, s * 0.24, s * 0.1);
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.4, fuseH * 0.25, s * 0.18, s * 0.1);

            // Missiles on rails
            ctx.fillStyle = weaponDark;
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.65, fuseH * 0.36, s * 0.14, s * 0.04);
            ctx.fillRect(-fuseLen * 0.05 - wingSpan * 0.35, fuseH * 0.33, s * 0.12, s * 0.04);

            // Cockpit glass (tandem seating, angular)
            ctx.fillStyle = glass;
            // Front gunner
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.4, -fuseH * 0.05);
            ctx.lineTo(fuseLen * 0.48, fuseH * 0.15);
            ctx.lineTo(fuseLen * 0.35, fuseH * 0.35);
            ctx.lineTo(fuseLen * 0.2, fuseH * 0.3);
            ctx.lineTo(fuseLen * 0.18, -fuseH * 0.1);
            ctx.closePath();
            ctx.fill();
            // Rear pilot
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.15, -fuseH * 0.15);
            ctx.lineTo(fuseLen * 0.15, fuseH * 0.2);
            ctx.lineTo(-fuseLen * 0.02, fuseH * 0.15);
            ctx.lineTo(-fuseLen * 0.02, -fuseH * 0.25);
            ctx.closePath();
            ctx.fill();
            // Glass highlights
            ctx.fillStyle = glassHighlight;
            ctx.beginPath();
            ctx.moveTo(fuseLen * 0.38, 0);
            ctx.lineTo(fuseLen * 0.42, fuseH * 0.1);
            ctx.lineTo(fuseLen * 0.32, fuseH * 0.15);
            ctx.lineTo(fuseLen * 0.3, 0);
            ctx.closePath();
            ctx.fill();

            // Armored canopy frames
            ctx.fillStyle = darker;
            ctx.fillRect(fuseLen * 0.32, -fuseH * 0.02, s * 0.02, fuseH * 0.22);
            ctx.fillRect(fuseLen * 0.18, -fuseH * 0.18, s * 0.02, fuseH * 0.28);

            // F89 marking
            if (s >= 16) {
                ctx.fillStyle = highlight;
                const markX = -fuseLen * 0.02;
                const markY = -fuseH * 0.15;
                const markW = Math.max(1, Math.floor(s * 0.06));
                const markH = Math.max(1, Math.floor(s * 0.02));
                // F
                ctx.fillRect(markX, markY, markW, markH);
                ctx.fillRect(markX, markY, Math.max(1, Math.floor(markW * 0.35)), markH * 4);
                ctx.fillRect(markX, markY + markH * 2, Math.max(1, Math.floor(markW * 0.7)), markH);
                // 8
                ctx.fillRect(markX + markW + markH, markY, markH, markH * 4);
                ctx.fillRect(markX + markW + markH * 2, markY, markH, markH * 4);
                ctx.fillRect(markX + markW + markH, markY + markH * 2, markH * 2, markH);
                // 9
                ctx.fillRect(markX + markW + markH * 4, markY, markW, markH);
                ctx.fillRect(markX + markW + markH * 4, markY + markH * 2, markW, markH);
                ctx.fillRect(markX + markW + markH * 4, markY + markH * 3, Math.max(1, Math.floor(markW * 0.6)), markH);
                ctx.fillRect(markX + markW + markH * 4 + markW - markH, markY, markH, markH * 4);
            }

            // Chin-mounted gun turret
            ctx.fillStyle = weapon;
            ctx.beginPath();
            ctx.arc(fuseLen * 0.38, fuseH * 0.45, s * 0.1, 0, Math.PI * 2);
            ctx.fill();
            // Gun barrel
            ctx.fillStyle = weaponDark;
            ctx.fillRect(fuseLen * 0.38, fuseH * 0.42, s * 0.22, s * 0.05);
            // Gun barrel tip
            ctx.fillRect(fuseLen * 0.58, fuseH * 0.4, s * 0.04, s * 0.08);

            // Landing gear (fixed skids)
            ctx.fillStyle = darker;
            // Skid struts
            ctx.fillRect(fuseLen * 0.12, fuseH * 0.45, Math.max(1, s * 0.03), s * 0.2);
            ctx.fillRect(-fuseLen * 0.18, fuseH * 0.45, Math.max(1, s * 0.03), s * 0.2);
            // Skid rails
            ctx.fillRect(-fuseLen * 0.25, fuseH * 0.62, fuseLen * 0.5, skidH);

            // Main rotor disc (perspective ellipse)
            const rotorTime = performance.now() / 38;
            const rotorRadX = fuseLen * 0.72;
            const rotorRadY = fuseLen * 0.22;
            
            // Rotor blur disc
            ctx.fillStyle = rotor;
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.ellipse(0, -fuseH * 0.75, rotorRadX, rotorRadY, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Rotor blades (4 blades)
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < 4; i++) {
                const angle = rotorTime + (i * Math.PI / 2);
                const bx = Math.cos(angle) * rotorRadX;
                const by = Math.sin(angle) * rotorRadY;
                const bladeW = Math.max(2, Math.floor(s * 0.07));
                ctx.fillRect(bx - bladeW / 2, -fuseH * 0.75 + by - 1, bladeW, 2);
            }
            ctx.globalAlpha = 1.0;

            // Rotor hub/mast
            ctx.fillStyle = darker;
            ctx.fillRect(-s * 0.05, -fuseH * 0.88, s * 0.1, s * 0.15);
            ctx.fillStyle = weapon;
            ctx.beginPath();
            ctx.arc(0, -fuseH * 0.9, s * 0.06, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        
        function drawTank(x, y, size, color, heading = 0, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 14);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            // Colors - M1 Abrams-like military tank palette
            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 18), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 32), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 12), fogFactor, ambient, skyColor);
            const track = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
            const trackMid = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const trackHighlight = getSpriteColorWithFog('#3a3a3a', fogFactor, ambient, skyColor);
            const wheel = getSpriteColorWithFog('#252525', fogFactor, ambient, skyColor);
            const wheelHighlight = getSpriteColorWithFog('#404040', fogFactor, ambient, skyColor);
            const metal = getSpriteColorWithFog('#2a2a2a', fogFactor, ambient, skyColor);
            const metalDark = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);

            const relAngle = normalizeAngle(heading - camera.angle);
            const sinRel = Math.sin(relAngle);
            const cosRel = Math.cos(relAngle);

            // Determine view type
            const showFront = sinRel > 0.7;
            const showBack = sinRel < -0.7;
            const showSide = !showFront && !showBack;
            const facingToward = cosRel < -0.5;

            if (showSide) {
            // Dimensions - proper tank proportions
            const hullLen = s * 1.2;
            const hullH = s * 0.22;
            const trackH = Math.max(3, Math.floor(s * 0.24));
            const trackLen = s * 1.3;
            const turretLen = s * 0.55;
            const turretH = s * 0.2;
            const gunLen = s * 0.6;
            const gunH = Math.max(2, Math.floor(s * 0.06));
            const wheelRad = Math.max(2, Math.floor(trackH * 0.38));
            const wheelCount = Math.max(3, Math.floor(s / 12));

            // Y positions (bottom-up)
            const trackY = iy - Math.floor(trackH * 0.3);
            const hullY = trackY - hullH + Math.floor(trackH * 0.15);
            const turretY = hullY - turretH + Math.floor(s * 0.04);

            // Track assembly (with visible road wheels)
            // Track base
            ctx.fillStyle = track;
            ctx.fillRect(ix - trackLen * 0.5, trackY, trackLen, trackH);
            
            // Track top highlight
            ctx.fillStyle = trackHighlight;
            ctx.fillRect(ix - trackLen * 0.5, trackY, trackLen, Math.max(1, Math.floor(trackH * 0.15)));
            
            // Track guards/fenders
            ctx.fillStyle = dark;
            ctx.fillRect(ix - trackLen * 0.52, trackY - Math.floor(s * 0.04), trackLen * 1.04, Math.floor(s * 0.05));

            // Road wheels (visible between track sections)
            const wheelSpacing = trackLen / (wheelCount + 1);
            for (let i = 1; i <= wheelCount; i++) {
                const wx = ix - trackLen * 0.5 + wheelSpacing * i;
                const wy = trackY + trackH * 0.5;
                
                // Wheel body
                ctx.fillStyle = wheel;
                ctx.beginPath();
                ctx.arc(wx, wy, wheelRad, 0, Math.PI * 2);
                ctx.fill();
                
                // Wheel highlight (top)
                ctx.fillStyle = wheelHighlight;
                ctx.beginPath();
                ctx.arc(wx, wy - wheelRad * 0.3, wheelRad * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Wheel hub
                ctx.fillStyle = trackMid;
                ctx.beginPath();
                ctx.arc(wx, wy, wheelRad * 0.35, 0, Math.PI * 2);
                ctx.fill();
            }

            // Drive sprocket (rear)
            ctx.fillStyle = wheel;
            ctx.beginPath();
            ctx.arc(ix - trackLen * 0.42, trackY + trackH * 0.4, wheelRad * 0.9, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = wheelHighlight;
            ctx.beginPath();
            ctx.arc(ix - trackLen * 0.42, trackY + trackH * 0.3, wheelRad * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Idler wheel (front)
            ctx.fillStyle = wheel;
            ctx.beginPath();
            ctx.arc(ix + trackLen * 0.42, trackY + trackH * 0.4, wheelRad * 0.9, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = wheelHighlight;
            ctx.beginPath();
            ctx.arc(ix + trackLen * 0.42, trackY + trackH * 0.3, wheelRad * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Hull (sloped armor like M1 Abrams)
            ctx.fillStyle = base;
            ctx.beginPath();
            ctx.moveTo(ix + hullLen * 0.5, hullY + hullH);        // Front bottom
            ctx.lineTo(ix + hullLen * 0.55, hullY + hullH * 0.3); // Front slope
            ctx.lineTo(ix + hullLen * 0.4, hullY);                // Front top
            ctx.lineTo(ix - hullLen * 0.45, hullY);               // Rear top
            ctx.lineTo(ix - hullLen * 0.5, hullY + hullH);        // Rear bottom
            ctx.closePath();
            ctx.fill();

            // Hull top highlight
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.moveTo(ix + hullLen * 0.4, hullY);
            ctx.lineTo(ix - hullLen * 0.45, hullY);
            ctx.lineTo(ix - hullLen * 0.35, hullY + hullH * 0.25);
            ctx.lineTo(ix + hullLen * 0.3, hullY + hullH * 0.25);
            ctx.closePath();
            ctx.fill();

            // Hull side shadow
            ctx.fillStyle = dark;
            ctx.fillRect(ix - hullLen * 0.5, hullY + hullH * 0.6, hullLen, hullH * 0.4);

            // Turret (angular, modern design)
            ctx.fillStyle = base;
            ctx.beginPath();
            ctx.moveTo(ix + turretLen * 0.5, turretY + turretH);      // Front bottom
            ctx.lineTo(ix + turretLen * 0.55, turretY + turretH * 0.4);// Front slope
            ctx.lineTo(ix + turretLen * 0.4, turretY);                // Front top
            ctx.lineTo(ix - turretLen * 0.5, turretY);                // Rear top
            ctx.lineTo(ix - turretLen * 0.55, turretY + turretH);     // Rear bottom
            ctx.closePath();
            ctx.fill();

            // Turret top highlight
            ctx.fillStyle = highlight;
            ctx.beginPath();
            ctx.moveTo(ix + turretLen * 0.35, turretY);
            ctx.lineTo(ix - turretLen * 0.45, turretY);
            ctx.lineTo(ix - turretLen * 0.35, turretY + turretH * 0.3);
            ctx.lineTo(ix + turretLen * 0.25, turretY + turretH * 0.3);
            ctx.closePath();
            ctx.fill();

            // Turret side shadow
            ctx.fillStyle = dark;
            ctx.fillRect(ix - turretLen * 0.55, turretY + turretH * 0.65, turretLen * 1.1, turretH * 0.35);

            // Commander's hatch
            ctx.fillStyle = darker;
            ctx.fillRect(ix - turretLen * 0.15, turretY - Math.floor(s * 0.05), s * 0.15, Math.floor(s * 0.06));
            ctx.fillStyle = metalDark;
            ctx.fillRect(ix - turretLen * 0.12, turretY - Math.floor(s * 0.04), s * 0.09, Math.floor(s * 0.04));

            // Loader's hatch
            ctx.fillStyle = darker;
            ctx.fillRect(ix - turretLen * 0.4, turretY - Math.floor(s * 0.03), s * 0.1, Math.floor(s * 0.04));

            // Main gun mantlet
            ctx.fillStyle = darker;
            ctx.beginPath();
            ctx.moveTo(ix + turretLen * 0.45, turretY + turretH * 0.25);
            ctx.lineTo(ix + turretLen * 0.55, turretY + turretH * 0.4);
            ctx.lineTo(ix + turretLen * 0.55, turretY + turretH * 0.7);
            ctx.lineTo(ix + turretLen * 0.45, turretY + turretH * 0.85);
            ctx.closePath();
            ctx.fill();

            // Main gun barrel (long, with thermal sleeve)
            const gunY = turretY + turretH * 0.45;
            ctx.fillStyle = metal;
            ctx.fillRect(ix + turretLen * 0.5, gunY, gunLen, gunH);
            // Thermal sleeve sections
            ctx.fillStyle = metalDark;
            ctx.fillRect(ix + turretLen * 0.5 + gunLen * 0.15, gunY - 1, gunLen * 0.15, gunH + 2);
            ctx.fillRect(ix + turretLen * 0.5 + gunLen * 0.45, gunY - 1, gunLen * 0.15, gunH + 2);
            // Muzzle brake
            ctx.fillStyle = metalDark;
            ctx.fillRect(ix + turretLen * 0.5 + gunLen - s * 0.06, gunY - Math.floor(s * 0.02), s * 0.08, gunH + Math.floor(s * 0.04));
            // Bore evacuator
            ctx.fillStyle = darker;
            ctx.fillRect(ix + turretLen * 0.5 + gunLen * 0.3, gunY - Math.floor(s * 0.015), s * 0.08, gunH + Math.floor(s * 0.03));

            // Coaxial machine gun
            ctx.fillStyle = metalDark;
            ctx.fillRect(ix + turretLen * 0.48, gunY + gunH + Math.floor(s * 0.02), s * 0.2, Math.max(1, Math.floor(s * 0.025)));

            // Smoke grenade launchers (side of turret)
            ctx.fillStyle = metalDark;
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(ix + turretLen * 0.25 + i * s * 0.06, turretY + turretH * 0.15, s * 0.04, s * 0.08);
            }
            } else if (showFront) {
                // FRONT VIEW - hull front armor, gun pointing toward camera
                const bodyW = s * 0.9;
                const bodyH = s * 0.45;
                const turretW = s * 0.5;
                const turretH = s * 0.25;

                // Tracks (front view)
                ctx.fillStyle = track;
                ctx.fillRect(ix - bodyW * 0.6, iy + bodyH * 0.15, bodyW * 1.2, bodyH * 0.35);
                ctx.fillStyle = trackHighlight;
                ctx.fillRect(ix - bodyW * 0.6, iy + bodyH * 0.15, bodyW * 1.2, Math.max(1, bodyH * 0.08));

                // Hull block (sloped front armor)
                ctx.fillStyle = base;
                ctx.beginPath();
                ctx.moveTo(ix - bodyW * 0.5, iy + bodyH * 0.15);
                ctx.lineTo(ix - bodyW * 0.4, iy - bodyH * 0.25);
                ctx.lineTo(ix + bodyW * 0.4, iy - bodyH * 0.25);
                ctx.lineTo(ix + bodyW * 0.5, iy + bodyH * 0.15);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = highlight;
                ctx.fillRect(ix - bodyW * 0.35, iy - bodyH * 0.2, bodyW * 0.7, bodyH * 0.12);

                // Turret
                ctx.fillStyle = base;
                ctx.fillRect(ix - turretW * 0.5, iy - bodyH * 0.5, turretW, turretH);
                ctx.fillStyle = darker;
                ctx.fillRect(ix - turretW * 0.4, iy - bodyH * 0.5, turretW * 0.8, turretH * 0.25);

                // Gun barrel facing camera (foreshortened - small circle)
                ctx.fillStyle = metal;
                ctx.beginPath();
                ctx.arc(ix, iy - bodyH * 0.45, s * 0.06, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = metalDark;
                ctx.beginPath();
                ctx.arc(ix, iy - bodyH * 0.45, s * 0.03, 0, Math.PI * 2);
                ctx.fill();

            } else if (showBack) {
                // BACK VIEW - engine deck, exhaust grilles
                const bodyW = s * 0.9;
                const bodyH = s * 0.45;
                const turretW = s * 0.5;
                const turretH = s * 0.25;

                // Tracks (back view)
                ctx.fillStyle = track;
                ctx.fillRect(ix - bodyW * 0.6, iy + bodyH * 0.15, bodyW * 1.2, bodyH * 0.35);
                ctx.fillStyle = trackHighlight;
                ctx.fillRect(ix - bodyW * 0.6, iy + bodyH * 0.15, bodyW * 1.2, Math.max(1, bodyH * 0.08));

                // Hull block (rear - engine deck)
                ctx.fillStyle = base;
                ctx.fillRect(ix - bodyW * 0.5, iy - bodyH * 0.2, bodyW, bodyH * 0.45);
                ctx.fillStyle = dark;
                ctx.fillRect(ix - bodyW * 0.45, iy - bodyH * 0.15, bodyW * 0.9, bodyH * 0.35);

                // Exhaust grilles (prominent from back)
                ctx.fillStyle = metalDark;
                ctx.fillRect(ix - bodyW * 0.3, iy - bodyH * 0.1, bodyW * 0.22, bodyH * 0.18);
                ctx.fillRect(ix + bodyW * 0.08, iy - bodyH * 0.1, bodyW * 0.22, bodyH * 0.18);

                // Turret
                ctx.fillStyle = base;
                ctx.fillRect(ix - turretW * 0.5, iy - bodyH * 0.5, turretW, turretH);
                ctx.fillStyle = darker;
                ctx.fillRect(ix - turretW * 0.4, iy - bodyH * 0.5, turretW * 0.8, turretH * 0.25);

                // Gun barrel pointing away (just the base visible)
                ctx.fillStyle = metal;
                ctx.fillRect(ix - s * 0.04, iy - bodyH * 0.55, s * 0.08, s * 0.08);
            }
        }
        
        function drawBuilding(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 16);
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const height = Math.floor(s * 1.6);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const shadow = getSpriteColorWithFog(darkenColor(color, 30), fogFactor, ambient, skyColor);
            const highlight = getSpriteColorWithFog(lightenColor(color, 10), fogFactor, ambient, skyColor);
            const roof = getSpriteColorWithFog(darkenColor(color, 45), fogFactor, ambient, skyColor);
            const trim = getSpriteColorWithFog('#444444', fogFactor, ambient, skyColor);
            const windowDark = getSpriteColorWithFog('#223344', fogFactor, ambient, skyColor);
            const windowLit = getSpriteColorWithFog('#c9b46a', fogFactor, ambient, skyColor);

            // Base/ground plate
            ctx.fillStyle = trim;
            ctx.fillRect(ix - Math.floor(s * 0.48), iy - Math.floor(s * 0.08), Math.floor(s * 0.96), Math.floor(s * 0.12));

            // Main block (shadow side + front)
            ctx.fillStyle = shadow;
            ctx.fillRect(ix - Math.floor(s * 0.45), iy - height, Math.floor(s * 0.32), height - Math.floor(s * 0.08));
            ctx.fillStyle = base;
            ctx.fillRect(ix - Math.floor(s * 0.1), iy - height, Math.floor(s * 0.55), height - Math.floor(s * 0.08));
            ctx.fillStyle = highlight;
            ctx.fillRect(ix + Math.floor(s * 0.42), iy - height, Math.floor(s * 0.05), height - Math.floor(s * 0.08));

            // Roof slab
            ctx.fillStyle = roof;
            ctx.fillRect(ix - Math.floor(s * 0.5), iy - height - Math.floor(s * 0.08), Math.floor(s * 1.0), Math.floor(s * 0.12));

            // Windows (blocky grid)
            const rows = 3;
            const cols = 2;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const wx = ix - Math.floor(s * 0.02) + col * Math.floor(s * 0.2);
                    const wy = iy - height + Math.floor(s * 0.18) + row * Math.floor(s * 0.4);
                    ctx.fillStyle = Math.random() > 0.6 ? windowLit : windowDark;
                    ctx.fillRect(wx, wy, Math.floor(s * 0.14), Math.floor(s * 0.18));
                }
            }

            // Door
            ctx.fillStyle = trim;
            ctx.fillRect(ix + Math.floor(s * 0.08), iy - Math.floor(s * 0.34), Math.floor(s * 0.2), Math.floor(s * 0.26));
        }

        function drawHangar(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 20);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 25), fogFactor, ambient, skyColor);
            const roof = getSpriteColorWithFog(darkenColor(color, 10), fogFactor, ambient, skyColor);

            // Main structure (large rectangular building)
            ctx.fillStyle = base;
            ctx.fillRect(ix - s * 0.7, iy - s * 0.4, s * 1.4, s * 0.8);

            // Curved roof (simplified as darker top section)
            ctx.fillStyle = roof;
            ctx.fillRect(ix - s * 0.7, iy - s * 0.5, s * 1.4, s * 0.15);

            // Large door opening (dark)
            ctx.fillStyle = dark;
            ctx.fillRect(ix - s * 0.4, iy - s * 0.1, s * 0.8, s * 0.5);

            // Door frame
            ctx.fillStyle = getSpriteColorWithFog(darkenColor(color, 15), fogFactor, ambient, skyColor);
            ctx.fillRect(ix - s * 0.45, iy - s * 0.15, s * 0.05, s * 0.55);
            ctx.fillRect(ix + s * 0.4, iy - s * 0.15, s * 0.05, s * 0.55);
        }

        function drawControlTower(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 15);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 20), fogFactor, ambient, skyColor);
            const glass = getSpriteColorWithFog('#4a8aaa', fogFactor, ambient, skyColor);

            // Tower base (wider at bottom)
            ctx.fillStyle = base;
            ctx.fillRect(ix - s * 0.3, iy, s * 0.6, s * 0.4);

            // Tower shaft
            ctx.fillRect(ix - s * 0.2, iy - s * 0.8, s * 0.4, s * 0.8);

            // Control room (wider top with windows)
            ctx.fillStyle = dark;
            ctx.fillRect(ix - s * 0.4, iy - s * 1.2, s * 0.8, s * 0.4);

            // Windows (glass)
            ctx.fillStyle = glass;
            ctx.fillRect(ix - s * 0.35, iy - s * 1.1, s * 0.7, s * 0.2);

            // Antenna
            ctx.fillStyle = dark;
            ctx.fillRect(ix - s * 0.05, iy - s * 1.5, s * 0.1, s * 0.3);
        }

        function drawBarracks(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 18);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 20), fogFactor, ambient, skyColor);
            const roof = getSpriteColorWithFog('#4a3a2a', fogFactor, ambient, skyColor);

            // Main building
            ctx.fillStyle = base;
            ctx.fillRect(ix - s * 0.6, iy - s * 0.25, s * 1.2, s * 0.5);

            // Roof
            ctx.fillStyle = roof;
            ctx.fillRect(ix - s * 0.65, iy - s * 0.35, s * 1.3, s * 0.12);

            // Windows (row of small dark rectangles)
            ctx.fillStyle = dark;
            for (let i = 0; i < 4; i++) {
                ctx.fillRect(ix - s * 0.45 + i * s * 0.25, iy - s * 0.15, s * 0.12, s * 0.15);
            }

            // Door
            ctx.fillRect(ix - s * 0.08, iy + s * 0.05, s * 0.16, s * 0.2);
        }

        function drawFuelDepot(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 15);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 30), fogFactor, ambient, skyColor);
            const warning = getSpriteColorWithFog('#8a4a2a', fogFactor, ambient, skyColor);

            // Large cylindrical tank (simplified as rounded rectangle)
            ctx.fillStyle = base;
            ctx.fillRect(ix - s * 0.5, iy - s * 0.3, s, s * 0.6);

            // Tank top (darker)
            ctx.fillStyle = dark;
            ctx.fillRect(ix - s * 0.5, iy - s * 0.35, s, s * 0.1);

            // Warning stripe
            ctx.fillStyle = warning;
            ctx.fillRect(ix - s * 0.5, iy - s * 0.1, s, s * 0.08);

            // Pipes
            ctx.fillStyle = dark;
            ctx.fillRect(ix + s * 0.4, iy - s * 0.15, s * 0.2, s * 0.1);
            ctx.fillRect(ix + s * 0.55, iy - s * 0.15, s * 0.05, s * 0.4);
        }

        function drawHelipad(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 20);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const marking = getSpriteColorWithFog('#8a8a2a', fogFactor, ambient, skyColor);
            const darkEdge = getSpriteColorWithFog(darkenColor(color, 20), fogFactor, ambient, skyColor);

            const padW = s * 0.95;
            const padH = s * 0.35;

            // Pad surface (flattened ellipse to read as horizontal)
            ctx.fillStyle = base;
            ctx.beginPath();
            ctx.ellipse(ix, iy, padW * 0.5, padH * 0.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Edge ring
            ctx.strokeStyle = darkEdge;
            ctx.lineWidth = Math.max(1, Math.floor(s * 0.05));
            ctx.beginPath();
            ctx.ellipse(ix, iy, padW * 0.48, padH * 0.48, 0, 0, Math.PI * 2);
            ctx.stroke();

            // H marking (compressed vertically for perspective, centered on pad)
            const hHeight = padH * 0.55;
            const hWidth = Math.max(1, Math.floor(padW * 0.08));
            const hGap = padW * 0.18;
            const hBarH = Math.max(1, Math.floor(padH * 0.15));

            ctx.fillStyle = marking;
            // Left vertical bar of H
            ctx.fillRect(ix - hGap - hWidth / 2, iy - hHeight / 2, hWidth, hHeight);
            // Right vertical bar of H
            ctx.fillRect(ix + hGap - hWidth / 2, iy - hHeight / 2, hWidth, hHeight);
            // Horizontal bar of H (centered)
            ctx.fillRect(ix - hGap, iy - hBarH / 2, hGap * 2, hBarH);

            // Outer outline
            ctx.strokeStyle = marking;
            ctx.lineWidth = Math.max(1, Math.floor(s * 0.04));
            ctx.beginPath();
            ctx.ellipse(ix, iy, padW * 0.43, padH * 0.43, 0, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawResupplyGlow(x, y, size, fogFactor = 0) {
            // Subtle pulsing glow effect for friendly resupply points
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const time = performance.now() / 1000;
            
            // Pulse between 0.15 and 0.35 alpha
            const pulse = 0.25 + Math.sin(time * 2) * 0.1;
            const alpha = Math.max(0.05, pulse * (1 - fogFactor * 0.7));
            
            // Glow radius slightly larger than helipad
            const glowRadius = size * 0.6;
            const glowHeight = size * 0.25;  // Flattened ellipse for ground perspective
            
            // Draw multiple overlapping ellipses for soft glow effect
            // Outer glow (faint, large)
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = '#88ff88';
            ctx.beginPath();
            ctx.ellipse(ix, iy, glowRadius * 1.4, glowHeight * 1.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Middle glow
            ctx.globalAlpha = alpha * 0.6;
            ctx.fillStyle = '#aaffaa';
            ctx.beginPath();
            ctx.ellipse(ix, iy, glowRadius * 1.1, glowHeight * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner glow (brighter, smaller)
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = '#ccffcc';
            ctx.beginPath();
            ctx.ellipse(ix, iy, glowRadius * 0.8, glowHeight * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
        }
        
        function drawSAMSite(x, y, size, color, fogFactor = 0, ambient = 1, skyColor = CONFIG.SKY_COLOR) {
            ctx.imageSmoothingEnabled = false;
            const s = Math.max(Math.floor(size), 14);
            const ix = Math.floor(x);
            const iy = Math.floor(y);

            const base = getSpriteColorWithFog(color, fogFactor, ambient, skyColor);
            const dark = getSpriteColorWithFog(darkenColor(color, 25), fogFactor, ambient, skyColor);
            const darker = getSpriteColorWithFog(darkenColor(color, 35), fogFactor, ambient, skyColor);
            const platform = getSpriteColorWithFog('#3a3a3a', fogFactor, ambient, skyColor);
            const platformEdge = getSpriteColorWithFog('#4a4a4a', fogFactor, ambient, skyColor);
            const tube = getSpriteColorWithFog('#1a1a1a', fogFactor, ambient, skyColor);
            const radar = getSpriteColorWithFog('#666666', fogFactor, ambient, skyColor);
            const cabinGlass = getSpriteColorWithFog('#335566', fogFactor, ambient, skyColor);

            // Base platform
            ctx.fillStyle = platform;
            ctx.fillRect(ix - Math.floor(s * 0.6), iy - Math.floor(s * 0.05), Math.floor(s * 1.2), Math.floor(s * 0.15));
            ctx.fillStyle = platformEdge;
            ctx.fillRect(ix - Math.floor(s * 0.6), iy - Math.floor(s * 0.05), Math.floor(s * 1.2), Math.max(1, Math.floor(s * 0.03)));

            // Chassis
            ctx.fillStyle = darker;
            ctx.fillRect(ix - Math.floor(s * 0.4), iy - Math.floor(s * 0.15), Math.floor(s * 0.8), Math.floor(s * 0.12));

            // Wheels (blocky)
            ctx.fillStyle = tube;
            ctx.fillRect(ix - Math.floor(s * 0.28), iy - Math.floor(s * 0.02), Math.floor(s * 0.12), Math.floor(s * 0.08));
            ctx.fillRect(ix + Math.floor(s * 0.16), iy - Math.floor(s * 0.02), Math.floor(s * 0.12), Math.floor(s * 0.08));

            // Launcher box
            ctx.fillStyle = base;
            ctx.fillRect(ix - Math.floor(s * 0.3), iy - Math.floor(s * 0.45), Math.floor(s * 0.6), Math.floor(s * 0.32));
            ctx.fillStyle = dark;
            ctx.fillRect(ix + Math.floor(s * 0.22), iy - Math.floor(s * 0.45), Math.floor(s * 0.08), Math.floor(s * 0.32));

            // Missile tubes (2x2 squares)
            ctx.fillStyle = tube;
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    const tubeX = ix - Math.floor(s * 0.2) + col * Math.floor(s * 0.22);
                    const tubeY = iy - Math.floor(s * 0.42) + row * Math.floor(s * 0.14);
                    ctx.fillRect(tubeX, tubeY, Math.floor(s * 0.08), Math.floor(s * 0.08));
                }
            }

            // Radar mast and blocky dish
            ctx.fillStyle = platformEdge;
            ctx.fillRect(ix - Math.floor(s * 0.52), iy - Math.floor(s * 0.7), Math.floor(s * 0.05), Math.floor(s * 0.35));
            ctx.fillStyle = radar;
            ctx.fillRect(ix - Math.floor(s * 0.56), iy - Math.floor(s * 0.78), Math.floor(s * 0.12), Math.floor(s * 0.08));

            // Cabin
            ctx.fillStyle = dark;
            ctx.fillRect(ix + Math.floor(s * 0.35), iy - Math.floor(s * 0.35), Math.floor(s * 0.2), Math.floor(s * 0.22));
            ctx.fillStyle = cabinGlass;
            ctx.fillRect(ix + Math.floor(s * 0.38), iy - Math.floor(s * 0.32), Math.floor(s * 0.14), Math.floor(s * 0.08));
        }
        
        function lightenColor(color, amount) {
            const base = hexToRgb(color);
            return rgbToHex({
                r: Math.min(255, base.r + amount),
                g: Math.min(255, base.g + amount),
                b: Math.min(255, base.b + amount)
            });
        }
        
        function darkenColor(color, amount) {
            const base = hexToRgb(color);
            return rgbToHex({
                r: Math.max(0, base.r - amount),
                g: Math.max(0, base.g - amount),
                b: Math.max(0, base.b - amount)
            });
        }
        
        // ============================================
        // C4 CHARGES RENDERING
        // ============================================
        function renderC4Charges(cam) {
            if (placedC4Charges.length === 0) return;
            
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            const now = performance.now();
            
            for (const charge of placedC4Charges) {
                // Calculate relative position
                let dx = charge.x - cam.x;
                let dy = charge.y - cam.y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Check if in front of camera and close enough to see
                if (ry > 5 && ry < 300) {
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;
                    
                    // Apply bank tilt
                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const columnOffset = screenX - screenWidth / 2;
                    const bankOffset = columnOffset * bankTiltFactor;
                    const screenY = (cam.height - charge.z) * scaleY + cam.horizon + bankOffset;
                    
                    // Size based on distance
                    const size = Math.max(4, 20 * scaleY);
                    
                    // Blinking armed indicator
                    const blinkPhase = Math.sin((now - charge.placedAt) * 0.01) > 0;
                    
                    // Draw C4 block (olive drab rectangle)
                    ctx.fillStyle = '#4a4a2a';
                    ctx.fillRect(screenX - size * 0.6, screenY - size * 0.3, size * 1.2, size * 0.6);
                    
                    // Border
                    ctx.strokeStyle = '#2a2a1a';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(screenX - size * 0.6, screenY - size * 0.3, size * 1.2, size * 0.6);
                    
                    // Blinking red LED when armed
                    if (blinkPhase) {
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY - size * 0.1, size * 0.12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glow effect
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(screenX, screenY - size * 0.1, size * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }
        
        // ============================================
        // PROJECTILE RENDERING
        // ============================================
        function renderProjectiles(cam) {
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            
            for (const proj of projectiles) {
                // Calculate relative position
                let dx = proj.x - cam.x;
                let dy = proj.y - cam.y;
                
                // Handle map wrapping
                if (!proj.noWrap) {
                    if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                    if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                    if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                    if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                }
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                // Check if in front of camera
                if (ry > 5 && ry < cam.distance) {
                    // Check terrain occlusion for projectiles
                    if (isProjectileOccluded(proj, cam, dx, dy, ry)) {
                        continue;
                    }
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;

                    // Apply bank tilt
                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
                    const screenY = (cam.height - proj.z) * scaleY + cam.horizon + bankOffset;
                    
                    // Different rendering based on projectile type - ALL BALL-BASED
                    const scale = Math.min(scaleY, 1);
                    
                    if (proj.projectileType === 'missile') {
                        // Missiles - larger ball with smoke trail as fading circles
                        const missileSize = 5 * scale;
                        ctx.fillStyle = proj.color || '#ff4400';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, missileSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Smoke trail as fading circles behind (not a line)
                        const trailAngle = proj.angle - cam.angle;
                        for (let t = 1; t <= 3; t++) {
                            const trailDist = t * 8 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY + Math.cos(trailAngle) * trailDist;
                            const trailSize = (4 - t * 0.8) * scale;
                            const alpha = 0.6 - t * 0.15;
                            ctx.fillStyle = `rgba(150, 150, 150, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Flame at exhaust
                        const flameX = screenX + Math.sin(trailAngle) * 10 * scale;
                        const flameY = screenY + Math.cos(trailAngle) * 10 * scale;
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(flameX, flameY, 3 * scale, 0, Math.PI * 2);
                        ctx.fill();
                        
                    } else if (proj.projectileType === 'rocket') {
                        // Rockets - medium ball with fire trail as circles
                        const rocketSize = 4 * scale;
                        ctx.fillStyle = proj.color || '#ff6600';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, rocketSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Fire trail as fading circles
                        const trailAngle = proj.angle - cam.angle;
                        for (let t = 1; t <= 2; t++) {
                            const trailDist = t * 6 * scale;
                            const trailX = screenX + Math.sin(trailAngle) * trailDist;
                            const trailY = screenY + Math.cos(trailAngle) * trailDist;
                            const trailSize = (3 - t * 0.6) * scale;
                            const alpha = 0.7 - t * 0.2;
                            ctx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                    } else {
                        // Bullets - just balls, no tracer lines
                        // Heli cannon = larger, soldier bullets = smaller
                        const bulletSize = proj.projectileType === 'cannon' ? 3 * scale : 2.5 * scale;
                        ctx.fillStyle = proj.color || '#ffff00';
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, Math.max(bulletSize, 1.5), 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        // ============================================
        // EXPLOSION RENDERING
        // ============================================
        function renderExplosions(cam) {
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            
            for (const exp of explosions) {
                // Calculate relative position
                let dx = exp.x - cam.x;
                let dy = exp.y - cam.y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                // Rotate to camera space
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                if (ry > 5 && ry < cam.distance) {
                    // Check terrain occlusion for explosions
                    if (isProjectileOccluded(exp, cam, dx, dy, ry)) {
                        continue;
                    }
                    const scaleX = (screenWidth / 2) / ry;
                    const scaleY = 240.0 / ry;
                    const screenX = screenWidth / 2 + rx * scaleX;

                    // Apply bank tilt
                    const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                    const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
                    const screenY = (cam.height - exp.z) * scaleY + cam.horizon + bankOffset;
                    
                    const progress = 1 - (exp.lifetime / exp.maxLifetime);
                    const currentSize = exp.size * scaleY * (0.5 + progress * 0.5);
                    const alpha = 1 - progress;
                    
                    // Draw explosion layers
                    const gradient = ctx.createRadialGradient(
                        screenX, screenY, 0,
                        screenX, screenY, currentSize
                    );
                    gradient.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 50, ${alpha * 0.8})`);
                    gradient.addColorStop(0.6, `rgba(255, 100, 0, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(100, 50, 0, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, currentSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // ============================================
        // HUD RENDERING - Comanche Style
        // ============================================
        
        // Helper function to draw bordered panel
        function drawHUDPanel(x, y, width, height, title = null) {
            // Panel background
            ctx.fillStyle = 'rgba(0, 20, 0, 0.85)';
            ctx.fillRect(x, y, width, height);
            
            // Panel border (double line effect)
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 1, y + 1, width - 2, height - 2);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            
            // Corner accents
            const cornerSize = 6;
            ctx.fillStyle = '#0f0';
            // Top-left
            ctx.fillRect(x, y, cornerSize, 2);
            ctx.fillRect(x, y, 2, cornerSize);
            // Top-right
            ctx.fillRect(x + width - cornerSize, y, cornerSize, 2);
            ctx.fillRect(x + width - 2, y, 2, cornerSize);
            // Bottom-left
            ctx.fillRect(x, y + height - 2, cornerSize, 2);
            ctx.fillRect(x, y + height - cornerSize, 2, cornerSize);
            // Bottom-right
            ctx.fillRect(x + width - cornerSize, y + height - 2, cornerSize, 2);
            ctx.fillRect(x + width - 2, y + height - cornerSize, 2, cornerSize);
            
            // Title bar if provided
            if (title) {
                ctx.fillStyle = 'rgba(0, 80, 0, 0.5)';
                ctx.fillRect(x + 2, y + 2, width - 4, 16);
                ctx.font = 'bold 11px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.textAlign = 'center';
                ctx.fillText(title, x + width / 2, y + 13);
            }
        }

        function getDeltaHeadingData() {
            let heading = Math.round((-camera.angle * 180 / Math.PI) % 360);
            if (heading < 0) heading += 360;
            const cardinals = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];
            const index = Math.round(heading / 45);
            return { heading, cardinal: cardinals[index] || 'N' };
        }

        function getDeltaZoomFactor() {
            if (gameMode !== GAME_MODES.DELTA) return 1;
            const weaponKey = soldierWeapon.current;
            const targetZoom = soldierScope.active
                ? (weaponKey === 'sniper' ? soldierScope.zoom : 1.6)
                : 1;
            return 1 + (targetZoom - 1) * soldierScope.transitionTime;
        }

        function calculateRangeToTarget() {
            const maxRange = Math.min(camera.distance, 1200);
            const angle = camera.angle;
            const dirX = -Math.sin(angle);
            const dirY = -Math.cos(angle);
            const pitchFactor = (camera.horizon - screenHeight / 2) / 240.0;
            const dirZ = pitchFactor;

            let targetHit = null;
            let targetDist = Infinity;

            for (const target of targets) {
                if (target.destroyed) continue;
                let dx = target.x - camera.x;
                let dy = target.y - camera.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;

                const t = dx * dirX + dy * dirY;
                if (t <= 0 || t > maxRange) continue;

                const closestDistSq = dx * dx + dy * dy - t * t;
                const radius = target.size * 1.1;
                if (closestDistSq > radius * radius) continue;

                const rayZ = camera.height + dirZ * t;
                if (Math.abs(rayZ - target.z) > target.size * 1.2) continue;

                if (t < targetDist) {
                    targetDist = t;
                    targetHit = target;
                }
            }

            let terrainDist = maxRange;
            const step = 4;
            for (let t = step; t <= maxRange; t += step) {
                const sampleX = ((camera.x + dirX * t) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                const sampleY = ((camera.y + dirY * t) % CONFIG.MAP_SIZE + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                const terrainHeight = getTerrainHeight(sampleX, sampleY);
                const rayZ = camera.height + dirZ * t;
                if (rayZ <= terrainHeight) {
                    terrainDist = t;
                    break;
                }
            }

            if (targetHit && targetDist < terrainDist) {
                return { distance: Math.round(targetDist), target: targetHit };
            }

            return { distance: Math.round(terrainDist), target: null };
        }

        function renderScopeOverlay() {
            if (gameMode !== GAME_MODES.DELTA) return;
            if (!soldierScope.active) return;
            if (soldierWeapon.current !== 'sniper') return;

            const alpha = 0.85 * soldierScope.transitionTime;
            if (alpha <= 0) return;

            const cx = screenWidth / 2;
            const cy = screenHeight / 2;
            // Larger scope circle for better visibility (Delta Force style)
            const radius = Math.min(screenWidth, screenHeight) * 0.42;

            ctx.save();
            
            // Draw scope vignette - thinner black border around scope
            ctx.globalAlpha = alpha;
            
            // Create a path that covers the screen except for the scope circle
            ctx.beginPath();
            ctx.rect(0, 0, screenWidth, screenHeight);
            ctx.arc(cx, cy, radius, 0, Math.PI * 2, true);  // Counter-clockwise to cut out
            ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';
            ctx.fill();

            // Scope ring (outer edge)
            ctx.strokeStyle = 'rgba(20, 20, 20, 0.95)';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner scope ring highlight
            ctx.strokeStyle = 'rgba(0, 255, 120, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, radius - 4, 0, Math.PI * 2);
            ctx.stroke();

            // Crosshair reticle
            ctx.strokeStyle = 'rgba(0, 255, 120, 0.9)';
            ctx.lineWidth = 1.5;
            const gap = 8;
            const lineLen = radius * 0.7;
            ctx.beginPath();
            // Horizontal lines
            ctx.moveTo(cx - lineLen, cy);
            ctx.lineTo(cx - gap, cy);
            ctx.moveTo(cx + gap, cy);
            ctx.lineTo(cx + lineLen, cy);
            // Vertical lines
            ctx.moveTo(cx, cy - lineLen);
            ctx.lineTo(cx, cy - gap);
            ctx.moveTo(cx, cy + gap);
            ctx.lineTo(cx, cy + lineLen);
            ctx.stroke();
            
            // Mil-dots on crosshair
            ctx.fillStyle = 'rgba(0, 255, 120, 0.8)';
            const dotSpacing = radius * 0.15;
            for (let i = 1; i <= 3; i++) {
                // Horizontal dots
                ctx.beginPath();
                ctx.arc(cx - gap - dotSpacing * i, cy, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx + gap + dotSpacing * i, cy, 2, 0, Math.PI * 2);
                ctx.fill();
                // Vertical dots
                ctx.beginPath();
                ctx.arc(cx, cy - gap - dotSpacing * i, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(cx, cy + gap + dotSpacing * i, 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Center dot
            ctx.fillStyle = 'rgba(0, 255, 120, 0.95)';
            ctx.beginPath();
            ctx.arc(cx, cy, 2, 0, Math.PI * 2);
            ctx.fill();

            // Range finder display
            const rangeData = calculateRangeToTarget();
            const targetLabel = rangeData.target ? rangeData.target.type.toUpperCase() : '';
            const label = targetLabel ? `RNG: ${rangeData.distance}m | ${targetLabel}` : `RNG: ${rangeData.distance}m`;

            ctx.font = 'bold 13px Courier New';
            ctx.fillStyle = '#00ff88';
            ctx.textAlign = 'center';
            ctx.fillText(label, cx, cy + radius + 25);
            
            // Zoom indicator
            ctx.font = '11px Courier New';
            ctx.fillStyle = '#00aa55';
            ctx.fillText(`${soldierScope.zoom}x ZOOM`, cx, cy - radius - 15);

            ctx.restore();
        }

        function renderDeltaHUD() {
            const weapon = WEAPONS_DELTA[soldierWeapon.current];
            const state = soldierWeapon.weapons[soldierWeapon.current];
            if (!weapon || !state) return;
            const headingData = getDeltaHeadingData();

            const weaponPanelW = 200;
            const weaponPanelH = 95;
            const weaponPanelX = 10;
            const weaponPanelY = 10;

            drawHUDPanel(weaponPanelX, weaponPanelY, weaponPanelW, weaponPanelH, 'WEAPON');

            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = weapon.color;
            ctx.textAlign = 'left';
            ctx.fillText(weapon.name.toUpperCase(), weaponPanelX + 12, weaponPanelY + 35);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'right';
            const ammoDisplay = soldierWeapon.current === 'airstrike'
                ? `STR ${getAirstrikeCharges(state)}`
                : `${state.mag}/${state.mags}`;
            ctx.fillText(ammoDisplay, weaponPanelX + weaponPanelW - 12, weaponPanelY + 35);

            // Magazine icon
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(weaponPanelX + 14, weaponPanelY + 43, 30, 12);
            ctx.fillStyle = '#0a0';
            ctx.fillRect(weaponPanelX + 18, weaponPanelY + 47, 18, 4);
            ctx.fillRect(weaponPanelX + 32, weaponPanelY + 45, 12, 2);

            // Weapon keys - reorganized to fit in panel
            ctx.font = '9px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'left';
            ctx.fillText('[1]M4 [2]SNP [3]PST [4]JAV', weaponPanelX + 12, weaponPanelY + 68);
            ctx.fillText('[5]STG [6]C4 [7]AIR [R]RLD', weaponPanelX + 12, weaponPanelY + 80);
            
            // Show C4 status if C4 is selected
            if (soldierWeapon.current === 'c4' && placedC4Charges.length > 0) {
                ctx.font = 'bold 10px Courier New';
                ctx.fillStyle = '#ff4400';
                ctx.fillText(`[FIRE TO DETONATE ${placedC4Charges.length}]`, weaponPanelX + 12, weaponPanelY + 92);
            }

            const compassPanelW = 220;
            const compassPanelH = 60;
            const compassPanelX = screenWidth - compassPanelW - 10;
            const compassPanelY = 10;
            drawHUDPanel(compassPanelX, compassPanelY, compassPanelW, compassPanelH, 'COMPASS');

            ctx.font = 'bold 18px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText(`${headingData.cardinal}`, compassPanelX + compassPanelW / 2, compassPanelY + 38);

            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText(`HDG ${headingData.heading.toString().padStart(3, '0')}°`, compassPanelX + compassPanelW / 2, compassPanelY + 54);

            const statusPanelW = 220;
            const statusPanelH = 70;
            const statusPanelX = 10;
            const statusPanelY = screenHeight - statusPanelH - 10;
            drawHUDPanel(statusPanelX, statusPanelY, statusPanelW, statusPanelH, 'STATUS');

            const healthPercent = playerHealth / maxPlayerHealth;
            ctx.fillStyle = '#111';
            ctx.fillRect(statusPanelX + 12, statusPanelY + 30, statusPanelW - 24, 12);
            ctx.strokeStyle = '#0a0';
            ctx.strokeRect(statusPanelX + 12, statusPanelY + 30, statusPanelW - 24, 12);
            const healthColor = healthPercent > 0.6 ? '#00ff55' : healthPercent > 0.3 ? '#ffcc00' : '#ff3333';
            ctx.fillStyle = healthColor;
            ctx.fillRect(statusPanelX + 12, statusPanelY + 30, (statusPanelW - 24) * healthPercent, 12);

            ctx.font = '11px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText(`HP ${Math.round(playerHealth)}`, statusPanelX + 12, statusPanelY + 26);
            const alertTexts = ['UNDETECTED', 'SUSPICIOUS', 'ALERT', 'ALARM!'];
            const alertColors = ['#00ff66', '#ffff00', '#ff8800', '#ff3333'];
            ctx.fillStyle = alertColors[alertLevel] || '#00ff66';
            ctx.fillText(alertTexts[alertLevel] || 'UNDETECTED', statusPanelX + 12, statusPanelY + 54);
            ctx.textAlign = 'right';
            ctx.fillStyle = '#0f0';
            ctx.fillText(`STANCE: ${SOLDIER.stance.toUpperCase()}`, statusPanelX + statusPanelW - 12, statusPanelY + 54);

            const showCrosshair = !soldierScope.active || soldierWeapon.current !== 'sniper';
            if (showCrosshair) {
                const cx = screenWidth / 2;
                const cy = screenHeight / 2;
                const scale = soldierScope.active ? 0.7 : 1.0;
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(cx - 10 * scale, cy);
                ctx.lineTo(cx - 2 * scale, cy);
                ctx.moveTo(cx + 2 * scale, cy);
                ctx.lineTo(cx + 10 * scale, cy);
                ctx.moveTo(cx, cy - 10 * scale);
                ctx.lineTo(cx, cy - 2 * scale);
                ctx.moveTo(cx, cy + 2 * scale);
                ctx.lineTo(cx, cy + 10 * scale);
                ctx.stroke();
            }

            if (soldierWeapon.isReloading) {
                const blinkOn = Math.floor(performance.now() / 200) % 2 === 0;
                if (blinkOn) {
                    ctx.font = 'bold 20px Courier New';
                    ctx.fillStyle = '#ff0';
                    ctx.textAlign = 'center';
                    ctx.fillText('RELOADING', screenWidth / 2, screenHeight * 0.35);
                }
            }

            renderScopeOverlay();
            
            // Targeting overlay for Delta mode (same system as Comanche)
            renderTargetingOverlay();
            
            // C4 charges indicator (always visible when charges placed)
            if (placedC4Charges.length > 0 && soldierWeapon.current !== 'c4') {
                const blinkOn = Math.floor(performance.now() / 400) % 2 === 0;
                if (blinkOn) {
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillStyle = '#ff4400';
                    ctx.textAlign = 'left';
                    ctx.fillText(`C4 ARMED: ${placedC4Charges.length} [6]`, 10, screenHeight - 100);
                }
            }

            const now = performance.now();
            const showInbound = airstrikeState.planesInbound.length > 0 || now < airstrikeState.inboundMessageUntil;

            if (airstrikeState.designating) {
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#66ccff';
                ctx.textAlign = 'center';
                ctx.fillText('DESIGNATING TARGET', screenWidth / 2, screenHeight * 0.28);
            }

            if (showInbound) {
                ctx.font = 'bold 16px Courier New';
                ctx.fillStyle = '#66ccff';
                ctx.textAlign = 'center';
                ctx.fillText('AIRSTRIKE INBOUND', screenWidth / 2, screenHeight * 0.32);
            }
            
            // Boundary warning
            if (boundaryWarning.active) {
                const blinkOn = Math.floor(performance.now() / 250) % 2 === 0;
                if (blinkOn || boundaryWarning.intensity >= 1.0) {
                    ctx.font = 'bold 20px Courier New';
                    ctx.fillStyle = boundaryWarning.intensity >= 1.0 ? '#ff3333' : '#ffaa00';
                    ctx.textAlign = 'center';
                    ctx.fillText('⚠ LEAVING MISSION AREA ⚠', screenWidth / 2, screenHeight * 0.15);
                    ctx.font = '14px Courier New';
                    ctx.fillText('TURN BACK', screenWidth / 2, screenHeight * 0.15 + 25);
                }
            }

            // Only show targeting crosshair while designating (not after calling strike)
            if (airstrikeState.designating) {
                const markerPoint = getAirstrikeAimPoint();
                if (markerPoint) {
                    const projection = projectWorldToScreen(camera, markerPoint.x, markerPoint.y, markerPoint.z);
                    if (projection) {
                        const markerSize = Math.max(6, 16 * projection.scaleY);
                        ctx.save();
                        ctx.strokeStyle = '#66ccff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(projection.screenX, projection.screenY, markerSize, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(projection.screenX - markerSize, projection.screenY);
                        ctx.lineTo(projection.screenX + markerSize, projection.screenY);
                        ctx.moveTo(projection.screenX, projection.screenY - markerSize);
                        ctx.lineTo(projection.screenX, projection.screenY + markerSize);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
            
            // Resupply indicator
            renderResupplyIndicator();
        }
        
        function renderHUD() {
            if (gameMode === GAME_MODES.DELTA) {
                renderDeltaHUD();
            } else {
                // Get heading in degrees
                let heading = Math.round((-camera.angle * 180 / Math.PI) % 360);
                if (heading < 0) heading += 360;

                const remaining = targets.filter(t => !t.destroyed).length;
                const healthPercent = playerHealth / maxPlayerHealth;

                // ========================================
                // TOP BAR - Flight info, Health, Score
                // ========================================
                ctx.fillStyle = 'rgba(0, 20, 0, 0.85)';
                ctx.fillRect(0, 0, screenWidth, 45);
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 45);
                ctx.lineTo(screenWidth, 45);
                ctx.stroke();

                // Flight data (left side)
                ctx.font = 'bold 14px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.textAlign = 'left';
                ctx.fillText(`ALT`, 10, 15);
                ctx.fillText(`SPD`, 90, 15);
                ctx.fillText(`HDG`, 170, 15);

                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.fillText(`${Math.floor(camera.height).toString().padStart(4, ' ')}`, 10, 35);
                ctx.fillText(`${Math.abs(currentSpeed).toFixed(0).padStart(3, ' ')}`, 90, 35);
                ctx.fillText(`${heading.toString().padStart(3, '0')}°`, 170, 35);

                // Health bar (center-left area)
                const healthBarX = 260;
                const healthBarWidth = 200;
                const healthBarHeight = 20;
                const healthBarY = 12;

                // Health label
                ctx.font = 'bold 12px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.textAlign = 'right';
                ctx.fillText('HULL', healthBarX - 5, healthBarY + 14);

                // Health bar background
                ctx.fillStyle = '#111';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                ctx.strokeStyle = '#0a0';
                ctx.lineWidth = 1;
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

                // Health bar fill with gradient color
                let healthColor;
                if (healthPercent > 0.6) {
                    healthColor = '#0f0';
                } else if (healthPercent > 0.3) {
                    healthColor = '#ff0';
                } else {
                    // Blinking red when critical
                    const blinkOn = Math.floor(performance.now() / 250) % 2 === 0;
                    healthColor = blinkOn ? '#f00' : '#800';
                }
                ctx.fillStyle = healthColor;
                ctx.fillRect(healthBarX + 2, healthBarY + 2, (healthBarWidth - 4) * healthPercent, healthBarHeight - 4);

                // Health segments (tick marks)
                ctx.strokeStyle = '#0a0';
                ctx.lineWidth = 1;
                for (let i = 1; i < 10; i++) {
                    const tickX = healthBarX + (healthBarWidth / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(tickX, healthBarY);
                    ctx.lineTo(tickX, healthBarY + 4);
                    ctx.moveTo(tickX, healthBarY + healthBarHeight - 4);
                    ctx.lineTo(tickX, healthBarY + healthBarHeight);
                    ctx.stroke();
                }

                // Health percentage text
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeText(`${Math.ceil(healthPercent * 100)}%`, healthBarX + healthBarWidth / 2, healthBarY + 15);
                ctx.fillStyle = '#fff';
                ctx.fillText(`${Math.ceil(healthPercent * 100)}%`, healthBarX + healthBarWidth / 2, healthBarY + 15);

                // Score and targets (right side)
                ctx.font = 'bold 14px Courier New';
                ctx.fillStyle = '#0f0';
                ctx.textAlign = 'right';
                // Show FREE PLAY indicator or targets count
                if (currentMissionIndex === -1) {
                    ctx.fillStyle = '#0af';
                    ctx.fillText('FREE PLAY', screenWidth - 10, 15);
                } else {
                    ctx.fillText(`TARGETS: ${remaining}`, screenWidth - 10, 15);
                }
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#ff0';
                ctx.fillText(`SCORE: ${score.toString().padStart(6, '0')}`, screenWidth - 10, 35);

                // Sound indicator
                if (!soundEnabled) {
                    ctx.font = '12px Courier New';
                    ctx.fillStyle = '#f00';
                    ctx.textAlign = 'right';
                    ctx.fillText('MUTED [B]', screenWidth - 150, 35);
                }

                // God mode indicator
                if (godMode) {
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillStyle = '#ff0';
                    ctx.textAlign = 'left';
                    ctx.fillText('GOD MODE [G]', 480, 15);
                }

                // Night vision indicator
                if (nightVisionMode) {
                    ctx.font = 'bold 14px Courier New';
                    ctx.fillStyle = '#0f0';
                    ctx.textAlign = 'left';
                    ctx.fillText('◉ IR MODE [N]', 10, screenHeight - 130);
                }

                // Simple controls indicator
                if (simpleControls) {
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillStyle = '#0af';
                    ctx.textAlign = 'left';
                    ctx.fillText('SIMPLE CTRL [T]', 580, 15);
                }

                // Weather indicator (show if not clear)
                if (weatherCondition !== 'clear') {
                    const weather = WEATHER_SETTINGS[weatherCondition];
                    ctx.font = 'bold 12px Courier New';
                    ctx.fillStyle = weatherCondition === 'night' ? '#448' :
                                   weatherCondition === 'storm' ? '#f80' : '#aaa';
                    ctx.textAlign = 'left';
                    ctx.fillText(`☁ ${weather.name} [M]`, 580, 35);

                    // Warning if visibility is very low and no night vision
                    if (weather.ambient < 0.3 && !nightVisionMode) {
                        const blinkOn = Math.floor(performance.now() / 500) % 2 === 0;
                        if (blinkOn) {
                            ctx.fillStyle = '#f00';
                            ctx.fillText('LOW VIS - USE NV [N]', 10, screenHeight - 150);
                        }
                    }
                }

                // Heading compass at top center
                renderCompass(heading);

                // Altitude ladder on right side
                renderAltitudeLadder();

                // ========================================
                // MISSILE WARNING (center screen)
                // ========================================
                if (missileWarning) {
                    const blinkOn = Math.floor(performance.now() / 150) % 2 === 0;
                    if (blinkOn) {
                        // Warning box
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        ctx.fillRect(screenWidth / 2 - 100, 75, 200, 35);
                        ctx.strokeStyle = '#f00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenWidth / 2 - 100, 75, 200, 35);

                        ctx.fillStyle = '#ff0000';
                        ctx.font = 'bold 20px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('⚠ MISSILE LOCK ⚠', screenWidth / 2, 98);
                    }
                }

                // Flight path predictor (trajectory line)
                renderFlightPathPredictor();

                // Targeting reticle in center
                renderReticle();

                // ========================================
                // WEAPON PANEL (bottom-left, above radar)
                // ========================================
                const radarSize = CONFIG.RADAR_SIZE; // 100px
                const weaponPanelX = 10;
                const weaponPanelY = screenHeight - radarSize - 10 - 125; // Above radar
                const weaponPanelW = 200;
                const weaponPanelH = 120;

                drawHUDPanel(weaponPanelX, weaponPanelY, weaponPanelW, weaponPanelH, 'WEAPONS');

                // Weapon list
                let weaponY = weaponPanelY + 28;
                for (let i = 0; i < weaponOrder.length; i++) {
                    const wKey = weaponOrder[i];
                    const w = WEAPONS[wKey];
                    const state = weaponState[wKey];
                    const isSelected = i === currentWeaponIndex;

                    // Selection indicator
                    if (isSelected) {
                        // Highlight background
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.15)';
                        ctx.fillRect(weaponPanelX + 4, weaponY - 11, weaponPanelW - 8, 18);

                        // Selection arrow
                        ctx.fillStyle = '#0f0';
                        ctx.beginPath();
                        ctx.moveTo(weaponPanelX + 8, weaponY - 5);
                        ctx.lineTo(weaponPanelX + 14, weaponY);
                        ctx.lineTo(weaponPanelX + 8, weaponY + 5);
                        ctx.closePath();
                        ctx.fill();
                    }
                
                // Weapon color bar
                ctx.fillStyle = w.color;
                ctx.fillRect(weaponPanelX + 18, weaponY - 8, 4, 14);
                
                // Weapon key and name
                ctx.font = isSelected ? 'bold 13px Courier New' : '12px Courier New';
                ctx.fillStyle = isSelected ? '#0f0' : '#0a0';
                ctx.textAlign = 'left';
                ctx.save();
                ctx.beginPath();
                ctx.rect(weaponPanelX + 22, weaponY - 12, weaponPanelW - 90, 18);
                ctx.clip();
                ctx.fillText(`[${w.key}] ${w.name}`, weaponPanelX + 26, weaponY + 3);
                ctx.restore();
                
                // Ammo display
                ctx.textAlign = 'right';
                if (state.ammo === Infinity) {
                    ctx.fillStyle = isSelected ? '#0f0' : '#0a0';
                    ctx.fillText('∞', weaponPanelX + weaponPanelW - 10, weaponY + 3);
                } else {
                    // Ammo bar background
                    const ammoBarX = weaponPanelX + weaponPanelW - 55;
                    const ammoBarW = 40;
                    const maxAmmo = WEAPONS[wKey].maxAmmo;
                    const ammoPercent = state.ammo / maxAmmo;
                    
                    ctx.fillStyle = '#111';
                    ctx.fillRect(ammoBarX, weaponY - 6, ammoBarW, 10);
                    
                    // Ammo bar fill
                    let ammoColor = '#0f0';
                    if (ammoPercent <= 0.25) ammoColor = '#f00';
                    else if (ammoPercent <= 0.5) ammoColor = '#ff0';
                    ctx.fillStyle = isSelected ? ammoColor : (ammoPercent <= 0.25 ? '#800' : '#080');
                    ctx.fillRect(ammoBarX + 1, weaponY - 5, (ammoBarW - 2) * ammoPercent, 8);
                    
                    // Ammo count
                    ctx.font = 'bold 10px Courier New';
                    ctx.fillStyle = isSelected ? '#fff' : '#888';
                    ctx.textAlign = 'center';
                    ctx.fillText(state.ammo.toString(), ammoBarX + ammoBarW / 2, weaponY + 2);
                }
                
                weaponY += 22;
            }
            
            // ========================================
            // COUNTERMEASURES PANEL (bottom, next to radar)
            // ========================================
            const cmPanelX = radarSize + 20; // Right of radar (100 + 20 = 120)
            const cmPanelY = screenHeight - 75;
            const cmPanelW = 140;
            const cmPanelH = 65;
            
            drawHUDPanel(cmPanelX, cmPanelY, cmPanelW, cmPanelH, 'COUNTERMEASURES');
            
            // Chaff
            ctx.font = '12px Courier New';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#0af';
            ctx.fillText('[;] CHAFF', cmPanelX + 8, cmPanelY + 35);
            
            // Chaff count boxes
            const chaffCount = countermeasures.chaff.count;
            for (let i = 0; i < 10; i++) {
                const boxX = cmPanelX + 80 + i * 5;
                ctx.fillStyle = i < chaffCount ? '#0af' : '#222';
                ctx.fillRect(boxX, cmPanelY + 26, 4, 10);
            }
            
            // Flare
            ctx.fillStyle = '#fa0';
            ctx.fillText("['] FLARE", cmPanelX + 8, cmPanelY + 52);
            
            // Flare count boxes
            const flareCount = countermeasures.flare.count;
            for (let i = 0; i < 10; i++) {
                const boxX = cmPanelX + 80 + i * 5;
                ctx.fillStyle = i < flareCount ? '#fa0' : '#222';
                ctx.fillRect(boxX, cmPanelY + 43, 4, 10);
            }
            
            // ========================================
            // STATUS PANEL (bottom-right)
            // ========================================
            const statusPanelX = screenWidth - 160;
            const statusPanelY = screenHeight - 75;
            const statusPanelW = 150;
            const statusPanelH = 65;
            
            drawHUDPanel(statusPanelX, statusPanelY, statusPanelW, statusPanelH, 'STATUS');
            
            // Current weapon display
            const currentWeaponName = WEAPONS[weaponOrder[currentWeaponIndex]].name;
            ctx.font = 'bold 14px Courier New';
            ctx.fillStyle = WEAPONS[weaponOrder[currentWeaponIndex]].color;
            ctx.textAlign = 'center';
            ctx.fillText(currentWeaponName.toUpperCase(), statusPanelX + statusPanelW / 2, statusPanelY + 35);
            
            // Armed indicator
            ctx.font = '11px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.fillText('▶ ARMED ◀', statusPanelX + statusPanelW / 2, statusPanelY + 52);
            
            // Radar minimap
            renderRadar();
            
            // Terrain following radar (Comanche-style forward-looking)
            renderTerrainRadar();
            
            // Minimap (Comanche mode only - Delta has its own compass panel)
            renderMinimap();
        }

        if (gameState === GAME_STATES.PLAYING) {
            renderOnboardingHint();
        }
        }

        function renderOnboardingHint() {
            if (!showOnboardingHints || gameState !== GAME_STATES.PLAYING) return;

            for (const hint of ONBOARDING_HINTS) {
                if (hint.condition()) {
                    ctx.font = 'bold 14px Courier New';
                    ctx.fillStyle = '#ff0';
                    ctx.textAlign = 'center';
                    ctx.fillText('TIP: ' + hint.text, screenWidth / 2, screenHeight - 170);
                    return;
                }
            }
        }
        
        function renderObjectivesPanel() {
            if (gameState !== GAME_STATES.PLAYING) return;
            if (currentMissionIndex < 0) return; // No panel for free play
            if (!objectiveState.objectives || objectiveState.objectives.length === 0) return;
            
            const panelX = 10;
            // In Delta mode, position below the weapon panel (which ends at ~105px)
            // In Comanche mode, position below the standard HUD elements
            const panelY = (gameMode === GAME_MODES.DELTA) ? 115 : 55;
            const panelWidth = 240;
            const lineHeight = 20;
            const padding = 10;
            const headerHeight = 26;
            const panelHeight = headerHeight + padding * 2 + objectiveState.objectives.length * lineHeight + 4;
            
            // Panel background with gradient
            const grad = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelHeight);
            grad.addColorStop(0, 'rgba(0, 25, 0, 0.9)');
            grad.addColorStop(1, 'rgba(0, 15, 0, 0.85)');
            ctx.fillStyle = grad;
            ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
            
            // Border with subtle glow
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.strokeRect(panelX - 1, panelY - 1, panelWidth + 2, panelHeight + 2);
            
            // Header with accent bar
            ctx.fillStyle = 'rgba(0, 50, 0, 0.95)';
            ctx.fillRect(panelX, panelY, panelWidth, headerHeight);
            ctx.fillStyle = '#0f0';
            ctx.fillRect(panelX, panelY + headerHeight - 2, panelWidth, 2);
            
            ctx.font = 'bold 13px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText('MISSION OBJECTIVES', panelX + padding, panelY + 17);
            
            // Objectives list
            let y = panelY + headerHeight + padding + 14;
            
            for (const obj of objectiveState.objectives) {
                // Status indicator with better icons
                let statusIcon, statusColor, bgColor;
                if (obj.complete) {
                    statusIcon = '\u2713'; // Checkmark
                    statusColor = '#0f0';
                    bgColor = 'rgba(0, 100, 0, 0.3)';
                } else if (obj.failed) {
                    statusIcon = '\u2717'; // X mark
                    statusColor = '#f00';
                    bgColor = 'rgba(100, 0, 0, 0.3)';
                } else {
                    statusIcon = '\u25cb'; // Circle
                    statusColor = '#888';
                    bgColor = null;
                }
                
                // Row background for completed/failed
                if (bgColor) {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(panelX + 2, y - 12, panelWidth - 4, lineHeight - 2);
                }
                
                // Status icon
                ctx.font = '12px Courier New';
                ctx.fillStyle = statusColor;
                ctx.fillText(statusIcon, panelX + padding, y);
                
                // Objective description (truncated if needed)
                const descMaxLen = 20;
                let desc = obj.description || 'Unknown objective';
                if (desc.length > descMaxLen) {
                    desc = desc.substring(0, descMaxLen - 2) + '..';
                }
                
                ctx.font = '11px Courier New';
                ctx.fillStyle = obj.complete ? '#0a0' : (obj.failed ? '#800' : '#0c0');
                ctx.fillText(desc, panelX + padding + 18, y);
                
                // Progress (right-aligned) with highlight
                const progress = getObjectiveProgressText(obj);
                ctx.textAlign = 'right';
                ctx.font = 'bold 11px Courier New';
                ctx.fillStyle = obj.complete ? '#0f0' : (obj.failed ? '#f00' : '#ff0');
                ctx.fillText(progress, panelX + panelWidth - padding, y);
                ctx.textAlign = 'left';
                
                y += lineHeight;
            }
        }
        
        function renderMissionTimer() {
            const mission = getActiveMission();
            if (!mission || !mission.timeLimit) return;
            
            const mins = Math.floor(missionTime / 60);
            const secs = Math.floor(missionTime % 60);
            const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            // Flash red when under 30 seconds
            const isLowTime = missionTime < 30;
            const blinkOn = Math.floor(performance.now() / 250) % 2 === 0;
            
            ctx.font = 'bold 28px Courier New';
            ctx.textAlign = 'center';
            
            if (isLowTime) {
                ctx.fillStyle = blinkOn ? '#ff0000' : '#880000';
            } else {
                ctx.fillStyle = '#00ff00';
            }
            
            // Draw timer below compass
            ctx.fillText(timeStr, screenWidth / 2, 85);
            
            // Label
            ctx.font = '12px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.fillText('TIME', screenWidth / 2, 98);
        }
        
        function renderCompass(heading) {
            const compassWidth = 250;
            const compassX = screenWidth / 2 - compassWidth / 2;
            const compassY = 8;
            const compassHeight = 28;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(compassX, compassY, compassWidth, compassHeight);
            
            // Border
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(compassX, compassY, compassWidth, compassHeight);
            
            // Clip to compass bounds
            ctx.save();
            ctx.beginPath();
            ctx.rect(compassX + 1, compassY + 1, compassWidth - 2, compassHeight - 2);
            ctx.clip();
            
            // Draw tick marks and labels for every 10 degrees
            const pixelsPerDegree = 2;
            ctx.font = 'bold 11px Courier New';
            ctx.textAlign = 'center';
            
            // Cardinal and ordinal directions
            const cardinals = {
                0: 'N', 45: 'NE', 90: 'E', 135: 'SE',
                180: 'S', 225: 'SW', 270: 'W', 315: 'NW'
            };
            
            for (let deg = -180; deg <= 540; deg += 5) {
                let normDeg = ((deg % 360) + 360) % 360;
                let diff = deg - heading;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                
                if (Math.abs(diff) < compassWidth / 2 / pixelsPerDegree) {
                    const x = screenWidth / 2 + diff * pixelsPerDegree;
                    
                    // Draw tick
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    if (deg % 10 === 0) {
                        // Long tick for every 10 degrees
                        ctx.moveTo(x, compassY + compassHeight - 10);
                        ctx.lineTo(x, compassY + compassHeight - 2);
                        ctx.stroke();
                        
                        // Label
                        if (cardinals[normDeg]) {
                            ctx.fillStyle = '#0f0';
                            ctx.fillText(cardinals[normDeg], x, compassY + 14);
                        } else if (deg % 30 === 0) {
                            // Show degree number every 30 degrees
                            ctx.fillStyle = '#0a0';
                            ctx.font = '9px Courier New';
                            ctx.fillText(normDeg.toString(), x, compassY + 14);
                            ctx.font = 'bold 11px Courier New';
                        }
                    } else {
                        // Short tick for every 5 degrees
                        ctx.moveTo(x, compassY + compassHeight - 6);
                        ctx.lineTo(x, compassY + compassHeight - 2);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.restore();
            
            // Center marker (current heading indicator)
            ctx.fillStyle = '#ff0';
            ctx.beginPath();
            ctx.moveTo(screenWidth / 2, compassY - 2);
            ctx.lineTo(screenWidth / 2 - 6, compassY + 6);
            ctx.lineTo(screenWidth / 2 + 6, compassY + 6);
            ctx.closePath();
            ctx.fill();
            
            // Heading readout (removed - keep compass visual only)
            // ctx.font = 'bold 12px Courier New';
            // ctx.fillStyle = '#0f0';
            // ctx.textAlign = 'center';
            // const headingStr = Math.round(heading).toString().padStart(3, '0');
            // ctx.fillText(headingStr + '°', screenWidth / 2, compassY + compassHeight + 12);
        }
        
        function renderAltitudeLadder() {
            // Altitude ladder on right side (like Comanche)
            const ladderX = screenWidth - 50;
            const ladderY = screenHeight / 2 - 100;
            const ladderHeight = 200;
            const ladderWidth = 40;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(ladderX, ladderY, ladderWidth, ladderHeight);
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(ladderX, ladderY, ladderWidth, ladderHeight);
            
            // Current altitude
            const altitude = Math.round(camera.height);
            const altPerPixel = 2;  // Altitude units per pixel
            
            // Draw tick marks and altitude labels
            ctx.save();
            ctx.beginPath();
            ctx.rect(ladderX, ladderY, ladderWidth, ladderHeight);
            ctx.clip();
            
            const centerY = ladderY + ladderHeight / 2;
            
            // Draw altitude scale
            for (let alt = Math.floor((altitude - 100) / 10) * 10; alt <= altitude + 100; alt += 10) {
                const yOffset = (altitude - alt) / altPerPixel;
                const y = centerY + yOffset;
                
                if (y >= ladderY && y <= ladderY + ladderHeight) {
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    if (alt % 50 === 0) {
                        // Long tick with label
                        ctx.moveTo(ladderX, y);
                        ctx.lineTo(ladderX + 15, y);
                        ctx.stroke();
                        
                        ctx.font = '10px Courier New';
                        ctx.fillStyle = '#0f0';
                        ctx.textAlign = 'left';
                        ctx.fillText(alt.toString(), ladderX + 18, y + 3);
                    } else {
                        // Short tick
                        ctx.moveTo(ladderX, y);
                        ctx.lineTo(ladderX + 8, y);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.restore();
            
            // Current altitude indicator (center reference) - REMOVED: caused floating line artifact
            // ctx.strokeStyle = '#ff0';
            // ctx.lineWidth = 2;
            // ctx.beginPath();
            // ctx.moveTo(ladderX - 5, centerY);
            // ctx.lineTo(ladderX + 5, centerY - 5);
            // ctx.lineTo(ladderX + 5, centerY + 5);
            // ctx.closePath();
            // ctx.stroke();
            
            // Digital altitude readout
            ctx.fillStyle = '#0f0';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(altitude.toString(), ladderX + ladderWidth / 2, ladderY + ladderHeight + 18);
            
            // Vertical speed indicator
            const vspeed = Math.round((camera.verticalSpeed || 0) * 10);
            if (vspeed !== 0) {
                ctx.font = '10px Courier New';
                ctx.fillStyle = vspeed > 0 ? '#0f0' : '#f80';
                const vspeedStr = (vspeed > 0 ? '+' : '') + vspeed;
                ctx.fillText(vspeedStr, ladderX + ladderWidth / 2, ladderY - 5);
            }
        }
        
        function renderFlightPathPredictor() {
            // Flight path predictor shows where helicopter will fly based on current bank/speed
            // Inspired by Comanche's trajectory indicator
            
            const cx = screenWidth / 2;
            const cy = screenHeight / 2;
            const bankAngle = camera.bank || 0;
            const forwardSpeed = Math.abs(camera.forwardSpeed || 0);
            const yawRate = camera.yawRate || 0;
            
            // Only show when moving
            if (forwardSpeed < 0.5) return;
            
            ctx.save();
            
            // Dashed line style
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            
            // Predict path over next ~2 seconds
            let px = cx;
            let py = cy;
            let angle = 0;  // Relative to screen center
            const steps = 30;
            const timeStep = 0.07;  // Time per step
            
            for (let i = 0; i < steps; i++) {
                // Integrate position based on current yaw rate
                // Yaw rate causes curving path on screen
                const turnFactor = yawRate * 800;  // Scale for screen
                const advanceFactor = forwardSpeed * 3;
                
                angle += turnFactor * timeStep;
                
                // Move forward (up on screen) and curve based on bank/yaw
                px += Math.sin(angle) * advanceFactor;
                py -= Math.cos(angle) * advanceFactor * 0.5;  // Less vertical movement
                
                ctx.lineTo(px, py);
                
                // Fade out towards the end
                if (i > steps * 0.7) {
                    ctx.globalAlpha = 1 - (i - steps * 0.7) / (steps * 0.3);
                }
            }
            
            ctx.stroke();
            
            // Prediction marker at end
            ctx.globalAlpha = 0.5;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.arc(px, py, 5, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function renderReticle() {
            const cx = screenWidth / 2;
            const cy = screenHeight / 2;
            const size = 30;
            const bankAngle = camera.bank || 0;
            const hitAlpha = hitMarkerTime > 0 ? Math.min(1, hitMarkerTime / 140) : 0;
            const hitPulse = hitAlpha * hitMarkerIntensity;
            
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(bankAngle);  // Rotate reticle with bank angle
            
            ctx.strokeStyle = hitAlpha > 0 ? `rgba(255, 255, 255, ${0.6 + 0.4 * hitAlpha})` : '#0f0';
            ctx.lineWidth = hitAlpha > 0 ? 3 : 2;
            
            // Outer circle
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.stroke();
            
            // Crosshair lines (rotate with bank)
            ctx.beginPath();
            // Top
            ctx.moveTo(0, -size - 10);
            ctx.lineTo(0, -size + 10);
            // Bottom
            ctx.moveTo(0, size - 10);
            ctx.lineTo(0, size + 10);
            // Left
            ctx.moveTo(-size - 10, 0);
            ctx.lineTo(-size + 10, 0);
            // Right
            ctx.moveTo(size - 10, 0);
            ctx.lineTo(size + 10, 0);
            ctx.stroke();
            
            // Center dot
            ctx.fillStyle = hitAlpha > 0 ? `rgba(255, 80, 80, ${0.8 * hitAlpha})` : '#0f0';
            ctx.beginPath();
            ctx.arc(0, 0, 3, 0, Math.PI * 2);
            ctx.fill();

            // Hit marker brackets
            if (hitAlpha > 0) {
                ctx.strokeStyle = `rgba(255, 80, 80, ${0.8 * hitPulse})`;
                ctx.lineWidth = 2;
                const markerSize = size + 8;
                ctx.beginPath();
                ctx.moveTo(-markerSize, -markerSize);
                ctx.lineTo(-markerSize + 10, -markerSize + 10);
                ctx.moveTo(markerSize, -markerSize);
                ctx.lineTo(markerSize - 10, -markerSize + 10);
                ctx.moveTo(-markerSize, markerSize);
                ctx.lineTo(-markerSize + 10, markerSize - 10);
                ctx.moveTo(markerSize, markerSize);
                ctx.lineTo(markerSize - 10, markerSize - 10);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // === ATTITUDE INDICATOR (Bank/Pitch) ===
            // Position at bottom center of screen, above the controls area
            renderAttitudeIndicator(screenWidth / 2, screenHeight - 60);
            
            // === TARGETING SYSTEM OVERLAY ===
            renderTargetingOverlay();
            
            // === RESUPPLY INDICATOR ===
            renderResupplyIndicator();
        }
        
        function renderResupplyIndicator() {
            const nearest = getNearestFriendlyHelipad(camera.x, camera.y);
            if (!nearest) return;
            
            const range = nearest.isBase ? RESUPPLY.range * 1.5 : RESUPPLY.range;
            const atResupply = isAtResupplyPoint();
            
            // Show distance to nearest friendly base if within 200 units
            if (nearest.distance < 200) {
                const cx = screenWidth / 2;
                const cy = screenHeight - 140;
                
                if (atResupply) {
                    // Resupplying indicator
                    const blinkOn = Math.floor(performance.now() / 300) % 2 === 0;
                    ctx.font = 'bold 16px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = blinkOn ? '#00ff00' : '#00aa00';
                    ctx.fillText('>>> RESUPPLYING <<<', cx, cy);
                    ctx.font = '12px Courier New';
                    ctx.fillStyle = '#0a0';
                    ctx.fillText('Ammo and health restoring...', cx, cy + 18);
                } else if (nearest.distance < 100) {
                    // Close to base but not resupplying (need to land in Comanche)
                    ctx.font = 'bold 14px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#ffaa00';
                    if (gameMode === GAME_MODES.COMANCHE) {
                        ctx.fillText('LAND TO RESUPPLY', cx, cy);
                    } else {
                        ctx.fillText('MOVE CLOSER TO RESUPPLY', cx, cy);
                    }
                    ctx.font = '11px Courier New';
                    ctx.fillStyle = '#aa8800';
                    ctx.fillText(`Distance: ${Math.round(nearest.distance)}m`, cx, cy + 15);
                }
            }
        }
        
        function renderTargetingOverlay() {
            const validTypes = targetingSystem.getValidTargetTypes();
            
            // Don't show targeting overlay for weapons that don't need lock
            if (!validTypes.requiresLock) return;
            
            const cam = gameMode === GAME_MODES.DELTA ? getDeltaCamera() : camera;
            const sinAngle = Math.sin(cam.angle);
            const cosAngle = Math.cos(cam.angle);
            const pitchFactor = (cam.horizon - screenHeight / 2) / 240.0;
            
            // Get all visible targets using weapon-appropriate range
            // getTargetsInView already filters by domain based on current weapon
            const visibleTargets = getTargetsInView(cam, targetingSystem.getTargetingRange());
            
            for (const targetInfo of visibleTargets) {
                const target = targetInfo.target;
                const isSelected = target === targetingSystem.selectedTarget;
                const isLocked = target === targetingSystem.lockedTarget;
                
                // Calculate screen position
                let dx = target.x - cam.x;
                let dy = target.y - cam.y;
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = -dx * sinAngle - dy * cosAngle;
                
                if (ry < 10) continue;
                
                const scaleX = (screenWidth / 2) / ry;
                const scaleY = 240.0 / ry;
                const screenX = screenWidth / 2 + rx * scaleX;
                
                // Apply bank tilt
                const bankTiltFactor = Math.sin(cam.bank || 0) * 0.3;
                const bankOffset = (screenX - screenWidth / 2) * bankTiltFactor;
                const screenY = (cam.height - target.z) * scaleY + cam.horizon + bankOffset;
                
                // Skip if off screen
                if (screenX < 0 || screenX > screenWidth || screenY < 50 || screenY > screenHeight - 50) continue;
                
                // Calculate bracket size based on distance
                const bracketSize = Math.max(15, Math.min(40, 800 / dist));
                
                ctx.save();
                
                if (isLocked) {
                    // LOCKED - Diamond shape, bright red/orange
                    ctx.strokeStyle = '#ff4400';
                    ctx.fillStyle = 'rgba(255, 68, 0, 0.2)';
                    ctx.lineWidth = 3;
                    
                    // Diamond
                    ctx.beginPath();
                    ctx.moveTo(screenX, screenY - bracketSize);
                    ctx.lineTo(screenX + bracketSize, screenY);
                    ctx.lineTo(screenX, screenY + bracketSize);
                    ctx.lineTo(screenX - bracketSize, screenY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // "LOCK" text
                    ctx.font = 'bold 10px Courier New';
                    ctx.fillStyle = '#ff4400';
                    ctx.textAlign = 'center';
                    ctx.fillText('LOCK', screenX, screenY - bracketSize - 8);
                    
                } else if (isSelected) {
                    // SELECTED - Square brackets, yellow, with lock progress
                    const lockProgress = targetingSystem.lockProgress / 100;
                    ctx.strokeStyle = targetingSystem.isLocking ? '#ffaa00' : '#ffff00';
                    ctx.lineWidth = 2;
                    
                    // Animated brackets that shrink as lock progresses
                    const animSize = bracketSize * (1.5 - lockProgress * 0.5);
                    const cornerLen = animSize * 0.4;
                    
                    // Top-left corner
                    ctx.beginPath();
                    ctx.moveTo(screenX - animSize, screenY - animSize + cornerLen);
                    ctx.lineTo(screenX - animSize, screenY - animSize);
                    ctx.lineTo(screenX - animSize + cornerLen, screenY - animSize);
                    ctx.stroke();
                    
                    // Top-right corner
                    ctx.beginPath();
                    ctx.moveTo(screenX + animSize - cornerLen, screenY - animSize);
                    ctx.lineTo(screenX + animSize, screenY - animSize);
                    ctx.lineTo(screenX + animSize, screenY - animSize + cornerLen);
                    ctx.stroke();
                    
                    // Bottom-left corner
                    ctx.beginPath();
                    ctx.moveTo(screenX - animSize, screenY + animSize - cornerLen);
                    ctx.lineTo(screenX - animSize, screenY + animSize);
                    ctx.lineTo(screenX - animSize + cornerLen, screenY + animSize);
                    ctx.stroke();
                    
                    // Bottom-right corner
                    ctx.beginPath();
                    ctx.moveTo(screenX + animSize - cornerLen, screenY + animSize);
                    ctx.lineTo(screenX + animSize, screenY + animSize);
                    ctx.lineTo(screenX + animSize, screenY + animSize - cornerLen);
                    ctx.stroke();
                    
                    // Lock progress bar (if locking)
                    if (targetingSystem.isLocking && validTypes.requiresLock) {
                        const barWidth = animSize * 2;
                        const barHeight = 4;
                        const barY = screenY + animSize + 8;
                        
                        // Background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                        ctx.fillRect(screenX - barWidth/2, barY, barWidth, barHeight);
                        
                        // Progress fill
                        ctx.fillStyle = lockProgress > 0.8 ? '#00ff00' : '#ffaa00';
                        ctx.fillRect(screenX - barWidth/2, barY, barWidth * lockProgress, barHeight);
                        
                        // Border
                        ctx.strokeStyle = '#ffaa00';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(screenX - barWidth/2, barY, barWidth, barHeight);
                    }
                    
                    // Target info
                    ctx.font = '9px Courier New';
                    ctx.fillStyle = '#ffff00';
                    ctx.textAlign = 'center';
                    const typeName = target.type.replace('_', ' ').toUpperCase();
                    ctx.fillText(`${typeName}`, screenX, screenY - animSize - 12);
                    ctx.fillText(`${Math.round(dist)}m`, screenX, screenY + animSize + 22);
                    
                } else {
                    // UNSELECTED - Simple brackets, dim green
                    ctx.strokeStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.lineWidth = 1;
                    
                    const cornerLen = bracketSize * 0.3;
                    
                    // Just corners
                    ctx.beginPath();
                    // Top-left
                    ctx.moveTo(screenX - bracketSize, screenY - bracketSize + cornerLen);
                    ctx.lineTo(screenX - bracketSize, screenY - bracketSize);
                    ctx.lineTo(screenX - bracketSize + cornerLen, screenY - bracketSize);
                    // Top-right
                    ctx.moveTo(screenX + bracketSize - cornerLen, screenY - bracketSize);
                    ctx.lineTo(screenX + bracketSize, screenY - bracketSize);
                    ctx.lineTo(screenX + bracketSize, screenY - bracketSize + cornerLen);
                    // Bottom-left
                    ctx.moveTo(screenX - bracketSize, screenY + bracketSize - cornerLen);
                    ctx.lineTo(screenX - bracketSize, screenY + bracketSize);
                    ctx.lineTo(screenX - bracketSize + cornerLen, screenY + bracketSize);
                    // Bottom-right
                    ctx.moveTo(screenX + bracketSize - cornerLen, screenY + bracketSize);
                    ctx.lineTo(screenX + bracketSize, screenY + bracketSize);
                    ctx.lineTo(screenX + bracketSize, screenY + bracketSize - cornerLen);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Targeting system status in HUD
            renderTargetingStatus();
        }
        
        function renderTargetingStatus() {
            const validTypes = targetingSystem.getValidTargetTypes();
            const weapon = gameMode === GAME_MODES.DELTA 
                ? soldierWeapon.current 
                : weaponOrder[currentWeaponIndex];
            
            // Only show targeting status for lock-on weapons
            if (!validTypes.requiresLock) return;
            
            const statusX = screenWidth / 2;
            const statusY = 70;
            
            ctx.save();
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            
            if (targetingSystem.lockedTarget) {
                // Locked - diamond indicator on target is sufficient, no text needed
            } else if (targetingSystem.selectedTarget && targetingSystem.isLocking) {
                // Acquiring lock
                ctx.fillStyle = '#ffaa00';
                const progress = Math.round(targetingSystem.lockProgress);
                ctx.fillText(`ACQUIRING LOCK... ${progress}%`, statusX, statusY);
            } else if (targetingSystem.selectedTarget) {
                // Target selected but not locking
                ctx.fillStyle = '#00ff00';
                ctx.fillText('[F] HOLD TO LOCK', statusX, statusY);
            } else {
                // No target
                ctx.fillStyle = '#888888';
                const targetType = validTypes.domain === DOMAINS.AIR ? 'AIR' : 'GROUND';
                ctx.fillText(`NO ${targetType} TARGET`, statusX, statusY);
            }
            
            ctx.restore();
        }
        
        function renderAttitudeIndicator(cx, cy) {
            const width = 120;
            const height = 40;
            const bankAngle = camera.bank || 0;
            const pitchOffset = (camera.pitch || 0) * 30;
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(cx - width/2, cy - height/2, width, height);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(cx - width/2, cy - height/2, width, height);
            
            // Clip to indicator bounds
            ctx.save();
            ctx.beginPath();
            ctx.rect(cx - width/2 + 2, cy - height/2 + 2, width - 4, height - 4);
            ctx.clip();
            
            // Draw artificial horizon line (tilted by bank, offset by pitch)
            ctx.save();
            ctx.translate(cx, cy + pitchOffset);
            ctx.rotate(bankAngle);
            
            // Sky (above horizon)
            ctx.fillStyle = '#234';
            ctx.fillRect(-width, -height * 2, width * 2, height * 2);
            
            // Ground (below horizon)
            ctx.fillStyle = '#432';
            ctx.fillRect(-width, 0, width * 2, height * 2);
            
            // Horizon line
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-width, 0);
            ctx.lineTo(width, 0);
            ctx.stroke();
            
            // Pitch ladder lines
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 1;
            for (let p = -20; p <= 20; p += 10) {
                if (p !== 0) {
                    const y = -p * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(-20, y);
                    ctx.lineTo(20, y);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            ctx.restore();
            
            // Aircraft reference symbol (fixed, doesn't rotate)
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Left wing
            ctx.moveTo(cx - 25, cy);
            ctx.lineTo(cx - 10, cy);
            // Right wing
            ctx.moveTo(cx + 10, cy);
            ctx.lineTo(cx + 25, cy);
            // Center mark
            ctx.moveTo(cx - 3, cy);
            ctx.lineTo(cx + 3, cy);
            ctx.moveTo(cx, cy - 3);
            ctx.lineTo(cx, cy + 3);
            ctx.stroke();
            
            // Bank angle indicator arc at top
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy - height/2 + 5, 35, Math.PI * 1.25, Math.PI * 1.75);
            ctx.stroke();
            
            // Bank angle marker (triangle pointing to current bank)
            ctx.save();
            ctx.translate(cx, cy - height/2 + 5);
            ctx.rotate(bankAngle);
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(0, -35);
            ctx.lineTo(-4, -28);
            ctx.lineTo(4, -28);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        
        function renderRadar() {
            const radarSize = CONFIG.RADAR_SIZE;
            const radarX = 10;
            const radarY = screenHeight - radarSize - 10;
            const radarCenterX = radarX + radarSize / 2;
            const radarCenterY = radarY + radarSize / 2;
            
            // Radar background
            ctx.fillStyle = 'rgba(0, 20, 0, 0.7)';
            ctx.fillRect(radarX, radarY, radarSize, radarSize);
            
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(radarX, radarY, radarSize, radarSize);
            
            // Radar circles
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(radarCenterX, radarCenterY, radarSize / 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(radarCenterX, radarCenterY, radarSize / 2 - 5, 0, Math.PI * 2);
            ctx.stroke();
            
            // Cross lines
            ctx.beginPath();
            ctx.moveTo(radarCenterX, radarY + 5);
            ctx.lineTo(radarCenterX, radarY + radarSize - 5);
            ctx.moveTo(radarX + 5, radarCenterY);
            ctx.lineTo(radarX + radarSize - 5, radarCenterY);
            ctx.stroke();
            
            // Draw targets on radar
            const scale = (radarSize / 2 - 5) / CONFIG.RADAR_RANGE;
            
            for (const target of targets) {
                if (target.destroyed) continue;
                
                // Calculate relative position
                let dx = target.x - camera.x;
                let dy = target.y - camera.y;
                
                // Handle map wrapping
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > CONFIG.RADAR_RANGE) continue;
                
                // Rotate to match camera heading (inverted so radar rotates with player view)
                const sinAngle = Math.sin(-camera.angle);
                const cosAngle = Math.cos(-camera.angle);
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = dx * sinAngle + dy * cosAngle;
                
                const radarTargetX = radarCenterX + rx * scale;
                const radarTargetY = radarCenterY - ry * scale;
                
                // Draw target dot - different colors for different types
                if (target.type === 'sam') {
                    ctx.fillStyle = '#ff6600'; // Orange for SAM
                } else if (target.type === 'tank') {
                    ctx.fillStyle = '#ff0000'; // Red for tank
                } else if (target.type === 'soldier') {
                    ctx.fillStyle = '#ffcc00'; // Yellow-orange for infantry
                } else {
                    ctx.fillStyle = '#ffff00'; // Yellow for building
                }
                ctx.beginPath();
                ctx.arc(radarTargetX, radarTargetY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw enemy missiles on radar
            for (const ep of enemyProjectiles) {
                let dx = ep.x - camera.x;
                let dy = ep.y - camera.y;
                
                if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > CONFIG.RADAR_RANGE) continue;
                
                const sinAngle = Math.sin(-camera.angle);
                const cosAngle = Math.cos(-camera.angle);
                const rx = dx * cosAngle - dy * sinAngle;
                const ry = dx * sinAngle + dy * cosAngle;
                
                const radarX2 = radarCenterX + rx * scale;
                const radarY2 = radarCenterY - ry * scale;
                
                // Blinking missile indicator
                const blinkOn = Math.floor(performance.now() / 100) % 2 === 0;
                if (blinkOn) {
                    ctx.fillStyle = '#ff00ff'; // Magenta for incoming missiles
                    ctx.beginPath();
                    ctx.arc(radarX2, radarY2, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw extraction/reach objectives on radar
            const mission = getActiveMission();
            if (mission && mission.objectives) {
                for (const obj of mission.objectives) {
                    if (obj.type === 'reach_location' && !obj.completed) {
                        let dx = obj.x - camera.x;
                        let dy = obj.y - camera.y;
                        
                        if (dx > CONFIG.MAP_SIZE / 2) dx -= CONFIG.MAP_SIZE;
                        if (dx < -CONFIG.MAP_SIZE / 2) dx += CONFIG.MAP_SIZE;
                        if (dy > CONFIG.MAP_SIZE / 2) dy -= CONFIG.MAP_SIZE;
                        if (dy < -CONFIG.MAP_SIZE / 2) dy += CONFIG.MAP_SIZE;
                        
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Rotate to match camera heading
                        const sinAngle = Math.sin(-camera.angle);
                        const cosAngle = Math.cos(-camera.angle);
                        const rx = dx * cosAngle - dy * sinAngle;
                        const ry = dx * sinAngle + dy * cosAngle;
                        
                        // Clamp to radar edge if outside range
                        let radarDist = dist * scale;
                        const maxRadarDist = radarSize / 2 - 8;
                        if (radarDist > maxRadarDist) {
                            radarDist = maxRadarDist;
                        }
                        const angle = Math.atan2(rx, -ry);
                        const clampedRx = Math.sin(angle) * radarDist;
                        const clampedRy = -Math.cos(angle) * radarDist;
                        
                        const objX = radarCenterX + (dist <= CONFIG.RADAR_RANGE ? rx * scale : clampedRx);
                        const objY = radarCenterY - (dist <= CONFIG.RADAR_RANGE ? ry * scale : clampedRy);
                        
                        // Draw extraction point as blinking cyan diamond
                        const blinkOn = Math.floor(performance.now() / 400) % 2 === 0;
                        ctx.fillStyle = blinkOn ? '#00ffff' : '#008888';
                        ctx.beginPath();
                        ctx.moveTo(objX, objY - 5);
                        ctx.lineTo(objX + 4, objY);
                        ctx.lineTo(objX, objY + 5);
                        ctx.lineTo(objX - 4, objY);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            
            // Draw player (triangle pointing up = forward)
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(radarCenterX, radarCenterY - 6);
            ctx.lineTo(radarCenterX - 4, radarCenterY + 4);
            ctx.lineTo(radarCenterX + 4, radarCenterY + 4);
            ctx.closePath();
            ctx.fill();
            
            // Radar label
            ctx.font = '10px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText('RADAR', radarX + 5, radarY + 12);
        }

        function renderMinimap() {
            const mapSize = 120;
            const mapX = screenWidth - mapSize - 15;
            const mapY = 50;  // Below top bar
            const scale = mapSize / CONFIG.MAP_SIZE;

            ctx.fillStyle = 'rgba(0, 20, 0, 0.8)';
            ctx.fillRect(mapX, mapY, mapSize, mapSize);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.strokeRect(mapX, mapY, mapSize, mapSize);

            ctx.fillStyle = '#f00';
            for (const base of world.bases) {
                const bx = mapX + base.x * scale;
                const by = mapY + base.y * scale;
                ctx.fillRect(bx - 2, by - 2, 4, 4);
            }

            ctx.fillStyle = '#f80';
            for (const airport of world.airports) {
                const ax = mapX + airport.x * scale;
                const ay = mapY + airport.y * scale;
                ctx.fillRect(ax - 3, ay - 1, 6, 2);
            }

            ctx.fillStyle = '#f00';
            for (const target of targets) {
                if (target.destroyed) continue;
                if (target.domain === DOMAINS.AIR) {
                    const tx = mapX + target.x * scale;
                    const ty = mapY + target.y * scale;
                    ctx.beginPath();
                    ctx.arc(tx, ty, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.fillStyle = '#0f0';
            const px = mapX + camera.x * scale;
            const py = mapY + camera.y * scale;

            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(-camera.angle + Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(0, -4);
            ctx.lineTo(-3, 3);
            ctx.lineTo(3, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            if (gameMode === GAME_MODES.DELTA && playerState.heli.visible) {
                ctx.fillStyle = '#0ff';
                const hx = mapX + playerState.heli.x * scale;
                const hy = mapY + playerState.heli.y * scale;
                ctx.fillRect(hx - 2, hy - 2, 4, 4);
            }

            ctx.font = '9px Courier New';
            ctx.fillStyle = '#0a0';
            ctx.textAlign = 'left';
            ctx.fillText('TACTICAL MAP', mapX + 3, mapY + mapSize - 3);
        }
        
        // ============================================
        // TERRAIN FOLLOWING RADAR (Comanche-style)
        // Shows terrain height profile ahead of helicopter
        // ============================================
        function renderTerrainRadar() {
            if (!currentMap.altitude) return;
            
            // Position: bottom center, above the HUD bar
            const tfWidth = 200;
            const tfHeight = 60;
            const tfX = screenWidth / 2 - tfWidth / 2;
            const tfY = screenHeight - tfHeight - 85;  // Above countermeasures panel
            
            // Background panel
            ctx.fillStyle = 'rgba(0, 20, 0, 0.85)';
            ctx.fillRect(tfX, tfY, tfWidth, tfHeight);
            
            // Border
            ctx.strokeStyle = '#0a0';
            ctx.lineWidth = 1;
            ctx.strokeRect(tfX + 1, tfY + 1, tfWidth - 2, tfHeight - 2);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.strokeRect(tfX, tfY, tfWidth, tfHeight);
            
            // Corner accents
            const cornerSize = 5;
            ctx.fillStyle = '#0f0';
            ctx.fillRect(tfX, tfY, cornerSize, 2);
            ctx.fillRect(tfX, tfY, 2, cornerSize);
            ctx.fillRect(tfX + tfWidth - cornerSize, tfY, cornerSize, 2);
            ctx.fillRect(tfX + tfWidth - 2, tfY, 2, cornerSize);
            ctx.fillRect(tfX, tfY + tfHeight - 2, cornerSize, 2);
            ctx.fillRect(tfX, tfY + tfHeight - cornerSize, 2, cornerSize);
            ctx.fillRect(tfX + tfWidth - cornerSize, tfY + tfHeight - 2, cornerSize, 2);
            ctx.fillRect(tfX + tfWidth - 2, tfY + tfHeight - cornerSize, 2, cornerSize);
            
            // Title
            ctx.font = 'bold 9px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'center';
            ctx.fillText('TERRAIN RADAR', tfX + tfWidth / 2, tfY + 10);
            
            // Scan range (how far ahead to look)
            const scanRange = 300;  // Units ahead
            const numSamples = 40;  // Number of terrain samples
            const graphX = tfX + 10;
            const graphWidth = tfWidth - 20;
            const graphY = tfY + 15;
            const graphHeight = tfHeight - 22;
            
            // Calculate direction vectors
            const sinAngle = Math.sin(camera.angle);
            const cosAngle = Math.cos(camera.angle);
            
            // Sample terrain heights ahead
            const terrainHeights = [];
            let maxHeight = camera.height;  // Track max for scaling
            let minHeight = 0;
            
            for (let i = 0; i < numSamples; i++) {
                const dist = (i / numSamples) * scanRange;
                
                // Calculate world position ahead of helicopter
                let sampleX = camera.x - sinAngle * dist;
                let sampleY = camera.y - cosAngle * dist;
                
                // Wrap around map
                sampleX = ((sampleX % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                sampleY = ((sampleY % CONFIG.MAP_SIZE) + CONFIG.MAP_SIZE) % CONFIG.MAP_SIZE;
                
                const height = getTerrainHeight(sampleX, sampleY);
                terrainHeights.push(height);
                
                if (height > maxHeight) maxHeight = height;
            }
            
            // Add margin to max height for display
            maxHeight = Math.max(maxHeight + 50, camera.height + 100);
            minHeight = Math.max(0, Math.min(...terrainHeights) - 20);
            const heightRange = maxHeight - minHeight;
            
            // Draw altitude scale lines (horizontal reference lines)
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let alt = 0; alt <= maxHeight; alt += 100) {
                if (alt < minHeight) continue;
                const y = graphY + graphHeight - ((alt - minHeight) / heightRange) * graphHeight;
                if (y >= graphY && y <= graphY + graphHeight) {
                    ctx.beginPath();
                    ctx.moveTo(graphX, y);
                    ctx.lineTo(graphX + graphWidth, y);
                    ctx.stroke();
                }
            }
            
            // Draw terrain profile (filled polygon)
            ctx.fillStyle = 'rgba(139, 90, 43, 0.6)';  // Brown terrain fill
            ctx.strokeStyle = '#8B5A2B';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(graphX, graphY + graphHeight);  // Start at bottom left
            
            for (let i = 0; i < numSamples; i++) {
                const x = graphX + (i / numSamples) * graphWidth;
                const normalizedHeight = (terrainHeights[i] - minHeight) / heightRange;
                const y = graphY + graphHeight - normalizedHeight * graphHeight;
                
                if (i === 0) {
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.lineTo(graphX + graphWidth, graphY + graphHeight);  // Bottom right
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw helicopter altitude line (current flight path)
            const heliAltY = graphY + graphHeight - ((camera.height - minHeight) / heightRange) * graphHeight;
            
            // Helicopter altitude as dashed line
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(graphX, heliAltY);
            ctx.lineTo(graphX + graphWidth, heliAltY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw helicopter icon at left (current position)
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(graphX - 2, heliAltY);
            ctx.lineTo(graphX + 6, heliAltY - 4);
            ctx.lineTo(graphX + 6, heliAltY + 4);
            ctx.closePath();
            ctx.fill();
            
            // Collision warning - check if terrain ahead is higher than current altitude
            let collisionWarning = false;
            let warningDist = 0;
            for (let i = 0; i < numSamples; i++) {
                if (terrainHeights[i] > camera.height - 20) {  // 20 unit clearance
                    collisionWarning = true;
                    warningDist = (i / numSamples) * scanRange;
                    break;
                }
            }
            
            if (collisionWarning) {
                const blinkOn = Math.floor(performance.now() / 200) % 2 === 0;
                if (blinkOn) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = 'bold 10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('PULL UP', tfX + tfWidth / 2, tfY + tfHeight - 3);
                    
                    // Mark collision point on radar
                    const warnX = graphX + (warningDist / scanRange) * graphWidth;
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(warnX, graphY);
                    ctx.lineTo(warnX, graphY + graphHeight);
                    ctx.stroke();
                }
            }
            
            // Current altitude readout
            ctx.font = '9px Courier New';
            ctx.fillStyle = '#0f0';
            ctx.textAlign = 'left';
            ctx.fillText(`ALT:${Math.floor(camera.height)}`, tfX + 4, tfY + tfHeight - 3);
            
            // Range indicator
            ctx.textAlign = 'right';
            ctx.fillText(`${scanRange}m`, tfX + tfWidth - 4, tfY + tfHeight - 3);
        }
        
        function drawVerticalLine(x, ytop, ybottom, color) {
            // Clamp to screen bounds
            if (ytop < 0) ytop = 0;
            if (ytop >= ybottom) return;
            
            // Calculate buffer offset
            let offset = ytop * screenWidth + x;
            
            // Draw vertical line
            for (let y = ytop; y < ybottom; y++) {
                buf32[offset] = color;
                offset += screenWidth;
            }
        }
        
        function blendWithFog(color, factor) {
            // Extract ABGR components
            const a = (color >> 24) & 0xFF;
            const b = (color >> 16) & 0xFF;
            const g = (color >> 8) & 0xFF;
            const r = color & 0xFF;
            
            // Sky color components (ABGR: 0xFF8090E0)
            const skyR = 0xE0;
            const skyG = 0x90;
            const skyB = 0x80;
            
            // Blend with fog
            const newR = Math.floor(r + (skyR - r) * factor);
            const newG = Math.floor(g + (skyG - g) * factor);
            const newB = Math.floor(b + (skyB - b) * factor);
            
            return (a << 24) | (newB << 16) | (newG << 8) | newR;
        }
        
        function blendWithWeatherFog(color, factor, skyColor) {
            // Extract ABGR components from terrain color
            const a = (color >> 24) & 0xFF;
            const b = (color >> 16) & 0xFF;
            const g = (color >> 8) & 0xFF;
            const r = color & 0xFF;
            
            // Extract sky color components (ABGR format)
            const skyR = skyColor & 0xFF;
            const skyG = (skyColor >> 8) & 0xFF;
            const skyB = (skyColor >> 16) & 0xFF;
            
            // Blend toward sky color
            const newR = Math.floor(r + (skyR - r) * factor);
            const newG = Math.floor(g + (skyG - g) * factor);
            const newB = Math.floor(b + (skyB - b) * factor);
            
            return (a << 24) | (newB << 16) | (newG << 8) | newR;
        }
        
        function applyAmbient(color, ambient) {
            // Extract ABGR components
            const a = (color >> 24) & 0xFF;
            const b = (color >> 16) & 0xFF;
            const g = (color >> 8) & 0xFF;
            const r = color & 0xFF;
            
            // Darken by ambient factor
            const newR = Math.floor(r * ambient);
            const newG = Math.floor(g * ambient);
            const newB = Math.floor(b * ambient);
            
            return (a << 24) | (newB << 16) | (newG << 8) | newR;
        }
        
        // ============================================
        // UI UPDATE
        // ============================================
        function updateUI() {
            // FPS counter removed from display
            // document.getElementById('fps').textContent = `FPS: ${fps}`;
            // Hide the old UI elements since we have the HUD now
            document.getElementById('altitude').style.display = 'none';
            document.getElementById('speed').style.display = 'none';
        }

        function updateOverlayVisibility() {
            const mapSelector = document.getElementById('mapSelector');
            const controls = document.getElementById('controls');
            const ui = document.getElementById('ui');

            mapSelector.style.display = (gameState === GAME_STATES.FREEPLAY) ? 'block' : 'none';
            // Hide HTML UI overlay in Delta mode - it overlaps with the weapon panel
            // In Comanche mode, the FPS counter is fine at top-left (above the top bar)
            ui.style.display = (gameState === GAME_STATES.PLAYING && gameMode !== GAME_MODES.DELTA) ? 'block' : 'none';
            if (gameState !== GAME_STATES.PLAYING && gameState !== GAME_STATES.PAUSED) {
                controls.style.display = 'none';
            }
        }

        function isMenuState(state) {
            return state === GAME_STATES.TITLE ||
                state === GAME_STATES.MENU ||
                state === GAME_STATES.CAMPAIGN ||
                state === GAME_STATES.FREEPLAY ||
                state === GAME_STATES.SETTINGS ||
                state === GAME_STATES.ACHIEVEMENTS ||
                state === GAME_STATES.LEADERBOARD ||
                state === GAME_STATES.HOWTO ||
                state === GAME_STATES.BRIEFING ||
                state === GAME_STATES.MISSION_GENERATOR;
        }
        
        // ============================================
        // GAME LOOP
        // ============================================
        function gameLoop(timestamp) {
            const rawDelta = timestamp - lastTime;
            const deltaTime = Math.min(50, Math.max(0, rawDelta));
            lastTime = timestamp;
            
            // FPS calculation
            frameCount++;
            if (timestamp - fpsUpdateTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                fpsUpdateTime = timestamp;
            }
            
            // Update based on game state
            if (gameState === GAME_STATES.PLAYING) {
                // Update mission timer
                updateMissionTimer();
                updatePlaytime(deltaTime);
                updateTelemetry(deltaTime);
                updateAlertLevel(deltaTime);
                
                // Update player movement and combat
                if (!isPlayerDead && !missionComplete) {
                    handleInput(deltaTime);
                    handleCombatInput(deltaTime);

                    // In Comanche mode, sync heli state from camera
                    if (gameMode === GAME_MODES.COMANCHE) {
                        playerState.heli.x = camera.x;
                        playerState.heli.y = camera.y;
                        playerState.heli.z = camera.height;
                        playerState.heli.angle = camera.angle;
                        playerState.heli.bank = camera.bank;
                        playerState.heli.forwardSpeed = camera.forwardSpeed;
                        playerState.heli.lateralSpeed = camera.lateralSpeed;
                        playerState.heli.verticalSpeed = camera.verticalSpeed;
                    } else if (gameMode === GAME_MODES.DELTA) {
                        playerState.soldier.x = camera.x;
                        playerState.soldier.y = camera.y;
                        playerState.soldier.stance = SOLDIER.stance;
                    }
                    
                    // Update combat systems
                    updateProjectiles(deltaTime);
                    checkProjectileHits();
                    updateExplosions(deltaTime);
                    updateParticles(deltaTime);
                    
                    // Update enemy AI and projectiles
                    updateEnemyAI(deltaTime, timestamp);
                    updateEnemyProjectiles(deltaTime);
                    updateAirstrikePlanes(deltaTime);
                    updateAirportSpawns(timestamp);
                    updateHelipadSpawns(timestamp);
                    
                    // Update warning systems
                    updateMissileWarning(deltaTime);
                    
                    // Update targeting system
                    updateTargetingSystem(deltaTime);
                    
                    // Update resupply at friendly base
                    updateResupply(timestamp);
                    
                    // Update objective progress for position and time-based objectives
                    updateObjectiveProgress('position_update', { x: camera.x, y: camera.y });
                    updateObjectiveProgress('time_update', {});
                    checkAllObjectivesComplete();
                    
                    checkWinCondition();
                }

                // Update combat feedback (always decay in PLAYING)
                updateCombatFeedback(deltaTime);
                updateScreenShake(deltaTime);
                updateScreenFlash(deltaTime);

                updateRotorSound();
                updateWindSound();
            } else if (isMenuState(gameState)) {
                // Slow camera rotation for menu background
                camera.angle += 0.001;
            }

            // Keep feedback effects decaying when out of combat
            if (gameState !== GAME_STATES.PLAYING) {
                updateCombatFeedback(deltaTime);
                updateScreenShake(deltaTime);
                updateScreenFlash(deltaTime);
            }
            
            // Update weather effects (rain particles, lightning)
            updateRainParticles(deltaTime);
            
            // Update transition
            updateTransition(timestamp);

            // Render (always render)
            render();

            updateOverlayVisibility();
            
            // Update UI (only during gameplay)
            if (gameState === GAME_STATES.PLAYING) {
                updateUI();
            }
            
            // Next frame
            requestAnimationFrame(gameLoop);
        }
        
        // ============================================
        // GLOBAL FUNCTIONS (exposed for UI controls)
        // ============================================
        window.updateDistance = function(value) {
            camera.distance = parseInt(value);
            document.getElementById('distanceValue').textContent = value;
            settings.drawDistance = camera.distance;
            saveSettings();
        };
        
        // ============================================
        // START
        // ============================================
        window.addEventListener('load', init);
    })();
    </script>
</body>
</html>
